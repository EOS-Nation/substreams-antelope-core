#[allow(dead_code)]
const IMPL_MESSAGE_SERDE_FOR_ACTION_TRACES: () = {
    use ::prost_wkt::typetag;
    #[typetag::serde(name = "type.googleapis.com/sf.antelope.type.v1.ActionTraces")]
    impl ::prost_wkt::MessageSerde for ActionTraces {
        fn package_name(&self) -> &'static str { "sf.antelope.type.v1" }
        fn message_name(&self) -> &'static str { "ActionTraces" }
        fn type_url(&self) -> &'static str { "type.googleapis.com/sf.antelope.type.v1.ActionTraces" }
        fn new_instance(&self, data: Vec<u8>) -> ::std::result::Result<Box<dyn ::prost_wkt::MessageSerde>, ::prost::DecodeError> {
            let mut target = Self::default();
            ::prost::Message::merge(&mut target, data.as_slice())?;
            let erased: ::std::boxed::Box<dyn ::prost_wkt::MessageSerde> = ::std::boxed::Box::new(target);
            Ok(erased)
        }
        fn try_encoded(&self) -> ::std::result::Result<::std::vec::Vec<u8>, ::prost::EncodeError> {
            let mut buf = ::std::vec::Vec::new();
            buf.reserve(::prost::Message::encoded_len(self));
            ::prost::Message::encode(self, &mut buf)?;
            Ok(buf)
        }
    }
    ::prost_wkt::inventory::submit! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.ActionTraces" , decoder : | buf : & [u8] | { let msg : ActionTraces = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } }
};

#[allow(dead_code)]
const IMPL_MESSAGE_SERDE_FOR_TRANSACTION_TRACES: () = {
    use ::prost_wkt::typetag;
    #[typetag::serde(name = "type.googleapis.com/sf.antelope.type.v1.TransactionTraces")]
    impl ::prost_wkt::MessageSerde for TransactionTraces {
        fn package_name(&self) -> &'static str { "sf.antelope.type.v1" }
        fn message_name(&self) -> &'static str { "TransactionTraces" }
        fn type_url(&self) -> &'static str { "type.googleapis.com/sf.antelope.type.v1.TransactionTraces" }
        fn new_instance(&self, data: Vec<u8>) -> ::std::result::Result<Box<dyn ::prost_wkt::MessageSerde>, ::prost::DecodeError> {
            let mut target = Self::default();
            ::prost::Message::merge(&mut target, data.as_slice())?;
            let erased: ::std::boxed::Box<dyn ::prost_wkt::MessageSerde> = ::std::boxed::Box::new(target);
            Ok(erased)
        }
        fn try_encoded(&self) -> ::std::result::Result<::std::vec::Vec<u8>, ::prost::EncodeError> {
            let mut buf = ::std::vec::Vec::new();
            buf.reserve(::prost::Message::encoded_len(self));
            ::prost::Message::encode(self, &mut buf)?;
            Ok(buf)
        }
    }
    ::prost_wkt::inventory::submit! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.TransactionTraces" , decoder : | buf : & [u8] | { let msg : TransactionTraces = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } }
};

#[allow(dead_code)]
const IMPL_MESSAGE_SERDE_FOR_DB_OPS: () = {
    use ::prost_wkt::typetag;
    #[typetag::serde(name = "type.googleapis.com/sf.antelope.type.v1.DBOps")]
    impl ::prost_wkt::MessageSerde for DbOps {
        fn package_name(&self) -> &'static str { "sf.antelope.type.v1" }
        fn message_name(&self) -> &'static str { "DBOps" }
        fn type_url(&self) -> &'static str { "type.googleapis.com/sf.antelope.type.v1.DBOps" }
        fn new_instance(&self, data: Vec<u8>) -> ::std::result::Result<Box<dyn ::prost_wkt::MessageSerde>, ::prost::DecodeError> {
            let mut target = Self::default();
            ::prost::Message::merge(&mut target, data.as_slice())?;
            let erased: ::std::boxed::Box<dyn ::prost_wkt::MessageSerde> = ::std::boxed::Box::new(target);
            Ok(erased)
        }
        fn try_encoded(&self) -> ::std::result::Result<::std::vec::Vec<u8>, ::prost::EncodeError> {
            let mut buf = ::std::vec::Vec::new();
            buf.reserve(::prost::Message::encoded_len(self));
            ::prost::Message::encode(self, &mut buf)?;
            Ok(buf)
        }
    }
    ::prost_wkt::inventory::submit! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.DBOps" , decoder : | buf : & [u8] | { let msg : DbOps = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } }
};

#[allow(dead_code)]
const IMPL_MESSAGE_SERDE_FOR_BLOCK: () = {
    use ::prost_wkt::typetag;
    #[typetag::serde(name = "type.googleapis.com/sf.antelope.type.v1.Block")]
    impl ::prost_wkt::MessageSerde for Block {
        fn package_name(&self) -> &'static str { "sf.antelope.type.v1" }
        fn message_name(&self) -> &'static str { "Block" }
        fn type_url(&self) -> &'static str { "type.googleapis.com/sf.antelope.type.v1.Block" }
        fn new_instance(&self, data: Vec<u8>) -> ::std::result::Result<Box<dyn ::prost_wkt::MessageSerde>, ::prost::DecodeError> {
            let mut target = Self::default();
            ::prost::Message::merge(&mut target, data.as_slice())?;
            let erased: ::std::boxed::Box<dyn ::prost_wkt::MessageSerde> = ::std::boxed::Box::new(target);
            Ok(erased)
        }
        fn try_encoded(&self) -> ::std::result::Result<::std::vec::Vec<u8>, ::prost::EncodeError> {
            let mut buf = ::std::vec::Vec::new();
            buf.reserve(::prost::Message::encoded_len(self));
            ::prost::Message::encode(self, &mut buf)?;
            Ok(buf)
        }
    }
    ::prost_wkt::inventory::submit! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.Block" , decoder : | buf : & [u8] | { let msg : Block = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } }
};

#[allow(dead_code)]
const IMPL_MESSAGE_SERDE_FOR_BLOCK_WITH_REFS: () = {
    use ::prost_wkt::typetag;
    #[typetag::serde(name = "type.googleapis.com/sf.antelope.type.v1.BlockWithRefs")]
    impl ::prost_wkt::MessageSerde for BlockWithRefs {
        fn package_name(&self) -> &'static str { "sf.antelope.type.v1" }
        fn message_name(&self) -> &'static str { "BlockWithRefs" }
        fn type_url(&self) -> &'static str { "type.googleapis.com/sf.antelope.type.v1.BlockWithRefs" }
        fn new_instance(&self, data: Vec<u8>) -> ::std::result::Result<Box<dyn ::prost_wkt::MessageSerde>, ::prost::DecodeError> {
            let mut target = Self::default();
            ::prost::Message::merge(&mut target, data.as_slice())?;
            let erased: ::std::boxed::Box<dyn ::prost_wkt::MessageSerde> = ::std::boxed::Box::new(target);
            Ok(erased)
        }
        fn try_encoded(&self) -> ::std::result::Result<::std::vec::Vec<u8>, ::prost::EncodeError> {
            let mut buf = ::std::vec::Vec::new();
            buf.reserve(::prost::Message::encoded_len(self));
            ::prost::Message::encode(self, &mut buf)?;
            Ok(buf)
        }
    }
    ::prost_wkt::inventory::submit! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.BlockWithRefs" , decoder : | buf : & [u8] | { let msg : BlockWithRefs = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } }
};

#[allow(dead_code)]
const IMPL_MESSAGE_SERDE_FOR_TRANSACTION_REFS: () = {
    use ::prost_wkt::typetag;
    #[typetag::serde(name = "type.googleapis.com/sf.antelope.type.v1.TransactionRefs")]
    impl ::prost_wkt::MessageSerde for TransactionRefs {
        fn package_name(&self) -> &'static str { "sf.antelope.type.v1" }
        fn message_name(&self) -> &'static str { "TransactionRefs" }
        fn type_url(&self) -> &'static str { "type.googleapis.com/sf.antelope.type.v1.TransactionRefs" }
        fn new_instance(&self, data: Vec<u8>) -> ::std::result::Result<Box<dyn ::prost_wkt::MessageSerde>, ::prost::DecodeError> {
            let mut target = Self::default();
            ::prost::Message::merge(&mut target, data.as_slice())?;
            let erased: ::std::boxed::Box<dyn ::prost_wkt::MessageSerde> = ::std::boxed::Box::new(target);
            Ok(erased)
        }
        fn try_encoded(&self) -> ::std::result::Result<::std::vec::Vec<u8>, ::prost::EncodeError> {
            let mut buf = ::std::vec::Vec::new();
            buf.reserve(::prost::Message::encoded_len(self));
            ::prost::Message::encode(self, &mut buf)?;
            Ok(buf)
        }
    }
    ::prost_wkt::inventory::submit! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.TransactionRefs" , decoder : | buf : & [u8] | { let msg : TransactionRefs = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } }
};

#[allow(dead_code)]
const IMPL_MESSAGE_SERDE_FOR_ACTIVATED_PROTOCOL_FEATURES: () = {
    use ::prost_wkt::typetag;
    #[typetag::serde(name = "type.googleapis.com/sf.antelope.type.v1.ActivatedProtocolFeatures")]
    impl ::prost_wkt::MessageSerde for ActivatedProtocolFeatures {
        fn package_name(&self) -> &'static str { "sf.antelope.type.v1" }
        fn message_name(&self) -> &'static str { "ActivatedProtocolFeatures" }
        fn type_url(&self) -> &'static str { "type.googleapis.com/sf.antelope.type.v1.ActivatedProtocolFeatures" }
        fn new_instance(&self, data: Vec<u8>) -> ::std::result::Result<Box<dyn ::prost_wkt::MessageSerde>, ::prost::DecodeError> {
            let mut target = Self::default();
            ::prost::Message::merge(&mut target, data.as_slice())?;
            let erased: ::std::boxed::Box<dyn ::prost_wkt::MessageSerde> = ::std::boxed::Box::new(target);
            Ok(erased)
        }
        fn try_encoded(&self) -> ::std::result::Result<::std::vec::Vec<u8>, ::prost::EncodeError> {
            let mut buf = ::std::vec::Vec::new();
            buf.reserve(::prost::Message::encoded_len(self));
            ::prost::Message::encode(self, &mut buf)?;
            Ok(buf)
        }
    }
    ::prost_wkt::inventory::submit! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.ActivatedProtocolFeatures" , decoder : | buf : & [u8] | { let msg : ActivatedProtocolFeatures = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } }
};

#[allow(dead_code)]
const IMPL_MESSAGE_SERDE_FOR_PENDING_PRODUCER_SCHEDULE: () = {
    use ::prost_wkt::typetag;
    #[typetag::serde(name = "type.googleapis.com/sf.antelope.type.v1.PendingProducerSchedule")]
    impl ::prost_wkt::MessageSerde for PendingProducerSchedule {
        fn package_name(&self) -> &'static str { "sf.antelope.type.v1" }
        fn message_name(&self) -> &'static str { "PendingProducerSchedule" }
        fn type_url(&self) -> &'static str { "type.googleapis.com/sf.antelope.type.v1.PendingProducerSchedule" }
        fn new_instance(&self, data: Vec<u8>) -> ::std::result::Result<Box<dyn ::prost_wkt::MessageSerde>, ::prost::DecodeError> {
            let mut target = Self::default();
            ::prost::Message::merge(&mut target, data.as_slice())?;
            let erased: ::std::boxed::Box<dyn ::prost_wkt::MessageSerde> = ::std::boxed::Box::new(target);
            Ok(erased)
        }
        fn try_encoded(&self) -> ::std::result::Result<::std::vec::Vec<u8>, ::prost::EncodeError> {
            let mut buf = ::std::vec::Vec::new();
            buf.reserve(::prost::Message::encoded_len(self));
            ::prost::Message::encode(self, &mut buf)?;
            Ok(buf)
        }
    }
    ::prost_wkt::inventory::submit! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.PendingProducerSchedule" , decoder : | buf : & [u8] | { let msg : PendingProducerSchedule = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } }
};

#[allow(dead_code)]
const IMPL_MESSAGE_SERDE_FOR_PRODUCER_SCHEDULE: () = {
    use ::prost_wkt::typetag;
    #[typetag::serde(name = "type.googleapis.com/sf.antelope.type.v1.ProducerSchedule")]
    impl ::prost_wkt::MessageSerde for ProducerSchedule {
        fn package_name(&self) -> &'static str { "sf.antelope.type.v1" }
        fn message_name(&self) -> &'static str { "ProducerSchedule" }
        fn type_url(&self) -> &'static str { "type.googleapis.com/sf.antelope.type.v1.ProducerSchedule" }
        fn new_instance(&self, data: Vec<u8>) -> ::std::result::Result<Box<dyn ::prost_wkt::MessageSerde>, ::prost::DecodeError> {
            let mut target = Self::default();
            ::prost::Message::merge(&mut target, data.as_slice())?;
            let erased: ::std::boxed::Box<dyn ::prost_wkt::MessageSerde> = ::std::boxed::Box::new(target);
            Ok(erased)
        }
        fn try_encoded(&self) -> ::std::result::Result<::std::vec::Vec<u8>, ::prost::EncodeError> {
            let mut buf = ::std::vec::Vec::new();
            buf.reserve(::prost::Message::encoded_len(self));
            ::prost::Message::encode(self, &mut buf)?;
            Ok(buf)
        }
    }
    ::prost_wkt::inventory::submit! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.ProducerSchedule" , decoder : | buf : & [u8] | { let msg : ProducerSchedule = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } }
};

#[allow(dead_code)]
const IMPL_MESSAGE_SERDE_FOR_PRODUCER_KEY: () = {
    use ::prost_wkt::typetag;
    #[typetag::serde(name = "type.googleapis.com/sf.antelope.type.v1.ProducerKey")]
    impl ::prost_wkt::MessageSerde for ProducerKey {
        fn package_name(&self) -> &'static str { "sf.antelope.type.v1" }
        fn message_name(&self) -> &'static str { "ProducerKey" }
        fn type_url(&self) -> &'static str { "type.googleapis.com/sf.antelope.type.v1.ProducerKey" }
        fn new_instance(&self, data: Vec<u8>) -> ::std::result::Result<Box<dyn ::prost_wkt::MessageSerde>, ::prost::DecodeError> {
            let mut target = Self::default();
            ::prost::Message::merge(&mut target, data.as_slice())?;
            let erased: ::std::boxed::Box<dyn ::prost_wkt::MessageSerde> = ::std::boxed::Box::new(target);
            Ok(erased)
        }
        fn try_encoded(&self) -> ::std::result::Result<::std::vec::Vec<u8>, ::prost::EncodeError> {
            let mut buf = ::std::vec::Vec::new();
            buf.reserve(::prost::Message::encoded_len(self));
            ::prost::Message::encode(self, &mut buf)?;
            Ok(buf)
        }
    }
    ::prost_wkt::inventory::submit! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.ProducerKey" , decoder : | buf : & [u8] | { let msg : ProducerKey = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } }
};

#[allow(dead_code)]
const IMPL_MESSAGE_SERDE_FOR_PRODUCER_AUTHORITY_SCHEDULE: () = {
    use ::prost_wkt::typetag;
    #[typetag::serde(name = "type.googleapis.com/sf.antelope.type.v1.ProducerAuthoritySchedule")]
    impl ::prost_wkt::MessageSerde for ProducerAuthoritySchedule {
        fn package_name(&self) -> &'static str { "sf.antelope.type.v1" }
        fn message_name(&self) -> &'static str { "ProducerAuthoritySchedule" }
        fn type_url(&self) -> &'static str { "type.googleapis.com/sf.antelope.type.v1.ProducerAuthoritySchedule" }
        fn new_instance(&self, data: Vec<u8>) -> ::std::result::Result<Box<dyn ::prost_wkt::MessageSerde>, ::prost::DecodeError> {
            let mut target = Self::default();
            ::prost::Message::merge(&mut target, data.as_slice())?;
            let erased: ::std::boxed::Box<dyn ::prost_wkt::MessageSerde> = ::std::boxed::Box::new(target);
            Ok(erased)
        }
        fn try_encoded(&self) -> ::std::result::Result<::std::vec::Vec<u8>, ::prost::EncodeError> {
            let mut buf = ::std::vec::Vec::new();
            buf.reserve(::prost::Message::encoded_len(self));
            ::prost::Message::encode(self, &mut buf)?;
            Ok(buf)
        }
    }
    ::prost_wkt::inventory::submit! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.ProducerAuthoritySchedule" , decoder : | buf : & [u8] | { let msg : ProducerAuthoritySchedule = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } }
};

#[allow(dead_code)]
const IMPL_MESSAGE_SERDE_FOR_PRODUCER_AUTHORITY: () = {
    use ::prost_wkt::typetag;
    #[typetag::serde(name = "type.googleapis.com/sf.antelope.type.v1.ProducerAuthority")]
    impl ::prost_wkt::MessageSerde for ProducerAuthority {
        fn package_name(&self) -> &'static str { "sf.antelope.type.v1" }
        fn message_name(&self) -> &'static str { "ProducerAuthority" }
        fn type_url(&self) -> &'static str { "type.googleapis.com/sf.antelope.type.v1.ProducerAuthority" }
        fn new_instance(&self, data: Vec<u8>) -> ::std::result::Result<Box<dyn ::prost_wkt::MessageSerde>, ::prost::DecodeError> {
            let mut target = Self::default();
            ::prost::Message::merge(&mut target, data.as_slice())?;
            let erased: ::std::boxed::Box<dyn ::prost_wkt::MessageSerde> = ::std::boxed::Box::new(target);
            Ok(erased)
        }
        fn try_encoded(&self) -> ::std::result::Result<::std::vec::Vec<u8>, ::prost::EncodeError> {
            let mut buf = ::std::vec::Vec::new();
            buf.reserve(::prost::Message::encoded_len(self));
            ::prost::Message::encode(self, &mut buf)?;
            Ok(buf)
        }
    }
    ::prost_wkt::inventory::submit! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.ProducerAuthority" , decoder : | buf : & [u8] | { let msg : ProducerAuthority = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } }
};

#[allow(dead_code)]
const IMPL_MESSAGE_SERDE_FOR_BLOCK_SIGNING_AUTHORITY: () = {
    use ::prost_wkt::typetag;
    #[typetag::serde(name = "type.googleapis.com/sf.antelope.type.v1.BlockSigningAuthority")]
    impl ::prost_wkt::MessageSerde for BlockSigningAuthority {
        fn package_name(&self) -> &'static str { "sf.antelope.type.v1" }
        fn message_name(&self) -> &'static str { "BlockSigningAuthority" }
        fn type_url(&self) -> &'static str { "type.googleapis.com/sf.antelope.type.v1.BlockSigningAuthority" }
        fn new_instance(&self, data: Vec<u8>) -> ::std::result::Result<Box<dyn ::prost_wkt::MessageSerde>, ::prost::DecodeError> {
            let mut target = Self::default();
            ::prost::Message::merge(&mut target, data.as_slice())?;
            let erased: ::std::boxed::Box<dyn ::prost_wkt::MessageSerde> = ::std::boxed::Box::new(target);
            Ok(erased)
        }
        fn try_encoded(&self) -> ::std::result::Result<::std::vec::Vec<u8>, ::prost::EncodeError> {
            let mut buf = ::std::vec::Vec::new();
            buf.reserve(::prost::Message::encoded_len(self));
            ::prost::Message::encode(self, &mut buf)?;
            Ok(buf)
        }
    }
    ::prost_wkt::inventory::submit! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.BlockSigningAuthority" , decoder : | buf : & [u8] | { let msg : BlockSigningAuthority = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } }
};

#[allow(dead_code)]
const IMPL_MESSAGE_SERDE_FOR_BLOCK_SIGNING_AUTHORITY_V0: () = {
    use ::prost_wkt::typetag;
    #[typetag::serde(name = "type.googleapis.com/sf.antelope.type.v1.BlockSigningAuthorityV0")]
    impl ::prost_wkt::MessageSerde for BlockSigningAuthorityV0 {
        fn package_name(&self) -> &'static str { "sf.antelope.type.v1" }
        fn message_name(&self) -> &'static str { "BlockSigningAuthorityV0" }
        fn type_url(&self) -> &'static str { "type.googleapis.com/sf.antelope.type.v1.BlockSigningAuthorityV0" }
        fn new_instance(&self, data: Vec<u8>) -> ::std::result::Result<Box<dyn ::prost_wkt::MessageSerde>, ::prost::DecodeError> {
            let mut target = Self::default();
            ::prost::Message::merge(&mut target, data.as_slice())?;
            let erased: ::std::boxed::Box<dyn ::prost_wkt::MessageSerde> = ::std::boxed::Box::new(target);
            Ok(erased)
        }
        fn try_encoded(&self) -> ::std::result::Result<::std::vec::Vec<u8>, ::prost::EncodeError> {
            let mut buf = ::std::vec::Vec::new();
            buf.reserve(::prost::Message::encoded_len(self));
            ::prost::Message::encode(self, &mut buf)?;
            Ok(buf)
        }
    }
    ::prost_wkt::inventory::submit! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.BlockSigningAuthorityV0" , decoder : | buf : & [u8] | { let msg : BlockSigningAuthorityV0 = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } }
};

#[allow(dead_code)]
const IMPL_MESSAGE_SERDE_FOR_BLOCK_ROOT_MERKLE: () = {
    use ::prost_wkt::typetag;
    #[typetag::serde(name = "type.googleapis.com/sf.antelope.type.v1.BlockRootMerkle")]
    impl ::prost_wkt::MessageSerde for BlockRootMerkle {
        fn package_name(&self) -> &'static str { "sf.antelope.type.v1" }
        fn message_name(&self) -> &'static str { "BlockRootMerkle" }
        fn type_url(&self) -> &'static str { "type.googleapis.com/sf.antelope.type.v1.BlockRootMerkle" }
        fn new_instance(&self, data: Vec<u8>) -> ::std::result::Result<Box<dyn ::prost_wkt::MessageSerde>, ::prost::DecodeError> {
            let mut target = Self::default();
            ::prost::Message::merge(&mut target, data.as_slice())?;
            let erased: ::std::boxed::Box<dyn ::prost_wkt::MessageSerde> = ::std::boxed::Box::new(target);
            Ok(erased)
        }
        fn try_encoded(&self) -> ::std::result::Result<::std::vec::Vec<u8>, ::prost::EncodeError> {
            let mut buf = ::std::vec::Vec::new();
            buf.reserve(::prost::Message::encoded_len(self));
            ::prost::Message::encode(self, &mut buf)?;
            Ok(buf)
        }
    }
    ::prost_wkt::inventory::submit! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.BlockRootMerkle" , decoder : | buf : & [u8] | { let msg : BlockRootMerkle = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } }
};

#[allow(dead_code)]
const IMPL_MESSAGE_SERDE_FOR_PRODUCER_TO_LAST_PRODUCED: () = {
    use ::prost_wkt::typetag;
    #[typetag::serde(name = "type.googleapis.com/sf.antelope.type.v1.ProducerToLastProduced")]
    impl ::prost_wkt::MessageSerde for ProducerToLastProduced {
        fn package_name(&self) -> &'static str { "sf.antelope.type.v1" }
        fn message_name(&self) -> &'static str { "ProducerToLastProduced" }
        fn type_url(&self) -> &'static str { "type.googleapis.com/sf.antelope.type.v1.ProducerToLastProduced" }
        fn new_instance(&self, data: Vec<u8>) -> ::std::result::Result<Box<dyn ::prost_wkt::MessageSerde>, ::prost::DecodeError> {
            let mut target = Self::default();
            ::prost::Message::merge(&mut target, data.as_slice())?;
            let erased: ::std::boxed::Box<dyn ::prost_wkt::MessageSerde> = ::std::boxed::Box::new(target);
            Ok(erased)
        }
        fn try_encoded(&self) -> ::std::result::Result<::std::vec::Vec<u8>, ::prost::EncodeError> {
            let mut buf = ::std::vec::Vec::new();
            buf.reserve(::prost::Message::encoded_len(self));
            ::prost::Message::encode(self, &mut buf)?;
            Ok(buf)
        }
    }
    ::prost_wkt::inventory::submit! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.ProducerToLastProduced" , decoder : | buf : & [u8] | { let msg : ProducerToLastProduced = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } }
};

#[allow(dead_code)]
const IMPL_MESSAGE_SERDE_FOR_PRODUCER_TO_LAST_IMPLIED_IRB: () = {
    use ::prost_wkt::typetag;
    #[typetag::serde(name = "type.googleapis.com/sf.antelope.type.v1.ProducerToLastImpliedIRB")]
    impl ::prost_wkt::MessageSerde for ProducerToLastImpliedIrb {
        fn package_name(&self) -> &'static str { "sf.antelope.type.v1" }
        fn message_name(&self) -> &'static str { "ProducerToLastImpliedIRB" }
        fn type_url(&self) -> &'static str { "type.googleapis.com/sf.antelope.type.v1.ProducerToLastImpliedIRB" }
        fn new_instance(&self, data: Vec<u8>) -> ::std::result::Result<Box<dyn ::prost_wkt::MessageSerde>, ::prost::DecodeError> {
            let mut target = Self::default();
            ::prost::Message::merge(&mut target, data.as_slice())?;
            let erased: ::std::boxed::Box<dyn ::prost_wkt::MessageSerde> = ::std::boxed::Box::new(target);
            Ok(erased)
        }
        fn try_encoded(&self) -> ::std::result::Result<::std::vec::Vec<u8>, ::prost::EncodeError> {
            let mut buf = ::std::vec::Vec::new();
            buf.reserve(::prost::Message::encoded_len(self));
            ::prost::Message::encode(self, &mut buf)?;
            Ok(buf)
        }
    }
    ::prost_wkt::inventory::submit! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.ProducerToLastImpliedIRB" , decoder : | buf : & [u8] | { let msg : ProducerToLastImpliedIrb = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } }
};

#[allow(dead_code)]
const IMPL_MESSAGE_SERDE_FOR_TRANSACTION_RECEIPT: () = {
    use ::prost_wkt::typetag;
    #[typetag::serde(name = "type.googleapis.com/sf.antelope.type.v1.TransactionReceipt")]
    impl ::prost_wkt::MessageSerde for TransactionReceipt {
        fn package_name(&self) -> &'static str { "sf.antelope.type.v1" }
        fn message_name(&self) -> &'static str { "TransactionReceipt" }
        fn type_url(&self) -> &'static str { "type.googleapis.com/sf.antelope.type.v1.TransactionReceipt" }
        fn new_instance(&self, data: Vec<u8>) -> ::std::result::Result<Box<dyn ::prost_wkt::MessageSerde>, ::prost::DecodeError> {
            let mut target = Self::default();
            ::prost::Message::merge(&mut target, data.as_slice())?;
            let erased: ::std::boxed::Box<dyn ::prost_wkt::MessageSerde> = ::std::boxed::Box::new(target);
            Ok(erased)
        }
        fn try_encoded(&self) -> ::std::result::Result<::std::vec::Vec<u8>, ::prost::EncodeError> {
            let mut buf = ::std::vec::Vec::new();
            buf.reserve(::prost::Message::encoded_len(self));
            ::prost::Message::encode(self, &mut buf)?;
            Ok(buf)
        }
    }
    ::prost_wkt::inventory::submit! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.TransactionReceipt" , decoder : | buf : & [u8] | { let msg : TransactionReceipt = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } }
};

#[allow(dead_code)]
const IMPL_MESSAGE_SERDE_FOR_PACKED_TRANSACTION: () = {
    use ::prost_wkt::typetag;
    #[typetag::serde(name = "type.googleapis.com/sf.antelope.type.v1.PackedTransaction")]
    impl ::prost_wkt::MessageSerde for PackedTransaction {
        fn package_name(&self) -> &'static str { "sf.antelope.type.v1" }
        fn message_name(&self) -> &'static str { "PackedTransaction" }
        fn type_url(&self) -> &'static str { "type.googleapis.com/sf.antelope.type.v1.PackedTransaction" }
        fn new_instance(&self, data: Vec<u8>) -> ::std::result::Result<Box<dyn ::prost_wkt::MessageSerde>, ::prost::DecodeError> {
            let mut target = Self::default();
            ::prost::Message::merge(&mut target, data.as_slice())?;
            let erased: ::std::boxed::Box<dyn ::prost_wkt::MessageSerde> = ::std::boxed::Box::new(target);
            Ok(erased)
        }
        fn try_encoded(&self) -> ::std::result::Result<::std::vec::Vec<u8>, ::prost::EncodeError> {
            let mut buf = ::std::vec::Vec::new();
            buf.reserve(::prost::Message::encoded_len(self));
            ::prost::Message::encode(self, &mut buf)?;
            Ok(buf)
        }
    }
    ::prost_wkt::inventory::submit! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.PackedTransaction" , decoder : | buf : & [u8] | { let msg : PackedTransaction = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } }
};

#[allow(dead_code)]
const IMPL_MESSAGE_SERDE_FOR_BLOCK_HEADER: () = {
    use ::prost_wkt::typetag;
    #[typetag::serde(name = "type.googleapis.com/sf.antelope.type.v1.BlockHeader")]
    impl ::prost_wkt::MessageSerde for BlockHeader {
        fn package_name(&self) -> &'static str { "sf.antelope.type.v1" }
        fn message_name(&self) -> &'static str { "BlockHeader" }
        fn type_url(&self) -> &'static str { "type.googleapis.com/sf.antelope.type.v1.BlockHeader" }
        fn new_instance(&self, data: Vec<u8>) -> ::std::result::Result<Box<dyn ::prost_wkt::MessageSerde>, ::prost::DecodeError> {
            let mut target = Self::default();
            ::prost::Message::merge(&mut target, data.as_slice())?;
            let erased: ::std::boxed::Box<dyn ::prost_wkt::MessageSerde> = ::std::boxed::Box::new(target);
            Ok(erased)
        }
        fn try_encoded(&self) -> ::std::result::Result<::std::vec::Vec<u8>, ::prost::EncodeError> {
            let mut buf = ::std::vec::Vec::new();
            buf.reserve(::prost::Message::encoded_len(self));
            ::prost::Message::encode(self, &mut buf)?;
            Ok(buf)
        }
    }
    ::prost_wkt::inventory::submit! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.BlockHeader" , decoder : | buf : & [u8] | { let msg : BlockHeader = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } }
};

#[allow(dead_code)]
const IMPL_MESSAGE_SERDE_FOR_TRANSACTION_EVENT: () = {
    use ::prost_wkt::typetag;
    #[typetag::serde(name = "type.googleapis.com/sf.antelope.type.v1.TransactionEvent")]
    impl ::prost_wkt::MessageSerde for TransactionEvent {
        fn package_name(&self) -> &'static str { "sf.antelope.type.v1" }
        fn message_name(&self) -> &'static str { "TransactionEvent" }
        fn type_url(&self) -> &'static str { "type.googleapis.com/sf.antelope.type.v1.TransactionEvent" }
        fn new_instance(&self, data: Vec<u8>) -> ::std::result::Result<Box<dyn ::prost_wkt::MessageSerde>, ::prost::DecodeError> {
            let mut target = Self::default();
            ::prost::Message::merge(&mut target, data.as_slice())?;
            let erased: ::std::boxed::Box<dyn ::prost_wkt::MessageSerde> = ::std::boxed::Box::new(target);
            Ok(erased)
        }
        fn try_encoded(&self) -> ::std::result::Result<::std::vec::Vec<u8>, ::prost::EncodeError> {
            let mut buf = ::std::vec::Vec::new();
            buf.reserve(::prost::Message::encoded_len(self));
            ::prost::Message::encode(self, &mut buf)?;
            Ok(buf)
        }
    }
    ::prost_wkt::inventory::submit! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.TransactionEvent" , decoder : | buf : & [u8] | { let msg : TransactionEvent = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } }
};

#[allow(dead_code)]
const IMPL_MESSAGE_SERDE_FOR_PUBLIC_KEYS: () = {
    use ::prost_wkt::typetag;
    #[typetag::serde(name = "type.googleapis.com/sf.antelope.type.v1.PublicKeys")]
    impl ::prost_wkt::MessageSerde for PublicKeys {
        fn package_name(&self) -> &'static str { "sf.antelope.type.v1" }
        fn message_name(&self) -> &'static str { "PublicKeys" }
        fn type_url(&self) -> &'static str { "type.googleapis.com/sf.antelope.type.v1.PublicKeys" }
        fn new_instance(&self, data: Vec<u8>) -> ::std::result::Result<Box<dyn ::prost_wkt::MessageSerde>, ::prost::DecodeError> {
            let mut target = Self::default();
            ::prost::Message::merge(&mut target, data.as_slice())?;
            let erased: ::std::boxed::Box<dyn ::prost_wkt::MessageSerde> = ::std::boxed::Box::new(target);
            Ok(erased)
        }
        fn try_encoded(&self) -> ::std::result::Result<::std::vec::Vec<u8>, ::prost::EncodeError> {
            let mut buf = ::std::vec::Vec::new();
            buf.reserve(::prost::Message::encoded_len(self));
            ::prost::Message::encode(self, &mut buf)?;
            Ok(buf)
        }
    }
    ::prost_wkt::inventory::submit! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.PublicKeys" , decoder : | buf : & [u8] | { let msg : PublicKeys = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } }
};

#[allow(dead_code)]
const IMPL_MESSAGE_SERDE_FOR_TRANSACTION_LIFECYCLE: () = {
    use ::prost_wkt::typetag;
    #[typetag::serde(name = "type.googleapis.com/sf.antelope.type.v1.TransactionLifecycle")]
    impl ::prost_wkt::MessageSerde for TransactionLifecycle {
        fn package_name(&self) -> &'static str { "sf.antelope.type.v1" }
        fn message_name(&self) -> &'static str { "TransactionLifecycle" }
        fn type_url(&self) -> &'static str { "type.googleapis.com/sf.antelope.type.v1.TransactionLifecycle" }
        fn new_instance(&self, data: Vec<u8>) -> ::std::result::Result<Box<dyn ::prost_wkt::MessageSerde>, ::prost::DecodeError> {
            let mut target = Self::default();
            ::prost::Message::merge(&mut target, data.as_slice())?;
            let erased: ::std::boxed::Box<dyn ::prost_wkt::MessageSerde> = ::std::boxed::Box::new(target);
            Ok(erased)
        }
        fn try_encoded(&self) -> ::std::result::Result<::std::vec::Vec<u8>, ::prost::EncodeError> {
            let mut buf = ::std::vec::Vec::new();
            buf.reserve(::prost::Message::encoded_len(self));
            ::prost::Message::encode(self, &mut buf)?;
            Ok(buf)
        }
    }
    ::prost_wkt::inventory::submit! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.TransactionLifecycle" , decoder : | buf : & [u8] | { let msg : TransactionLifecycle = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } }
};

#[allow(dead_code)]
const IMPL_MESSAGE_SERDE_FOR_SIGNED_TRANSACTION: () = {
    use ::prost_wkt::typetag;
    #[typetag::serde(name = "type.googleapis.com/sf.antelope.type.v1.SignedTransaction")]
    impl ::prost_wkt::MessageSerde for SignedTransaction {
        fn package_name(&self) -> &'static str { "sf.antelope.type.v1" }
        fn message_name(&self) -> &'static str { "SignedTransaction" }
        fn type_url(&self) -> &'static str { "type.googleapis.com/sf.antelope.type.v1.SignedTransaction" }
        fn new_instance(&self, data: Vec<u8>) -> ::std::result::Result<Box<dyn ::prost_wkt::MessageSerde>, ::prost::DecodeError> {
            let mut target = Self::default();
            ::prost::Message::merge(&mut target, data.as_slice())?;
            let erased: ::std::boxed::Box<dyn ::prost_wkt::MessageSerde> = ::std::boxed::Box::new(target);
            Ok(erased)
        }
        fn try_encoded(&self) -> ::std::result::Result<::std::vec::Vec<u8>, ::prost::EncodeError> {
            let mut buf = ::std::vec::Vec::new();
            buf.reserve(::prost::Message::encoded_len(self));
            ::prost::Message::encode(self, &mut buf)?;
            Ok(buf)
        }
    }
    ::prost_wkt::inventory::submit! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.SignedTransaction" , decoder : | buf : & [u8] | { let msg : SignedTransaction = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } }
};

#[allow(dead_code)]
const IMPL_MESSAGE_SERDE_FOR_TRANSACTION: () = {
    use ::prost_wkt::typetag;
    #[typetag::serde(name = "type.googleapis.com/sf.antelope.type.v1.Transaction")]
    impl ::prost_wkt::MessageSerde for Transaction {
        fn package_name(&self) -> &'static str { "sf.antelope.type.v1" }
        fn message_name(&self) -> &'static str { "Transaction" }
        fn type_url(&self) -> &'static str { "type.googleapis.com/sf.antelope.type.v1.Transaction" }
        fn new_instance(&self, data: Vec<u8>) -> ::std::result::Result<Box<dyn ::prost_wkt::MessageSerde>, ::prost::DecodeError> {
            let mut target = Self::default();
            ::prost::Message::merge(&mut target, data.as_slice())?;
            let erased: ::std::boxed::Box<dyn ::prost_wkt::MessageSerde> = ::std::boxed::Box::new(target);
            Ok(erased)
        }
        fn try_encoded(&self) -> ::std::result::Result<::std::vec::Vec<u8>, ::prost::EncodeError> {
            let mut buf = ::std::vec::Vec::new();
            buf.reserve(::prost::Message::encoded_len(self));
            ::prost::Message::encode(self, &mut buf)?;
            Ok(buf)
        }
    }
    ::prost_wkt::inventory::submit! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.Transaction" , decoder : | buf : & [u8] | { let msg : Transaction = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } }
};

#[allow(dead_code)]
const IMPL_MESSAGE_SERDE_FOR_TRANSACTION_HEADER: () = {
    use ::prost_wkt::typetag;
    #[typetag::serde(name = "type.googleapis.com/sf.antelope.type.v1.TransactionHeader")]
    impl ::prost_wkt::MessageSerde for TransactionHeader {
        fn package_name(&self) -> &'static str { "sf.antelope.type.v1" }
        fn message_name(&self) -> &'static str { "TransactionHeader" }
        fn type_url(&self) -> &'static str { "type.googleapis.com/sf.antelope.type.v1.TransactionHeader" }
        fn new_instance(&self, data: Vec<u8>) -> ::std::result::Result<Box<dyn ::prost_wkt::MessageSerde>, ::prost::DecodeError> {
            let mut target = Self::default();
            ::prost::Message::merge(&mut target, data.as_slice())?;
            let erased: ::std::boxed::Box<dyn ::prost_wkt::MessageSerde> = ::std::boxed::Box::new(target);
            Ok(erased)
        }
        fn try_encoded(&self) -> ::std::result::Result<::std::vec::Vec<u8>, ::prost::EncodeError> {
            let mut buf = ::std::vec::Vec::new();
            buf.reserve(::prost::Message::encoded_len(self));
            ::prost::Message::encode(self, &mut buf)?;
            Ok(buf)
        }
    }
    ::prost_wkt::inventory::submit! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.TransactionHeader" , decoder : | buf : & [u8] | { let msg : TransactionHeader = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } }
};

#[allow(dead_code)]
const IMPL_MESSAGE_SERDE_FOR_TRANSACTION_TRACE: () = {
    use ::prost_wkt::typetag;
    #[typetag::serde(name = "type.googleapis.com/sf.antelope.type.v1.TransactionTrace")]
    impl ::prost_wkt::MessageSerde for TransactionTrace {
        fn package_name(&self) -> &'static str { "sf.antelope.type.v1" }
        fn message_name(&self) -> &'static str { "TransactionTrace" }
        fn type_url(&self) -> &'static str { "type.googleapis.com/sf.antelope.type.v1.TransactionTrace" }
        fn new_instance(&self, data: Vec<u8>) -> ::std::result::Result<Box<dyn ::prost_wkt::MessageSerde>, ::prost::DecodeError> {
            let mut target = Self::default();
            ::prost::Message::merge(&mut target, data.as_slice())?;
            let erased: ::std::boxed::Box<dyn ::prost_wkt::MessageSerde> = ::std::boxed::Box::new(target);
            Ok(erased)
        }
        fn try_encoded(&self) -> ::std::result::Result<::std::vec::Vec<u8>, ::prost::EncodeError> {
            let mut buf = ::std::vec::Vec::new();
            buf.reserve(::prost::Message::encoded_len(self));
            ::prost::Message::encode(self, &mut buf)?;
            Ok(buf)
        }
    }
    ::prost_wkt::inventory::submit! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.TransactionTrace" , decoder : | buf : & [u8] | { let msg : TransactionTrace = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } }
};

#[allow(dead_code)]
const IMPL_MESSAGE_SERDE_FOR_TRANSACTION_RECEIPT_HEADER: () = {
    use ::prost_wkt::typetag;
    #[typetag::serde(name = "type.googleapis.com/sf.antelope.type.v1.TransactionReceiptHeader")]
    impl ::prost_wkt::MessageSerde for TransactionReceiptHeader {
        fn package_name(&self) -> &'static str { "sf.antelope.type.v1" }
        fn message_name(&self) -> &'static str { "TransactionReceiptHeader" }
        fn type_url(&self) -> &'static str { "type.googleapis.com/sf.antelope.type.v1.TransactionReceiptHeader" }
        fn new_instance(&self, data: Vec<u8>) -> ::std::result::Result<Box<dyn ::prost_wkt::MessageSerde>, ::prost::DecodeError> {
            let mut target = Self::default();
            ::prost::Message::merge(&mut target, data.as_slice())?;
            let erased: ::std::boxed::Box<dyn ::prost_wkt::MessageSerde> = ::std::boxed::Box::new(target);
            Ok(erased)
        }
        fn try_encoded(&self) -> ::std::result::Result<::std::vec::Vec<u8>, ::prost::EncodeError> {
            let mut buf = ::std::vec::Vec::new();
            buf.reserve(::prost::Message::encoded_len(self));
            ::prost::Message::encode(self, &mut buf)?;
            Ok(buf)
        }
    }
    ::prost_wkt::inventory::submit! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.TransactionReceiptHeader" , decoder : | buf : & [u8] | { let msg : TransactionReceiptHeader = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } }
};

#[allow(dead_code)]
const IMPL_MESSAGE_SERDE_FOR_ACTION: () = {
    use ::prost_wkt::typetag;
    #[typetag::serde(name = "type.googleapis.com/sf.antelope.type.v1.Action")]
    impl ::prost_wkt::MessageSerde for Action {
        fn package_name(&self) -> &'static str { "sf.antelope.type.v1" }
        fn message_name(&self) -> &'static str { "Action" }
        fn type_url(&self) -> &'static str { "type.googleapis.com/sf.antelope.type.v1.Action" }
        fn new_instance(&self, data: Vec<u8>) -> ::std::result::Result<Box<dyn ::prost_wkt::MessageSerde>, ::prost::DecodeError> {
            let mut target = Self::default();
            ::prost::Message::merge(&mut target, data.as_slice())?;
            let erased: ::std::boxed::Box<dyn ::prost_wkt::MessageSerde> = ::std::boxed::Box::new(target);
            Ok(erased)
        }
        fn try_encoded(&self) -> ::std::result::Result<::std::vec::Vec<u8>, ::prost::EncodeError> {
            let mut buf = ::std::vec::Vec::new();
            buf.reserve(::prost::Message::encoded_len(self));
            ::prost::Message::encode(self, &mut buf)?;
            Ok(buf)
        }
    }
    ::prost_wkt::inventory::submit! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.Action" , decoder : | buf : & [u8] | { let msg : Action = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } }
};

#[allow(dead_code)]
const IMPL_MESSAGE_SERDE_FOR_ACTION_TRACE: () = {
    use ::prost_wkt::typetag;
    #[typetag::serde(name = "type.googleapis.com/sf.antelope.type.v1.ActionTrace")]
    impl ::prost_wkt::MessageSerde for ActionTrace {
        fn package_name(&self) -> &'static str { "sf.antelope.type.v1" }
        fn message_name(&self) -> &'static str { "ActionTrace" }
        fn type_url(&self) -> &'static str { "type.googleapis.com/sf.antelope.type.v1.ActionTrace" }
        fn new_instance(&self, data: Vec<u8>) -> ::std::result::Result<Box<dyn ::prost_wkt::MessageSerde>, ::prost::DecodeError> {
            let mut target = Self::default();
            ::prost::Message::merge(&mut target, data.as_slice())?;
            let erased: ::std::boxed::Box<dyn ::prost_wkt::MessageSerde> = ::std::boxed::Box::new(target);
            Ok(erased)
        }
        fn try_encoded(&self) -> ::std::result::Result<::std::vec::Vec<u8>, ::prost::EncodeError> {
            let mut buf = ::std::vec::Vec::new();
            buf.reserve(::prost::Message::encoded_len(self));
            ::prost::Message::encode(self, &mut buf)?;
            Ok(buf)
        }
    }
    ::prost_wkt::inventory::submit! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.ActionTrace" , decoder : | buf : & [u8] | { let msg : ActionTrace = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } }
};

#[allow(dead_code)]
const IMPL_MESSAGE_SERDE_FOR_ACTION_RECEIPT: () = {
    use ::prost_wkt::typetag;
    #[typetag::serde(name = "type.googleapis.com/sf.antelope.type.v1.ActionReceipt")]
    impl ::prost_wkt::MessageSerde for ActionReceipt {
        fn package_name(&self) -> &'static str { "sf.antelope.type.v1" }
        fn message_name(&self) -> &'static str { "ActionReceipt" }
        fn type_url(&self) -> &'static str { "type.googleapis.com/sf.antelope.type.v1.ActionReceipt" }
        fn new_instance(&self, data: Vec<u8>) -> ::std::result::Result<Box<dyn ::prost_wkt::MessageSerde>, ::prost::DecodeError> {
            let mut target = Self::default();
            ::prost::Message::merge(&mut target, data.as_slice())?;
            let erased: ::std::boxed::Box<dyn ::prost_wkt::MessageSerde> = ::std::boxed::Box::new(target);
            Ok(erased)
        }
        fn try_encoded(&self) -> ::std::result::Result<::std::vec::Vec<u8>, ::prost::EncodeError> {
            let mut buf = ::std::vec::Vec::new();
            buf.reserve(::prost::Message::encoded_len(self));
            ::prost::Message::encode(self, &mut buf)?;
            Ok(buf)
        }
    }
    ::prost_wkt::inventory::submit! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.ActionReceipt" , decoder : | buf : & [u8] | { let msg : ActionReceipt = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } }
};

#[allow(dead_code)]
const IMPL_MESSAGE_SERDE_FOR_AUTH_SEQUENCE: () = {
    use ::prost_wkt::typetag;
    #[typetag::serde(name = "type.googleapis.com/sf.antelope.type.v1.AuthSequence")]
    impl ::prost_wkt::MessageSerde for AuthSequence {
        fn package_name(&self) -> &'static str { "sf.antelope.type.v1" }
        fn message_name(&self) -> &'static str { "AuthSequence" }
        fn type_url(&self) -> &'static str { "type.googleapis.com/sf.antelope.type.v1.AuthSequence" }
        fn new_instance(&self, data: Vec<u8>) -> ::std::result::Result<Box<dyn ::prost_wkt::MessageSerde>, ::prost::DecodeError> {
            let mut target = Self::default();
            ::prost::Message::merge(&mut target, data.as_slice())?;
            let erased: ::std::boxed::Box<dyn ::prost_wkt::MessageSerde> = ::std::boxed::Box::new(target);
            Ok(erased)
        }
        fn try_encoded(&self) -> ::std::result::Result<::std::vec::Vec<u8>, ::prost::EncodeError> {
            let mut buf = ::std::vec::Vec::new();
            buf.reserve(::prost::Message::encoded_len(self));
            ::prost::Message::encode(self, &mut buf)?;
            Ok(buf)
        }
    }
    ::prost_wkt::inventory::submit! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.AuthSequence" , decoder : | buf : & [u8] | { let msg : AuthSequence = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } }
};

#[allow(dead_code)]
const IMPL_MESSAGE_SERDE_FOR_ACCOUNT_RAM_DELTA: () = {
    use ::prost_wkt::typetag;
    #[typetag::serde(name = "type.googleapis.com/sf.antelope.type.v1.AccountRAMDelta")]
    impl ::prost_wkt::MessageSerde for AccountRamDelta {
        fn package_name(&self) -> &'static str { "sf.antelope.type.v1" }
        fn message_name(&self) -> &'static str { "AccountRAMDelta" }
        fn type_url(&self) -> &'static str { "type.googleapis.com/sf.antelope.type.v1.AccountRAMDelta" }
        fn new_instance(&self, data: Vec<u8>) -> ::std::result::Result<Box<dyn ::prost_wkt::MessageSerde>, ::prost::DecodeError> {
            let mut target = Self::default();
            ::prost::Message::merge(&mut target, data.as_slice())?;
            let erased: ::std::boxed::Box<dyn ::prost_wkt::MessageSerde> = ::std::boxed::Box::new(target);
            Ok(erased)
        }
        fn try_encoded(&self) -> ::std::result::Result<::std::vec::Vec<u8>, ::prost::EncodeError> {
            let mut buf = ::std::vec::Vec::new();
            buf.reserve(::prost::Message::encoded_len(self));
            ::prost::Message::encode(self, &mut buf)?;
            Ok(buf)
        }
    }
    ::prost_wkt::inventory::submit! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.AccountRAMDelta" , decoder : | buf : & [u8] | { let msg : AccountRamDelta = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } }
};

#[allow(dead_code)]
const IMPL_MESSAGE_SERDE_FOR_ACCOUNT_DELTA: () = {
    use ::prost_wkt::typetag;
    #[typetag::serde(name = "type.googleapis.com/sf.antelope.type.v1.AccountDelta")]
    impl ::prost_wkt::MessageSerde for AccountDelta {
        fn package_name(&self) -> &'static str { "sf.antelope.type.v1" }
        fn message_name(&self) -> &'static str { "AccountDelta" }
        fn type_url(&self) -> &'static str { "type.googleapis.com/sf.antelope.type.v1.AccountDelta" }
        fn new_instance(&self, data: Vec<u8>) -> ::std::result::Result<Box<dyn ::prost_wkt::MessageSerde>, ::prost::DecodeError> {
            let mut target = Self::default();
            ::prost::Message::merge(&mut target, data.as_slice())?;
            let erased: ::std::boxed::Box<dyn ::prost_wkt::MessageSerde> = ::std::boxed::Box::new(target);
            Ok(erased)
        }
        fn try_encoded(&self) -> ::std::result::Result<::std::vec::Vec<u8>, ::prost::EncodeError> {
            let mut buf = ::std::vec::Vec::new();
            buf.reserve(::prost::Message::encoded_len(self));
            ::prost::Message::encode(self, &mut buf)?;
            Ok(buf)
        }
    }
    ::prost_wkt::inventory::submit! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.AccountDelta" , decoder : | buf : & [u8] | { let msg : AccountDelta = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } }
};

#[allow(dead_code)]
const IMPL_MESSAGE_SERDE_FOR_EXTENSION: () = {
    use ::prost_wkt::typetag;
    #[typetag::serde(name = "type.googleapis.com/sf.antelope.type.v1.Extension")]
    impl ::prost_wkt::MessageSerde for Extension {
        fn package_name(&self) -> &'static str { "sf.antelope.type.v1" }
        fn message_name(&self) -> &'static str { "Extension" }
        fn type_url(&self) -> &'static str { "type.googleapis.com/sf.antelope.type.v1.Extension" }
        fn new_instance(&self, data: Vec<u8>) -> ::std::result::Result<Box<dyn ::prost_wkt::MessageSerde>, ::prost::DecodeError> {
            let mut target = Self::default();
            ::prost::Message::merge(&mut target, data.as_slice())?;
            let erased: ::std::boxed::Box<dyn ::prost_wkt::MessageSerde> = ::std::boxed::Box::new(target);
            Ok(erased)
        }
        fn try_encoded(&self) -> ::std::result::Result<::std::vec::Vec<u8>, ::prost::EncodeError> {
            let mut buf = ::std::vec::Vec::new();
            buf.reserve(::prost::Message::encoded_len(self));
            ::prost::Message::encode(self, &mut buf)?;
            Ok(buf)
        }
    }
    ::prost_wkt::inventory::submit! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.Extension" , decoder : | buf : & [u8] | { let msg : Extension = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } }
};

#[allow(dead_code)]
const IMPL_MESSAGE_SERDE_FOR_TRX_OP: () = {
    use ::prost_wkt::typetag;
    #[typetag::serde(name = "type.googleapis.com/sf.antelope.type.v1.TrxOp")]
    impl ::prost_wkt::MessageSerde for TrxOp {
        fn package_name(&self) -> &'static str { "sf.antelope.type.v1" }
        fn message_name(&self) -> &'static str { "TrxOp" }
        fn type_url(&self) -> &'static str { "type.googleapis.com/sf.antelope.type.v1.TrxOp" }
        fn new_instance(&self, data: Vec<u8>) -> ::std::result::Result<Box<dyn ::prost_wkt::MessageSerde>, ::prost::DecodeError> {
            let mut target = Self::default();
            ::prost::Message::merge(&mut target, data.as_slice())?;
            let erased: ::std::boxed::Box<dyn ::prost_wkt::MessageSerde> = ::std::boxed::Box::new(target);
            Ok(erased)
        }
        fn try_encoded(&self) -> ::std::result::Result<::std::vec::Vec<u8>, ::prost::EncodeError> {
            let mut buf = ::std::vec::Vec::new();
            buf.reserve(::prost::Message::encoded_len(self));
            ::prost::Message::encode(self, &mut buf)?;
            Ok(buf)
        }
    }
    ::prost_wkt::inventory::submit! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.TrxOp" , decoder : | buf : & [u8] | { let msg : TrxOp = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } }
};

#[allow(dead_code)]
const IMPL_MESSAGE_SERDE_FOR_DB_OP: () = {
    use ::prost_wkt::typetag;
    #[typetag::serde(name = "type.googleapis.com/sf.antelope.type.v1.DBOp")]
    impl ::prost_wkt::MessageSerde for DbOp {
        fn package_name(&self) -> &'static str { "sf.antelope.type.v1" }
        fn message_name(&self) -> &'static str { "DBOp" }
        fn type_url(&self) -> &'static str { "type.googleapis.com/sf.antelope.type.v1.DBOp" }
        fn new_instance(&self, data: Vec<u8>) -> ::std::result::Result<Box<dyn ::prost_wkt::MessageSerde>, ::prost::DecodeError> {
            let mut target = Self::default();
            ::prost::Message::merge(&mut target, data.as_slice())?;
            let erased: ::std::boxed::Box<dyn ::prost_wkt::MessageSerde> = ::std::boxed::Box::new(target);
            Ok(erased)
        }
        fn try_encoded(&self) -> ::std::result::Result<::std::vec::Vec<u8>, ::prost::EncodeError> {
            let mut buf = ::std::vec::Vec::new();
            buf.reserve(::prost::Message::encoded_len(self));
            ::prost::Message::encode(self, &mut buf)?;
            Ok(buf)
        }
    }
    ::prost_wkt::inventory::submit! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.DBOp" , decoder : | buf : & [u8] | { let msg : DbOp = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } }
};

#[allow(dead_code)]
const IMPL_MESSAGE_SERDE_FOR_RAM_OP: () = {
    use ::prost_wkt::typetag;
    #[typetag::serde(name = "type.googleapis.com/sf.antelope.type.v1.RAMOp")]
    impl ::prost_wkt::MessageSerde for RamOp {
        fn package_name(&self) -> &'static str { "sf.antelope.type.v1" }
        fn message_name(&self) -> &'static str { "RAMOp" }
        fn type_url(&self) -> &'static str { "type.googleapis.com/sf.antelope.type.v1.RAMOp" }
        fn new_instance(&self, data: Vec<u8>) -> ::std::result::Result<Box<dyn ::prost_wkt::MessageSerde>, ::prost::DecodeError> {
            let mut target = Self::default();
            ::prost::Message::merge(&mut target, data.as_slice())?;
            let erased: ::std::boxed::Box<dyn ::prost_wkt::MessageSerde> = ::std::boxed::Box::new(target);
            Ok(erased)
        }
        fn try_encoded(&self) -> ::std::result::Result<::std::vec::Vec<u8>, ::prost::EncodeError> {
            let mut buf = ::std::vec::Vec::new();
            buf.reserve(::prost::Message::encoded_len(self));
            ::prost::Message::encode(self, &mut buf)?;
            Ok(buf)
        }
    }
    ::prost_wkt::inventory::submit! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.RAMOp" , decoder : | buf : & [u8] | { let msg : RamOp = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } }
};

#[allow(dead_code)]
const IMPL_MESSAGE_SERDE_FOR_RAM_CORRECTION_OP: () = {
    use ::prost_wkt::typetag;
    #[typetag::serde(name = "type.googleapis.com/sf.antelope.type.v1.RAMCorrectionOp")]
    impl ::prost_wkt::MessageSerde for RamCorrectionOp {
        fn package_name(&self) -> &'static str { "sf.antelope.type.v1" }
        fn message_name(&self) -> &'static str { "RAMCorrectionOp" }
        fn type_url(&self) -> &'static str { "type.googleapis.com/sf.antelope.type.v1.RAMCorrectionOp" }
        fn new_instance(&self, data: Vec<u8>) -> ::std::result::Result<Box<dyn ::prost_wkt::MessageSerde>, ::prost::DecodeError> {
            let mut target = Self::default();
            ::prost::Message::merge(&mut target, data.as_slice())?;
            let erased: ::std::boxed::Box<dyn ::prost_wkt::MessageSerde> = ::std::boxed::Box::new(target);
            Ok(erased)
        }
        fn try_encoded(&self) -> ::std::result::Result<::std::vec::Vec<u8>, ::prost::EncodeError> {
            let mut buf = ::std::vec::Vec::new();
            buf.reserve(::prost::Message::encoded_len(self));
            ::prost::Message::encode(self, &mut buf)?;
            Ok(buf)
        }
    }
    ::prost_wkt::inventory::submit! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.RAMCorrectionOp" , decoder : | buf : & [u8] | { let msg : RamCorrectionOp = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } }
};

#[allow(dead_code)]
const IMPL_MESSAGE_SERDE_FOR_TABLE_OP: () = {
    use ::prost_wkt::typetag;
    #[typetag::serde(name = "type.googleapis.com/sf.antelope.type.v1.TableOp")]
    impl ::prost_wkt::MessageSerde for TableOp {
        fn package_name(&self) -> &'static str { "sf.antelope.type.v1" }
        fn message_name(&self) -> &'static str { "TableOp" }
        fn type_url(&self) -> &'static str { "type.googleapis.com/sf.antelope.type.v1.TableOp" }
        fn new_instance(&self, data: Vec<u8>) -> ::std::result::Result<Box<dyn ::prost_wkt::MessageSerde>, ::prost::DecodeError> {
            let mut target = Self::default();
            ::prost::Message::merge(&mut target, data.as_slice())?;
            let erased: ::std::boxed::Box<dyn ::prost_wkt::MessageSerde> = ::std::boxed::Box::new(target);
            Ok(erased)
        }
        fn try_encoded(&self) -> ::std::result::Result<::std::vec::Vec<u8>, ::prost::EncodeError> {
            let mut buf = ::std::vec::Vec::new();
            buf.reserve(::prost::Message::encoded_len(self));
            ::prost::Message::encode(self, &mut buf)?;
            Ok(buf)
        }
    }
    ::prost_wkt::inventory::submit! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.TableOp" , decoder : | buf : & [u8] | { let msg : TableOp = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } }
};

#[allow(dead_code)]
const IMPL_MESSAGE_SERDE_FOR_D_TRX_OP: () = {
    use ::prost_wkt::typetag;
    #[typetag::serde(name = "type.googleapis.com/sf.antelope.type.v1.DTrxOp")]
    impl ::prost_wkt::MessageSerde for DTrxOp {
        fn package_name(&self) -> &'static str { "sf.antelope.type.v1" }
        fn message_name(&self) -> &'static str { "DTrxOp" }
        fn type_url(&self) -> &'static str { "type.googleapis.com/sf.antelope.type.v1.DTrxOp" }
        fn new_instance(&self, data: Vec<u8>) -> ::std::result::Result<Box<dyn ::prost_wkt::MessageSerde>, ::prost::DecodeError> {
            let mut target = Self::default();
            ::prost::Message::merge(&mut target, data.as_slice())?;
            let erased: ::std::boxed::Box<dyn ::prost_wkt::MessageSerde> = ::std::boxed::Box::new(target);
            Ok(erased)
        }
        fn try_encoded(&self) -> ::std::result::Result<::std::vec::Vec<u8>, ::prost::EncodeError> {
            let mut buf = ::std::vec::Vec::new();
            buf.reserve(::prost::Message::encoded_len(self));
            ::prost::Message::encode(self, &mut buf)?;
            Ok(buf)
        }
    }
    ::prost_wkt::inventory::submit! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.DTrxOp" , decoder : | buf : & [u8] | { let msg : DTrxOp = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } }
};

#[allow(dead_code)]
const IMPL_MESSAGE_SERDE_FOR_EXT_D_TRX_OP: () = {
    use ::prost_wkt::typetag;
    #[typetag::serde(name = "type.googleapis.com/sf.antelope.type.v1.ExtDTrxOp")]
    impl ::prost_wkt::MessageSerde for ExtDTrxOp {
        fn package_name(&self) -> &'static str { "sf.antelope.type.v1" }
        fn message_name(&self) -> &'static str { "ExtDTrxOp" }
        fn type_url(&self) -> &'static str { "type.googleapis.com/sf.antelope.type.v1.ExtDTrxOp" }
        fn new_instance(&self, data: Vec<u8>) -> ::std::result::Result<Box<dyn ::prost_wkt::MessageSerde>, ::prost::DecodeError> {
            let mut target = Self::default();
            ::prost::Message::merge(&mut target, data.as_slice())?;
            let erased: ::std::boxed::Box<dyn ::prost_wkt::MessageSerde> = ::std::boxed::Box::new(target);
            Ok(erased)
        }
        fn try_encoded(&self) -> ::std::result::Result<::std::vec::Vec<u8>, ::prost::EncodeError> {
            let mut buf = ::std::vec::Vec::new();
            buf.reserve(::prost::Message::encoded_len(self));
            ::prost::Message::encode(self, &mut buf)?;
            Ok(buf)
        }
    }
    ::prost_wkt::inventory::submit! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.ExtDTrxOp" , decoder : | buf : & [u8] | { let msg : ExtDTrxOp = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } }
};

#[allow(dead_code)]
const IMPL_MESSAGE_SERDE_FOR_FEATURE_OP: () = {
    use ::prost_wkt::typetag;
    #[typetag::serde(name = "type.googleapis.com/sf.antelope.type.v1.FeatureOp")]
    impl ::prost_wkt::MessageSerde for FeatureOp {
        fn package_name(&self) -> &'static str { "sf.antelope.type.v1" }
        fn message_name(&self) -> &'static str { "FeatureOp" }
        fn type_url(&self) -> &'static str { "type.googleapis.com/sf.antelope.type.v1.FeatureOp" }
        fn new_instance(&self, data: Vec<u8>) -> ::std::result::Result<Box<dyn ::prost_wkt::MessageSerde>, ::prost::DecodeError> {
            let mut target = Self::default();
            ::prost::Message::merge(&mut target, data.as_slice())?;
            let erased: ::std::boxed::Box<dyn ::prost_wkt::MessageSerde> = ::std::boxed::Box::new(target);
            Ok(erased)
        }
        fn try_encoded(&self) -> ::std::result::Result<::std::vec::Vec<u8>, ::prost::EncodeError> {
            let mut buf = ::std::vec::Vec::new();
            buf.reserve(::prost::Message::encoded_len(self));
            ::prost::Message::encode(self, &mut buf)?;
            Ok(buf)
        }
    }
    ::prost_wkt::inventory::submit! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.FeatureOp" , decoder : | buf : & [u8] | { let msg : FeatureOp = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } }
};

#[allow(dead_code)]
const IMPL_MESSAGE_SERDE_FOR_CREATION_FLAT_NODE: () = {
    use ::prost_wkt::typetag;
    #[typetag::serde(name = "type.googleapis.com/sf.antelope.type.v1.CreationFlatNode")]
    impl ::prost_wkt::MessageSerde for CreationFlatNode {
        fn package_name(&self) -> &'static str { "sf.antelope.type.v1" }
        fn message_name(&self) -> &'static str { "CreationFlatNode" }
        fn type_url(&self) -> &'static str { "type.googleapis.com/sf.antelope.type.v1.CreationFlatNode" }
        fn new_instance(&self, data: Vec<u8>) -> ::std::result::Result<Box<dyn ::prost_wkt::MessageSerde>, ::prost::DecodeError> {
            let mut target = Self::default();
            ::prost::Message::merge(&mut target, data.as_slice())?;
            let erased: ::std::boxed::Box<dyn ::prost_wkt::MessageSerde> = ::std::boxed::Box::new(target);
            Ok(erased)
        }
        fn try_encoded(&self) -> ::std::result::Result<::std::vec::Vec<u8>, ::prost::EncodeError> {
            let mut buf = ::std::vec::Vec::new();
            buf.reserve(::prost::Message::encoded_len(self));
            ::prost::Message::encode(self, &mut buf)?;
            Ok(buf)
        }
    }
    ::prost_wkt::inventory::submit! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.CreationFlatNode" , decoder : | buf : & [u8] | { let msg : CreationFlatNode = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } }
};

#[allow(dead_code)]
const IMPL_MESSAGE_SERDE_FOR_PERM_OP: () = {
    use ::prost_wkt::typetag;
    #[typetag::serde(name = "type.googleapis.com/sf.antelope.type.v1.PermOp")]
    impl ::prost_wkt::MessageSerde for PermOp {
        fn package_name(&self) -> &'static str { "sf.antelope.type.v1" }
        fn message_name(&self) -> &'static str { "PermOp" }
        fn type_url(&self) -> &'static str { "type.googleapis.com/sf.antelope.type.v1.PermOp" }
        fn new_instance(&self, data: Vec<u8>) -> ::std::result::Result<Box<dyn ::prost_wkt::MessageSerde>, ::prost::DecodeError> {
            let mut target = Self::default();
            ::prost::Message::merge(&mut target, data.as_slice())?;
            let erased: ::std::boxed::Box<dyn ::prost_wkt::MessageSerde> = ::std::boxed::Box::new(target);
            Ok(erased)
        }
        fn try_encoded(&self) -> ::std::result::Result<::std::vec::Vec<u8>, ::prost::EncodeError> {
            let mut buf = ::std::vec::Vec::new();
            buf.reserve(::prost::Message::encoded_len(self));
            ::prost::Message::encode(self, &mut buf)?;
            Ok(buf)
        }
    }
    ::prost_wkt::inventory::submit! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.PermOp" , decoder : | buf : & [u8] | { let msg : PermOp = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } }
};

#[allow(dead_code)]
const IMPL_MESSAGE_SERDE_FOR_PERMISSION_OBJECT: () = {
    use ::prost_wkt::typetag;
    #[typetag::serde(name = "type.googleapis.com/sf.antelope.type.v1.PermissionObject")]
    impl ::prost_wkt::MessageSerde for PermissionObject {
        fn package_name(&self) -> &'static str { "sf.antelope.type.v1" }
        fn message_name(&self) -> &'static str { "PermissionObject" }
        fn type_url(&self) -> &'static str { "type.googleapis.com/sf.antelope.type.v1.PermissionObject" }
        fn new_instance(&self, data: Vec<u8>) -> ::std::result::Result<Box<dyn ::prost_wkt::MessageSerde>, ::prost::DecodeError> {
            let mut target = Self::default();
            ::prost::Message::merge(&mut target, data.as_slice())?;
            let erased: ::std::boxed::Box<dyn ::prost_wkt::MessageSerde> = ::std::boxed::Box::new(target);
            Ok(erased)
        }
        fn try_encoded(&self) -> ::std::result::Result<::std::vec::Vec<u8>, ::prost::EncodeError> {
            let mut buf = ::std::vec::Vec::new();
            buf.reserve(::prost::Message::encoded_len(self));
            ::prost::Message::encode(self, &mut buf)?;
            Ok(buf)
        }
    }
    ::prost_wkt::inventory::submit! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.PermissionObject" , decoder : | buf : & [u8] | { let msg : PermissionObject = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } }
};

#[allow(dead_code)]
const IMPL_MESSAGE_SERDE_FOR_PERMISSION: () = {
    use ::prost_wkt::typetag;
    #[typetag::serde(name = "type.googleapis.com/sf.antelope.type.v1.Permission")]
    impl ::prost_wkt::MessageSerde for Permission {
        fn package_name(&self) -> &'static str { "sf.antelope.type.v1" }
        fn message_name(&self) -> &'static str { "Permission" }
        fn type_url(&self) -> &'static str { "type.googleapis.com/sf.antelope.type.v1.Permission" }
        fn new_instance(&self, data: Vec<u8>) -> ::std::result::Result<Box<dyn ::prost_wkt::MessageSerde>, ::prost::DecodeError> {
            let mut target = Self::default();
            ::prost::Message::merge(&mut target, data.as_slice())?;
            let erased: ::std::boxed::Box<dyn ::prost_wkt::MessageSerde> = ::std::boxed::Box::new(target);
            Ok(erased)
        }
        fn try_encoded(&self) -> ::std::result::Result<::std::vec::Vec<u8>, ::prost::EncodeError> {
            let mut buf = ::std::vec::Vec::new();
            buf.reserve(::prost::Message::encoded_len(self));
            ::prost::Message::encode(self, &mut buf)?;
            Ok(buf)
        }
    }
    ::prost_wkt::inventory::submit! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.Permission" , decoder : | buf : & [u8] | { let msg : Permission = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } }
};

#[allow(dead_code)]
const IMPL_MESSAGE_SERDE_FOR_AUTHORITY: () = {
    use ::prost_wkt::typetag;
    #[typetag::serde(name = "type.googleapis.com/sf.antelope.type.v1.Authority")]
    impl ::prost_wkt::MessageSerde for Authority {
        fn package_name(&self) -> &'static str { "sf.antelope.type.v1" }
        fn message_name(&self) -> &'static str { "Authority" }
        fn type_url(&self) -> &'static str { "type.googleapis.com/sf.antelope.type.v1.Authority" }
        fn new_instance(&self, data: Vec<u8>) -> ::std::result::Result<Box<dyn ::prost_wkt::MessageSerde>, ::prost::DecodeError> {
            let mut target = Self::default();
            ::prost::Message::merge(&mut target, data.as_slice())?;
            let erased: ::std::boxed::Box<dyn ::prost_wkt::MessageSerde> = ::std::boxed::Box::new(target);
            Ok(erased)
        }
        fn try_encoded(&self) -> ::std::result::Result<::std::vec::Vec<u8>, ::prost::EncodeError> {
            let mut buf = ::std::vec::Vec::new();
            buf.reserve(::prost::Message::encoded_len(self));
            ::prost::Message::encode(self, &mut buf)?;
            Ok(buf)
        }
    }
    ::prost_wkt::inventory::submit! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.Authority" , decoder : | buf : & [u8] | { let msg : Authority = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } }
};

#[allow(dead_code)]
const IMPL_MESSAGE_SERDE_FOR_KEY_WEIGHT: () = {
    use ::prost_wkt::typetag;
    #[typetag::serde(name = "type.googleapis.com/sf.antelope.type.v1.KeyWeight")]
    impl ::prost_wkt::MessageSerde for KeyWeight {
        fn package_name(&self) -> &'static str { "sf.antelope.type.v1" }
        fn message_name(&self) -> &'static str { "KeyWeight" }
        fn type_url(&self) -> &'static str { "type.googleapis.com/sf.antelope.type.v1.KeyWeight" }
        fn new_instance(&self, data: Vec<u8>) -> ::std::result::Result<Box<dyn ::prost_wkt::MessageSerde>, ::prost::DecodeError> {
            let mut target = Self::default();
            ::prost::Message::merge(&mut target, data.as_slice())?;
            let erased: ::std::boxed::Box<dyn ::prost_wkt::MessageSerde> = ::std::boxed::Box::new(target);
            Ok(erased)
        }
        fn try_encoded(&self) -> ::std::result::Result<::std::vec::Vec<u8>, ::prost::EncodeError> {
            let mut buf = ::std::vec::Vec::new();
            buf.reserve(::prost::Message::encoded_len(self));
            ::prost::Message::encode(self, &mut buf)?;
            Ok(buf)
        }
    }
    ::prost_wkt::inventory::submit! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.KeyWeight" , decoder : | buf : & [u8] | { let msg : KeyWeight = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } }
};

#[allow(dead_code)]
const IMPL_MESSAGE_SERDE_FOR_PERMISSION_LEVEL: () = {
    use ::prost_wkt::typetag;
    #[typetag::serde(name = "type.googleapis.com/sf.antelope.type.v1.PermissionLevel")]
    impl ::prost_wkt::MessageSerde for PermissionLevel {
        fn package_name(&self) -> &'static str { "sf.antelope.type.v1" }
        fn message_name(&self) -> &'static str { "PermissionLevel" }
        fn type_url(&self) -> &'static str { "type.googleapis.com/sf.antelope.type.v1.PermissionLevel" }
        fn new_instance(&self, data: Vec<u8>) -> ::std::result::Result<Box<dyn ::prost_wkt::MessageSerde>, ::prost::DecodeError> {
            let mut target = Self::default();
            ::prost::Message::merge(&mut target, data.as_slice())?;
            let erased: ::std::boxed::Box<dyn ::prost_wkt::MessageSerde> = ::std::boxed::Box::new(target);
            Ok(erased)
        }
        fn try_encoded(&self) -> ::std::result::Result<::std::vec::Vec<u8>, ::prost::EncodeError> {
            let mut buf = ::std::vec::Vec::new();
            buf.reserve(::prost::Message::encoded_len(self));
            ::prost::Message::encode(self, &mut buf)?;
            Ok(buf)
        }
    }
    ::prost_wkt::inventory::submit! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.PermissionLevel" , decoder : | buf : & [u8] | { let msg : PermissionLevel = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } }
};

#[allow(dead_code)]
const IMPL_MESSAGE_SERDE_FOR_PERMISSION_LEVEL_WEIGHT: () = {
    use ::prost_wkt::typetag;
    #[typetag::serde(name = "type.googleapis.com/sf.antelope.type.v1.PermissionLevelWeight")]
    impl ::prost_wkt::MessageSerde for PermissionLevelWeight {
        fn package_name(&self) -> &'static str { "sf.antelope.type.v1" }
        fn message_name(&self) -> &'static str { "PermissionLevelWeight" }
        fn type_url(&self) -> &'static str { "type.googleapis.com/sf.antelope.type.v1.PermissionLevelWeight" }
        fn new_instance(&self, data: Vec<u8>) -> ::std::result::Result<Box<dyn ::prost_wkt::MessageSerde>, ::prost::DecodeError> {
            let mut target = Self::default();
            ::prost::Message::merge(&mut target, data.as_slice())?;
            let erased: ::std::boxed::Box<dyn ::prost_wkt::MessageSerde> = ::std::boxed::Box::new(target);
            Ok(erased)
        }
        fn try_encoded(&self) -> ::std::result::Result<::std::vec::Vec<u8>, ::prost::EncodeError> {
            let mut buf = ::std::vec::Vec::new();
            buf.reserve(::prost::Message::encoded_len(self));
            ::prost::Message::encode(self, &mut buf)?;
            Ok(buf)
        }
    }
    ::prost_wkt::inventory::submit! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.PermissionLevelWeight" , decoder : | buf : & [u8] | { let msg : PermissionLevelWeight = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } }
};

#[allow(dead_code)]
const IMPL_MESSAGE_SERDE_FOR_WAIT_WEIGHT: () = {
    use ::prost_wkt::typetag;
    #[typetag::serde(name = "type.googleapis.com/sf.antelope.type.v1.WaitWeight")]
    impl ::prost_wkt::MessageSerde for WaitWeight {
        fn package_name(&self) -> &'static str { "sf.antelope.type.v1" }
        fn message_name(&self) -> &'static str { "WaitWeight" }
        fn type_url(&self) -> &'static str { "type.googleapis.com/sf.antelope.type.v1.WaitWeight" }
        fn new_instance(&self, data: Vec<u8>) -> ::std::result::Result<Box<dyn ::prost_wkt::MessageSerde>, ::prost::DecodeError> {
            let mut target = Self::default();
            ::prost::Message::merge(&mut target, data.as_slice())?;
            let erased: ::std::boxed::Box<dyn ::prost_wkt::MessageSerde> = ::std::boxed::Box::new(target);
            Ok(erased)
        }
        fn try_encoded(&self) -> ::std::result::Result<::std::vec::Vec<u8>, ::prost::EncodeError> {
            let mut buf = ::std::vec::Vec::new();
            buf.reserve(::prost::Message::encoded_len(self));
            ::prost::Message::encode(self, &mut buf)?;
            Ok(buf)
        }
    }
    ::prost_wkt::inventory::submit! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.WaitWeight" , decoder : | buf : & [u8] | { let msg : WaitWeight = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } }
};

#[allow(dead_code)]
const IMPL_MESSAGE_SERDE_FOR_RLIMIT_OP: () = {
    use ::prost_wkt::typetag;
    #[typetag::serde(name = "type.googleapis.com/sf.antelope.type.v1.RlimitOp")]
    impl ::prost_wkt::MessageSerde for RlimitOp {
        fn package_name(&self) -> &'static str { "sf.antelope.type.v1" }
        fn message_name(&self) -> &'static str { "RlimitOp" }
        fn type_url(&self) -> &'static str { "type.googleapis.com/sf.antelope.type.v1.RlimitOp" }
        fn new_instance(&self, data: Vec<u8>) -> ::std::result::Result<Box<dyn ::prost_wkt::MessageSerde>, ::prost::DecodeError> {
            let mut target = Self::default();
            ::prost::Message::merge(&mut target, data.as_slice())?;
            let erased: ::std::boxed::Box<dyn ::prost_wkt::MessageSerde> = ::std::boxed::Box::new(target);
            Ok(erased)
        }
        fn try_encoded(&self) -> ::std::result::Result<::std::vec::Vec<u8>, ::prost::EncodeError> {
            let mut buf = ::std::vec::Vec::new();
            buf.reserve(::prost::Message::encoded_len(self));
            ::prost::Message::encode(self, &mut buf)?;
            Ok(buf)
        }
    }
    ::prost_wkt::inventory::submit! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.RlimitOp" , decoder : | buf : & [u8] | { let msg : RlimitOp = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } }
};

#[allow(dead_code)]
const IMPL_MESSAGE_SERDE_FOR_RLIMIT_STATE: () = {
    use ::prost_wkt::typetag;
    #[typetag::serde(name = "type.googleapis.com/sf.antelope.type.v1.RlimitState")]
    impl ::prost_wkt::MessageSerde for RlimitState {
        fn package_name(&self) -> &'static str { "sf.antelope.type.v1" }
        fn message_name(&self) -> &'static str { "RlimitState" }
        fn type_url(&self) -> &'static str { "type.googleapis.com/sf.antelope.type.v1.RlimitState" }
        fn new_instance(&self, data: Vec<u8>) -> ::std::result::Result<Box<dyn ::prost_wkt::MessageSerde>, ::prost::DecodeError> {
            let mut target = Self::default();
            ::prost::Message::merge(&mut target, data.as_slice())?;
            let erased: ::std::boxed::Box<dyn ::prost_wkt::MessageSerde> = ::std::boxed::Box::new(target);
            Ok(erased)
        }
        fn try_encoded(&self) -> ::std::result::Result<::std::vec::Vec<u8>, ::prost::EncodeError> {
            let mut buf = ::std::vec::Vec::new();
            buf.reserve(::prost::Message::encoded_len(self));
            ::prost::Message::encode(self, &mut buf)?;
            Ok(buf)
        }
    }
    ::prost_wkt::inventory::submit! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.RlimitState" , decoder : | buf : & [u8] | { let msg : RlimitState = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } }
};

#[allow(dead_code)]
const IMPL_MESSAGE_SERDE_FOR_RLIMIT_CONFIG: () = {
    use ::prost_wkt::typetag;
    #[typetag::serde(name = "type.googleapis.com/sf.antelope.type.v1.RlimitConfig")]
    impl ::prost_wkt::MessageSerde for RlimitConfig {
        fn package_name(&self) -> &'static str { "sf.antelope.type.v1" }
        fn message_name(&self) -> &'static str { "RlimitConfig" }
        fn type_url(&self) -> &'static str { "type.googleapis.com/sf.antelope.type.v1.RlimitConfig" }
        fn new_instance(&self, data: Vec<u8>) -> ::std::result::Result<Box<dyn ::prost_wkt::MessageSerde>, ::prost::DecodeError> {
            let mut target = Self::default();
            ::prost::Message::merge(&mut target, data.as_slice())?;
            let erased: ::std::boxed::Box<dyn ::prost_wkt::MessageSerde> = ::std::boxed::Box::new(target);
            Ok(erased)
        }
        fn try_encoded(&self) -> ::std::result::Result<::std::vec::Vec<u8>, ::prost::EncodeError> {
            let mut buf = ::std::vec::Vec::new();
            buf.reserve(::prost::Message::encoded_len(self));
            ::prost::Message::encode(self, &mut buf)?;
            Ok(buf)
        }
    }
    ::prost_wkt::inventory::submit! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.RlimitConfig" , decoder : | buf : & [u8] | { let msg : RlimitConfig = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } }
};

#[allow(dead_code)]
const IMPL_MESSAGE_SERDE_FOR_RLIMIT_ACCOUNT_LIMITS: () = {
    use ::prost_wkt::typetag;
    #[typetag::serde(name = "type.googleapis.com/sf.antelope.type.v1.RlimitAccountLimits")]
    impl ::prost_wkt::MessageSerde for RlimitAccountLimits {
        fn package_name(&self) -> &'static str { "sf.antelope.type.v1" }
        fn message_name(&self) -> &'static str { "RlimitAccountLimits" }
        fn type_url(&self) -> &'static str { "type.googleapis.com/sf.antelope.type.v1.RlimitAccountLimits" }
        fn new_instance(&self, data: Vec<u8>) -> ::std::result::Result<Box<dyn ::prost_wkt::MessageSerde>, ::prost::DecodeError> {
            let mut target = Self::default();
            ::prost::Message::merge(&mut target, data.as_slice())?;
            let erased: ::std::boxed::Box<dyn ::prost_wkt::MessageSerde> = ::std::boxed::Box::new(target);
            Ok(erased)
        }
        fn try_encoded(&self) -> ::std::result::Result<::std::vec::Vec<u8>, ::prost::EncodeError> {
            let mut buf = ::std::vec::Vec::new();
            buf.reserve(::prost::Message::encoded_len(self));
            ::prost::Message::encode(self, &mut buf)?;
            Ok(buf)
        }
    }
    ::prost_wkt::inventory::submit! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.RlimitAccountLimits" , decoder : | buf : & [u8] | { let msg : RlimitAccountLimits = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } }
};

#[allow(dead_code)]
const IMPL_MESSAGE_SERDE_FOR_RLIMIT_ACCOUNT_USAGE: () = {
    use ::prost_wkt::typetag;
    #[typetag::serde(name = "type.googleapis.com/sf.antelope.type.v1.RlimitAccountUsage")]
    impl ::prost_wkt::MessageSerde for RlimitAccountUsage {
        fn package_name(&self) -> &'static str { "sf.antelope.type.v1" }
        fn message_name(&self) -> &'static str { "RlimitAccountUsage" }
        fn type_url(&self) -> &'static str { "type.googleapis.com/sf.antelope.type.v1.RlimitAccountUsage" }
        fn new_instance(&self, data: Vec<u8>) -> ::std::result::Result<Box<dyn ::prost_wkt::MessageSerde>, ::prost::DecodeError> {
            let mut target = Self::default();
            ::prost::Message::merge(&mut target, data.as_slice())?;
            let erased: ::std::boxed::Box<dyn ::prost_wkt::MessageSerde> = ::std::boxed::Box::new(target);
            Ok(erased)
        }
        fn try_encoded(&self) -> ::std::result::Result<::std::vec::Vec<u8>, ::prost::EncodeError> {
            let mut buf = ::std::vec::Vec::new();
            buf.reserve(::prost::Message::encoded_len(self));
            ::prost::Message::encode(self, &mut buf)?;
            Ok(buf)
        }
    }
    ::prost_wkt::inventory::submit! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.RlimitAccountUsage" , decoder : | buf : & [u8] | { let msg : RlimitAccountUsage = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } }
};

#[allow(dead_code)]
const IMPL_MESSAGE_SERDE_FOR_USAGE_ACCUMULATOR: () = {
    use ::prost_wkt::typetag;
    #[typetag::serde(name = "type.googleapis.com/sf.antelope.type.v1.UsageAccumulator")]
    impl ::prost_wkt::MessageSerde for UsageAccumulator {
        fn package_name(&self) -> &'static str { "sf.antelope.type.v1" }
        fn message_name(&self) -> &'static str { "UsageAccumulator" }
        fn type_url(&self) -> &'static str { "type.googleapis.com/sf.antelope.type.v1.UsageAccumulator" }
        fn new_instance(&self, data: Vec<u8>) -> ::std::result::Result<Box<dyn ::prost_wkt::MessageSerde>, ::prost::DecodeError> {
            let mut target = Self::default();
            ::prost::Message::merge(&mut target, data.as_slice())?;
            let erased: ::std::boxed::Box<dyn ::prost_wkt::MessageSerde> = ::std::boxed::Box::new(target);
            Ok(erased)
        }
        fn try_encoded(&self) -> ::std::result::Result<::std::vec::Vec<u8>, ::prost::EncodeError> {
            let mut buf = ::std::vec::Vec::new();
            buf.reserve(::prost::Message::encoded_len(self));
            ::prost::Message::encode(self, &mut buf)?;
            Ok(buf)
        }
    }
    ::prost_wkt::inventory::submit! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.UsageAccumulator" , decoder : | buf : & [u8] | { let msg : UsageAccumulator = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } }
};

#[allow(dead_code)]
const IMPL_MESSAGE_SERDE_FOR_ELASTIC_LIMIT_PARAMETERS: () = {
    use ::prost_wkt::typetag;
    #[typetag::serde(name = "type.googleapis.com/sf.antelope.type.v1.ElasticLimitParameters")]
    impl ::prost_wkt::MessageSerde for ElasticLimitParameters {
        fn package_name(&self) -> &'static str { "sf.antelope.type.v1" }
        fn message_name(&self) -> &'static str { "ElasticLimitParameters" }
        fn type_url(&self) -> &'static str { "type.googleapis.com/sf.antelope.type.v1.ElasticLimitParameters" }
        fn new_instance(&self, data: Vec<u8>) -> ::std::result::Result<Box<dyn ::prost_wkt::MessageSerde>, ::prost::DecodeError> {
            let mut target = Self::default();
            ::prost::Message::merge(&mut target, data.as_slice())?;
            let erased: ::std::boxed::Box<dyn ::prost_wkt::MessageSerde> = ::std::boxed::Box::new(target);
            Ok(erased)
        }
        fn try_encoded(&self) -> ::std::result::Result<::std::vec::Vec<u8>, ::prost::EncodeError> {
            let mut buf = ::std::vec::Vec::new();
            buf.reserve(::prost::Message::encoded_len(self));
            ::prost::Message::encode(self, &mut buf)?;
            Ok(buf)
        }
    }
    ::prost_wkt::inventory::submit! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.ElasticLimitParameters" , decoder : | buf : & [u8] | { let msg : ElasticLimitParameters = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } }
};

#[allow(dead_code)]
const IMPL_MESSAGE_SERDE_FOR_RATIO: () = {
    use ::prost_wkt::typetag;
    #[typetag::serde(name = "type.googleapis.com/sf.antelope.type.v1.Ratio")]
    impl ::prost_wkt::MessageSerde for Ratio {
        fn package_name(&self) -> &'static str { "sf.antelope.type.v1" }
        fn message_name(&self) -> &'static str { "Ratio" }
        fn type_url(&self) -> &'static str { "type.googleapis.com/sf.antelope.type.v1.Ratio" }
        fn new_instance(&self, data: Vec<u8>) -> ::std::result::Result<Box<dyn ::prost_wkt::MessageSerde>, ::prost::DecodeError> {
            let mut target = Self::default();
            ::prost::Message::merge(&mut target, data.as_slice())?;
            let erased: ::std::boxed::Box<dyn ::prost_wkt::MessageSerde> = ::std::boxed::Box::new(target);
            Ok(erased)
        }
        fn try_encoded(&self) -> ::std::result::Result<::std::vec::Vec<u8>, ::prost::EncodeError> {
            let mut buf = ::std::vec::Vec::new();
            buf.reserve(::prost::Message::encoded_len(self));
            ::prost::Message::encode(self, &mut buf)?;
            Ok(buf)
        }
    }
    ::prost_wkt::inventory::submit! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.Ratio" , decoder : | buf : & [u8] | { let msg : Ratio = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } }
};

#[allow(dead_code)]
const IMPL_MESSAGE_SERDE_FOR_EXCEPTION: () = {
    use ::prost_wkt::typetag;
    #[typetag::serde(name = "type.googleapis.com/sf.antelope.type.v1.Exception")]
    impl ::prost_wkt::MessageSerde for Exception {
        fn package_name(&self) -> &'static str { "sf.antelope.type.v1" }
        fn message_name(&self) -> &'static str { "Exception" }
        fn type_url(&self) -> &'static str { "type.googleapis.com/sf.antelope.type.v1.Exception" }
        fn new_instance(&self, data: Vec<u8>) -> ::std::result::Result<Box<dyn ::prost_wkt::MessageSerde>, ::prost::DecodeError> {
            let mut target = Self::default();
            ::prost::Message::merge(&mut target, data.as_slice())?;
            let erased: ::std::boxed::Box<dyn ::prost_wkt::MessageSerde> = ::std::boxed::Box::new(target);
            Ok(erased)
        }
        fn try_encoded(&self) -> ::std::result::Result<::std::vec::Vec<u8>, ::prost::EncodeError> {
            let mut buf = ::std::vec::Vec::new();
            buf.reserve(::prost::Message::encoded_len(self));
            ::prost::Message::encode(self, &mut buf)?;
            Ok(buf)
        }
    }
    ::prost_wkt::inventory::submit! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.Exception" , decoder : | buf : & [u8] | { let msg : Exception = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } }
};

#[allow(dead_code)]
const IMPL_MESSAGE_SERDE_FOR_FEATURE: () = {
    use ::prost_wkt::typetag;
    #[typetag::serde(name = "type.googleapis.com/sf.antelope.type.v1.Feature")]
    impl ::prost_wkt::MessageSerde for Feature {
        fn package_name(&self) -> &'static str { "sf.antelope.type.v1" }
        fn message_name(&self) -> &'static str { "Feature" }
        fn type_url(&self) -> &'static str { "type.googleapis.com/sf.antelope.type.v1.Feature" }
        fn new_instance(&self, data: Vec<u8>) -> ::std::result::Result<Box<dyn ::prost_wkt::MessageSerde>, ::prost::DecodeError> {
            let mut target = Self::default();
            ::prost::Message::merge(&mut target, data.as_slice())?;
            let erased: ::std::boxed::Box<dyn ::prost_wkt::MessageSerde> = ::std::boxed::Box::new(target);
            Ok(erased)
        }
        fn try_encoded(&self) -> ::std::result::Result<::std::vec::Vec<u8>, ::prost::EncodeError> {
            let mut buf = ::std::vec::Vec::new();
            buf.reserve(::prost::Message::encoded_len(self));
            ::prost::Message::encode(self, &mut buf)?;
            Ok(buf)
        }
    }
    ::prost_wkt::inventory::submit! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.Feature" , decoder : | buf : & [u8] | { let msg : Feature = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } }
};

#[allow(dead_code)]
const IMPL_MESSAGE_SERDE_FOR_SUBJECTIVE_RESTRICTIONS: () = {
    use ::prost_wkt::typetag;
    #[typetag::serde(name = "type.googleapis.com/sf.antelope.type.v1.SubjectiveRestrictions")]
    impl ::prost_wkt::MessageSerde for SubjectiveRestrictions {
        fn package_name(&self) -> &'static str { "sf.antelope.type.v1" }
        fn message_name(&self) -> &'static str { "SubjectiveRestrictions" }
        fn type_url(&self) -> &'static str { "type.googleapis.com/sf.antelope.type.v1.SubjectiveRestrictions" }
        fn new_instance(&self, data: Vec<u8>) -> ::std::result::Result<Box<dyn ::prost_wkt::MessageSerde>, ::prost::DecodeError> {
            let mut target = Self::default();
            ::prost::Message::merge(&mut target, data.as_slice())?;
            let erased: ::std::boxed::Box<dyn ::prost_wkt::MessageSerde> = ::std::boxed::Box::new(target);
            Ok(erased)
        }
        fn try_encoded(&self) -> ::std::result::Result<::std::vec::Vec<u8>, ::prost::EncodeError> {
            let mut buf = ::std::vec::Vec::new();
            buf.reserve(::prost::Message::encoded_len(self));
            ::prost::Message::encode(self, &mut buf)?;
            Ok(buf)
        }
    }
    ::prost_wkt::inventory::submit! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.SubjectiveRestrictions" , decoder : | buf : & [u8] | { let msg : SubjectiveRestrictions = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } }
};

#[allow(dead_code)]
const IMPL_MESSAGE_SERDE_FOR_SPECIFICATION: () = {
    use ::prost_wkt::typetag;
    #[typetag::serde(name = "type.googleapis.com/sf.antelope.type.v1.Specification")]
    impl ::prost_wkt::MessageSerde for Specification {
        fn package_name(&self) -> &'static str { "sf.antelope.type.v1" }
        fn message_name(&self) -> &'static str { "Specification" }
        fn type_url(&self) -> &'static str { "type.googleapis.com/sf.antelope.type.v1.Specification" }
        fn new_instance(&self, data: Vec<u8>) -> ::std::result::Result<Box<dyn ::prost_wkt::MessageSerde>, ::prost::DecodeError> {
            let mut target = Self::default();
            ::prost::Message::merge(&mut target, data.as_slice())?;
            let erased: ::std::boxed::Box<dyn ::prost_wkt::MessageSerde> = ::std::boxed::Box::new(target);
            Ok(erased)
        }
        fn try_encoded(&self) -> ::std::result::Result<::std::vec::Vec<u8>, ::prost::EncodeError> {
            let mut buf = ::std::vec::Vec::new();
            buf.reserve(::prost::Message::encoded_len(self));
            ::prost::Message::encode(self, &mut buf)?;
            Ok(buf)
        }
    }
    ::prost_wkt::inventory::submit! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.Specification" , decoder : | buf : & [u8] | { let msg : Specification = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } }
};

#[allow(dead_code)]
const IMPL_MESSAGE_SERDE_FOR_ACCOUNT_CREATION_REF: () = {
    use ::prost_wkt::typetag;
    #[typetag::serde(name = "type.googleapis.com/sf.antelope.type.v1.AccountCreationRef")]
    impl ::prost_wkt::MessageSerde for AccountCreationRef {
        fn package_name(&self) -> &'static str { "sf.antelope.type.v1" }
        fn message_name(&self) -> &'static str { "AccountCreationRef" }
        fn type_url(&self) -> &'static str { "type.googleapis.com/sf.antelope.type.v1.AccountCreationRef" }
        fn new_instance(&self, data: Vec<u8>) -> ::std::result::Result<Box<dyn ::prost_wkt::MessageSerde>, ::prost::DecodeError> {
            let mut target = Self::default();
            ::prost::Message::merge(&mut target, data.as_slice())?;
            let erased: ::std::boxed::Box<dyn ::prost_wkt::MessageSerde> = ::std::boxed::Box::new(target);
            Ok(erased)
        }
        fn try_encoded(&self) -> ::std::result::Result<::std::vec::Vec<u8>, ::prost::EncodeError> {
            let mut buf = ::std::vec::Vec::new();
            buf.reserve(::prost::Message::encoded_len(self));
            ::prost::Message::encode(self, &mut buf)?;
            Ok(buf)
        }
    }
    ::prost_wkt::inventory::submit! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.AccountCreationRef" , decoder : | buf : & [u8] | { let msg : AccountCreationRef = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } }
};

#[allow(dead_code)]
const IMPL_MESSAGE_SERDE_FOR_HEADER_ONLY_BLOCK: () = {
    use ::prost_wkt::typetag;
    #[typetag::serde(name = "type.googleapis.com/sf.antelope.type.v1.HeaderOnlyBlock")]
    impl ::prost_wkt::MessageSerde for HeaderOnlyBlock {
        fn package_name(&self) -> &'static str { "sf.antelope.type.v1" }
        fn message_name(&self) -> &'static str { "HeaderOnlyBlock" }
        fn type_url(&self) -> &'static str { "type.googleapis.com/sf.antelope.type.v1.HeaderOnlyBlock" }
        fn new_instance(&self, data: Vec<u8>) -> ::std::result::Result<Box<dyn ::prost_wkt::MessageSerde>, ::prost::DecodeError> {
            let mut target = Self::default();
            ::prost::Message::merge(&mut target, data.as_slice())?;
            let erased: ::std::boxed::Box<dyn ::prost_wkt::MessageSerde> = ::std::boxed::Box::new(target);
            Ok(erased)
        }
        fn try_encoded(&self) -> ::std::result::Result<::std::vec::Vec<u8>, ::prost::EncodeError> {
            let mut buf = ::std::vec::Vec::new();
            buf.reserve(::prost::Message::encoded_len(self));
            ::prost::Message::encode(self, &mut buf)?;
            Ok(buf)
        }
    }
    ::prost_wkt::inventory::submit! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.HeaderOnlyBlock" , decoder : | buf : & [u8] | { let msg : HeaderOnlyBlock = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } }
};

#[allow(dead_code)]
const IMPL_MESSAGE_SERDE_FOR_TRANSACTION_TRACE_WITH_BLOCK_REF: () = {
    use ::prost_wkt::typetag;
    #[typetag::serde(name = "type.googleapis.com/sf.antelope.type.v1.TransactionTraceWithBlockRef")]
    impl ::prost_wkt::MessageSerde for TransactionTraceWithBlockRef {
        fn package_name(&self) -> &'static str { "sf.antelope.type.v1" }
        fn message_name(&self) -> &'static str { "TransactionTraceWithBlockRef" }
        fn type_url(&self) -> &'static str { "type.googleapis.com/sf.antelope.type.v1.TransactionTraceWithBlockRef" }
        fn new_instance(&self, data: Vec<u8>) -> ::std::result::Result<Box<dyn ::prost_wkt::MessageSerde>, ::prost::DecodeError> {
            let mut target = Self::default();
            ::prost::Message::merge(&mut target, data.as_slice())?;
            let erased: ::std::boxed::Box<dyn ::prost_wkt::MessageSerde> = ::std::boxed::Box::new(target);
            Ok(erased)
        }
        fn try_encoded(&self) -> ::std::result::Result<::std::vec::Vec<u8>, ::prost::EncodeError> {
            let mut buf = ::std::vec::Vec::new();
            buf.reserve(::prost::Message::encoded_len(self));
            ::prost::Message::encode(self, &mut buf)?;
            Ok(buf)
        }
    }
    ::prost_wkt::inventory::submit! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.TransactionTraceWithBlockRef" , decoder : | buf : & [u8] | { let msg : TransactionTraceWithBlockRef = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } }
};

#[allow(dead_code)]
const IMPL_MESSAGE_SERDE_FOR_BLOCK_REF: () = {
    use ::prost_wkt::typetag;
    #[typetag::serde(name = "type.googleapis.com/sf.antelope.type.v1.BlockRef")]
    impl ::prost_wkt::MessageSerde for BlockRef {
        fn package_name(&self) -> &'static str { "sf.antelope.type.v1" }
        fn message_name(&self) -> &'static str { "BlockRef" }
        fn type_url(&self) -> &'static str { "type.googleapis.com/sf.antelope.type.v1.BlockRef" }
        fn new_instance(&self, data: Vec<u8>) -> ::std::result::Result<Box<dyn ::prost_wkt::MessageSerde>, ::prost::DecodeError> {
            let mut target = Self::default();
            ::prost::Message::merge(&mut target, data.as_slice())?;
            let erased: ::std::boxed::Box<dyn ::prost_wkt::MessageSerde> = ::std::boxed::Box::new(target);
            Ok(erased)
        }
        fn try_encoded(&self) -> ::std::result::Result<::std::vec::Vec<u8>, ::prost::EncodeError> {
            let mut buf = ::std::vec::Vec::new();
            buf.reserve(::prost::Message::encoded_len(self));
            ::prost::Message::encode(self, &mut buf)?;
            Ok(buf)
        }
    }
    ::prost_wkt::inventory::submit! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.BlockRef" , decoder : | buf : & [u8] | { let msg : BlockRef = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } }
};

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_ACTION_TRACES : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.ActionTraces")] impl :: prost_wkt :: MessageSerde for ActionTraces { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "ActionTraces" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.ActionTraces" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.ActionTraces" , decoder : | buf : & [u8] | { let msg : ActionTraces = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_TRANSACTION_TRACES : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.TransactionTraces")] impl :: prost_wkt :: MessageSerde for TransactionTraces { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "TransactionTraces" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.TransactionTraces" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.TransactionTraces" , decoder : | buf : & [u8] | { let msg : TransactionTraces = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_DB_OPS : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.DBOps")] impl :: prost_wkt :: MessageSerde for DbOps { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "DBOps" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.DBOps" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.DBOps" , decoder : | buf : & [u8] | { let msg : DbOps = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_BLOCK : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.Block")] impl :: prost_wkt :: MessageSerde for Block { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "Block" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.Block" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.Block" , decoder : | buf : & [u8] | { let msg : Block = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_BLOCK_WITH_REFS : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.BlockWithRefs")] impl :: prost_wkt :: MessageSerde for BlockWithRefs { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "BlockWithRefs" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.BlockWithRefs" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.BlockWithRefs" , decoder : | buf : & [u8] | { let msg : BlockWithRefs = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_TRANSACTION_REFS : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.TransactionRefs")] impl :: prost_wkt :: MessageSerde for TransactionRefs { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "TransactionRefs" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.TransactionRefs" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.TransactionRefs" , decoder : | buf : & [u8] | { let msg : TransactionRefs = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_ACTIVATED_PROTOCOL_FEATURES : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.ActivatedProtocolFeatures")] impl :: prost_wkt :: MessageSerde for ActivatedProtocolFeatures { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "ActivatedProtocolFeatures" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.ActivatedProtocolFeatures" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.ActivatedProtocolFeatures" , decoder : | buf : & [u8] | { let msg : ActivatedProtocolFeatures = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_PENDING_PRODUCER_SCHEDULE : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.PendingProducerSchedule")] impl :: prost_wkt :: MessageSerde for PendingProducerSchedule { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "PendingProducerSchedule" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.PendingProducerSchedule" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.PendingProducerSchedule" , decoder : | buf : & [u8] | { let msg : PendingProducerSchedule = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_PRODUCER_SCHEDULE : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.ProducerSchedule")] impl :: prost_wkt :: MessageSerde for ProducerSchedule { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "ProducerSchedule" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.ProducerSchedule" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.ProducerSchedule" , decoder : | buf : & [u8] | { let msg : ProducerSchedule = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_PRODUCER_KEY : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.ProducerKey")] impl :: prost_wkt :: MessageSerde for ProducerKey { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "ProducerKey" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.ProducerKey" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.ProducerKey" , decoder : | buf : & [u8] | { let msg : ProducerKey = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_PRODUCER_AUTHORITY_SCHEDULE : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.ProducerAuthoritySchedule")] impl :: prost_wkt :: MessageSerde for ProducerAuthoritySchedule { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "ProducerAuthoritySchedule" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.ProducerAuthoritySchedule" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.ProducerAuthoritySchedule" , decoder : | buf : & [u8] | { let msg : ProducerAuthoritySchedule = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_PRODUCER_AUTHORITY : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.ProducerAuthority")] impl :: prost_wkt :: MessageSerde for ProducerAuthority { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "ProducerAuthority" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.ProducerAuthority" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.ProducerAuthority" , decoder : | buf : & [u8] | { let msg : ProducerAuthority = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_BLOCK_SIGNING_AUTHORITY : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.BlockSigningAuthority")] impl :: prost_wkt :: MessageSerde for BlockSigningAuthority { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "BlockSigningAuthority" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.BlockSigningAuthority" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.BlockSigningAuthority" , decoder : | buf : & [u8] | { let msg : BlockSigningAuthority = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_BLOCK_SIGNING_AUTHORITY_V0 : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.BlockSigningAuthorityV0")] impl :: prost_wkt :: MessageSerde for BlockSigningAuthorityV0 { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "BlockSigningAuthorityV0" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.BlockSigningAuthorityV0" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.BlockSigningAuthorityV0" , decoder : | buf : & [u8] | { let msg : BlockSigningAuthorityV0 = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_BLOCK_ROOT_MERKLE : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.BlockRootMerkle")] impl :: prost_wkt :: MessageSerde for BlockRootMerkle { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "BlockRootMerkle" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.BlockRootMerkle" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.BlockRootMerkle" , decoder : | buf : & [u8] | { let msg : BlockRootMerkle = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_PRODUCER_TO_LAST_PRODUCED : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.ProducerToLastProduced")] impl :: prost_wkt :: MessageSerde for ProducerToLastProduced { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "ProducerToLastProduced" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.ProducerToLastProduced" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.ProducerToLastProduced" , decoder : | buf : & [u8] | { let msg : ProducerToLastProduced = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_PRODUCER_TO_LAST_IMPLIED_IRB : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.ProducerToLastImpliedIRB")] impl :: prost_wkt :: MessageSerde for ProducerToLastImpliedIrb { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "ProducerToLastImpliedIRB" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.ProducerToLastImpliedIRB" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.ProducerToLastImpliedIRB" , decoder : | buf : & [u8] | { let msg : ProducerToLastImpliedIrb = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_TRANSACTION_RECEIPT : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.TransactionReceipt")] impl :: prost_wkt :: MessageSerde for TransactionReceipt { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "TransactionReceipt" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.TransactionReceipt" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.TransactionReceipt" , decoder : | buf : & [u8] | { let msg : TransactionReceipt = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_PACKED_TRANSACTION : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.PackedTransaction")] impl :: prost_wkt :: MessageSerde for PackedTransaction { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "PackedTransaction" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.PackedTransaction" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.PackedTransaction" , decoder : | buf : & [u8] | { let msg : PackedTransaction = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_BLOCK_HEADER : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.BlockHeader")] impl :: prost_wkt :: MessageSerde for BlockHeader { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "BlockHeader" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.BlockHeader" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.BlockHeader" , decoder : | buf : & [u8] | { let msg : BlockHeader = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_TRANSACTION_EVENT : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.TransactionEvent")] impl :: prost_wkt :: MessageSerde for TransactionEvent { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "TransactionEvent" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.TransactionEvent" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.TransactionEvent" , decoder : | buf : & [u8] | { let msg : TransactionEvent = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_PUBLIC_KEYS : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.PublicKeys")] impl :: prost_wkt :: MessageSerde for PublicKeys { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "PublicKeys" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.PublicKeys" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.PublicKeys" , decoder : | buf : & [u8] | { let msg : PublicKeys = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_TRANSACTION_LIFECYCLE : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.TransactionLifecycle")] impl :: prost_wkt :: MessageSerde for TransactionLifecycle { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "TransactionLifecycle" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.TransactionLifecycle" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.TransactionLifecycle" , decoder : | buf : & [u8] | { let msg : TransactionLifecycle = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_SIGNED_TRANSACTION : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.SignedTransaction")] impl :: prost_wkt :: MessageSerde for SignedTransaction { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "SignedTransaction" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.SignedTransaction" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.SignedTransaction" , decoder : | buf : & [u8] | { let msg : SignedTransaction = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_TRANSACTION : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.Transaction")] impl :: prost_wkt :: MessageSerde for Transaction { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "Transaction" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.Transaction" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.Transaction" , decoder : | buf : & [u8] | { let msg : Transaction = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_TRANSACTION_HEADER : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.TransactionHeader")] impl :: prost_wkt :: MessageSerde for TransactionHeader { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "TransactionHeader" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.TransactionHeader" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.TransactionHeader" , decoder : | buf : & [u8] | { let msg : TransactionHeader = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_TRANSACTION_TRACE : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.TransactionTrace")] impl :: prost_wkt :: MessageSerde for TransactionTrace { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "TransactionTrace" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.TransactionTrace" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.TransactionTrace" , decoder : | buf : & [u8] | { let msg : TransactionTrace = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_TRANSACTION_RECEIPT_HEADER : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.TransactionReceiptHeader")] impl :: prost_wkt :: MessageSerde for TransactionReceiptHeader { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "TransactionReceiptHeader" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.TransactionReceiptHeader" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.TransactionReceiptHeader" , decoder : | buf : & [u8] | { let msg : TransactionReceiptHeader = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_ACTION : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.Action")] impl :: prost_wkt :: MessageSerde for Action { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "Action" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.Action" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.Action" , decoder : | buf : & [u8] | { let msg : Action = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_ACTION_TRACE : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.ActionTrace")] impl :: prost_wkt :: MessageSerde for ActionTrace { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "ActionTrace" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.ActionTrace" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.ActionTrace" , decoder : | buf : & [u8] | { let msg : ActionTrace = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_ACTION_RECEIPT : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.ActionReceipt")] impl :: prost_wkt :: MessageSerde for ActionReceipt { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "ActionReceipt" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.ActionReceipt" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.ActionReceipt" , decoder : | buf : & [u8] | { let msg : ActionReceipt = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_AUTH_SEQUENCE : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.AuthSequence")] impl :: prost_wkt :: MessageSerde for AuthSequence { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "AuthSequence" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.AuthSequence" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.AuthSequence" , decoder : | buf : & [u8] | { let msg : AuthSequence = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_ACCOUNT_RAM_DELTA : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.AccountRAMDelta")] impl :: prost_wkt :: MessageSerde for AccountRamDelta { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "AccountRAMDelta" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.AccountRAMDelta" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.AccountRAMDelta" , decoder : | buf : & [u8] | { let msg : AccountRamDelta = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_ACCOUNT_DELTA : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.AccountDelta")] impl :: prost_wkt :: MessageSerde for AccountDelta { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "AccountDelta" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.AccountDelta" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.AccountDelta" , decoder : | buf : & [u8] | { let msg : AccountDelta = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_EXTENSION : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.Extension")] impl :: prost_wkt :: MessageSerde for Extension { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "Extension" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.Extension" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.Extension" , decoder : | buf : & [u8] | { let msg : Extension = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_TRX_OP : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.TrxOp")] impl :: prost_wkt :: MessageSerde for TrxOp { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "TrxOp" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.TrxOp" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.TrxOp" , decoder : | buf : & [u8] | { let msg : TrxOp = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_DB_OP : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.DBOp")] impl :: prost_wkt :: MessageSerde for DbOp { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "DBOp" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.DBOp" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.DBOp" , decoder : | buf : & [u8] | { let msg : DbOp = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_RAM_OP : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.RAMOp")] impl :: prost_wkt :: MessageSerde for RamOp { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "RAMOp" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.RAMOp" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.RAMOp" , decoder : | buf : & [u8] | { let msg : RamOp = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_RAM_CORRECTION_OP : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.RAMCorrectionOp")] impl :: prost_wkt :: MessageSerde for RamCorrectionOp { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "RAMCorrectionOp" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.RAMCorrectionOp" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.RAMCorrectionOp" , decoder : | buf : & [u8] | { let msg : RamCorrectionOp = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_TABLE_OP : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.TableOp")] impl :: prost_wkt :: MessageSerde for TableOp { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "TableOp" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.TableOp" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.TableOp" , decoder : | buf : & [u8] | { let msg : TableOp = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_D_TRX_OP : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.DTrxOp")] impl :: prost_wkt :: MessageSerde for DTrxOp { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "DTrxOp" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.DTrxOp" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.DTrxOp" , decoder : | buf : & [u8] | { let msg : DTrxOp = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_EXT_D_TRX_OP : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.ExtDTrxOp")] impl :: prost_wkt :: MessageSerde for ExtDTrxOp { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "ExtDTrxOp" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.ExtDTrxOp" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.ExtDTrxOp" , decoder : | buf : & [u8] | { let msg : ExtDTrxOp = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_FEATURE_OP : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.FeatureOp")] impl :: prost_wkt :: MessageSerde for FeatureOp { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "FeatureOp" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.FeatureOp" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.FeatureOp" , decoder : | buf : & [u8] | { let msg : FeatureOp = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_CREATION_FLAT_NODE : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.CreationFlatNode")] impl :: prost_wkt :: MessageSerde for CreationFlatNode { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "CreationFlatNode" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.CreationFlatNode" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.CreationFlatNode" , decoder : | buf : & [u8] | { let msg : CreationFlatNode = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_PERM_OP : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.PermOp")] impl :: prost_wkt :: MessageSerde for PermOp { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "PermOp" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.PermOp" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.PermOp" , decoder : | buf : & [u8] | { let msg : PermOp = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_PERMISSION_OBJECT : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.PermissionObject")] impl :: prost_wkt :: MessageSerde for PermissionObject { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "PermissionObject" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.PermissionObject" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.PermissionObject" , decoder : | buf : & [u8] | { let msg : PermissionObject = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_PERMISSION : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.Permission")] impl :: prost_wkt :: MessageSerde for Permission { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "Permission" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.Permission" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.Permission" , decoder : | buf : & [u8] | { let msg : Permission = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_AUTHORITY : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.Authority")] impl :: prost_wkt :: MessageSerde for Authority { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "Authority" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.Authority" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.Authority" , decoder : | buf : & [u8] | { let msg : Authority = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_KEY_WEIGHT : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.KeyWeight")] impl :: prost_wkt :: MessageSerde for KeyWeight { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "KeyWeight" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.KeyWeight" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.KeyWeight" , decoder : | buf : & [u8] | { let msg : KeyWeight = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_PERMISSION_LEVEL : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.PermissionLevel")] impl :: prost_wkt :: MessageSerde for PermissionLevel { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "PermissionLevel" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.PermissionLevel" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.PermissionLevel" , decoder : | buf : & [u8] | { let msg : PermissionLevel = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_PERMISSION_LEVEL_WEIGHT : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.PermissionLevelWeight")] impl :: prost_wkt :: MessageSerde for PermissionLevelWeight { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "PermissionLevelWeight" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.PermissionLevelWeight" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.PermissionLevelWeight" , decoder : | buf : & [u8] | { let msg : PermissionLevelWeight = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_WAIT_WEIGHT : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.WaitWeight")] impl :: prost_wkt :: MessageSerde for WaitWeight { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "WaitWeight" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.WaitWeight" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.WaitWeight" , decoder : | buf : & [u8] | { let msg : WaitWeight = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_RLIMIT_OP : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.RlimitOp")] impl :: prost_wkt :: MessageSerde for RlimitOp { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "RlimitOp" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.RlimitOp" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.RlimitOp" , decoder : | buf : & [u8] | { let msg : RlimitOp = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_RLIMIT_STATE : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.RlimitState")] impl :: prost_wkt :: MessageSerde for RlimitState { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "RlimitState" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.RlimitState" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.RlimitState" , decoder : | buf : & [u8] | { let msg : RlimitState = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_RLIMIT_CONFIG : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.RlimitConfig")] impl :: prost_wkt :: MessageSerde for RlimitConfig { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "RlimitConfig" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.RlimitConfig" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.RlimitConfig" , decoder : | buf : & [u8] | { let msg : RlimitConfig = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_RLIMIT_ACCOUNT_LIMITS : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.RlimitAccountLimits")] impl :: prost_wkt :: MessageSerde for RlimitAccountLimits { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "RlimitAccountLimits" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.RlimitAccountLimits" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.RlimitAccountLimits" , decoder : | buf : & [u8] | { let msg : RlimitAccountLimits = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_RLIMIT_ACCOUNT_USAGE : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.RlimitAccountUsage")] impl :: prost_wkt :: MessageSerde for RlimitAccountUsage { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "RlimitAccountUsage" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.RlimitAccountUsage" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.RlimitAccountUsage" , decoder : | buf : & [u8] | { let msg : RlimitAccountUsage = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_USAGE_ACCUMULATOR : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.UsageAccumulator")] impl :: prost_wkt :: MessageSerde for UsageAccumulator { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "UsageAccumulator" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.UsageAccumulator" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.UsageAccumulator" , decoder : | buf : & [u8] | { let msg : UsageAccumulator = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_ELASTIC_LIMIT_PARAMETERS : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.ElasticLimitParameters")] impl :: prost_wkt :: MessageSerde for ElasticLimitParameters { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "ElasticLimitParameters" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.ElasticLimitParameters" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.ElasticLimitParameters" , decoder : | buf : & [u8] | { let msg : ElasticLimitParameters = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_RATIO : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.Ratio")] impl :: prost_wkt :: MessageSerde for Ratio { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "Ratio" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.Ratio" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.Ratio" , decoder : | buf : & [u8] | { let msg : Ratio = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_EXCEPTION : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.Exception")] impl :: prost_wkt :: MessageSerde for Exception { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "Exception" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.Exception" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.Exception" , decoder : | buf : & [u8] | { let msg : Exception = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_FEATURE : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.Feature")] impl :: prost_wkt :: MessageSerde for Feature { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "Feature" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.Feature" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.Feature" , decoder : | buf : & [u8] | { let msg : Feature = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_SUBJECTIVE_RESTRICTIONS : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.SubjectiveRestrictions")] impl :: prost_wkt :: MessageSerde for SubjectiveRestrictions { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "SubjectiveRestrictions" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.SubjectiveRestrictions" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.SubjectiveRestrictions" , decoder : | buf : & [u8] | { let msg : SubjectiveRestrictions = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_SPECIFICATION : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.Specification")] impl :: prost_wkt :: MessageSerde for Specification { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "Specification" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.Specification" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.Specification" , decoder : | buf : & [u8] | { let msg : Specification = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_ACCOUNT_CREATION_REF : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.AccountCreationRef")] impl :: prost_wkt :: MessageSerde for AccountCreationRef { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "AccountCreationRef" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.AccountCreationRef" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.AccountCreationRef" , decoder : | buf : & [u8] | { let msg : AccountCreationRef = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_HEADER_ONLY_BLOCK : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.HeaderOnlyBlock")] impl :: prost_wkt :: MessageSerde for HeaderOnlyBlock { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "HeaderOnlyBlock" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.HeaderOnlyBlock" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.HeaderOnlyBlock" , decoder : | buf : & [u8] | { let msg : HeaderOnlyBlock = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_TRANSACTION_TRACE_WITH_BLOCK_REF : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.TransactionTraceWithBlockRef")] impl :: prost_wkt :: MessageSerde for TransactionTraceWithBlockRef { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "TransactionTraceWithBlockRef" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.TransactionTraceWithBlockRef" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.TransactionTraceWithBlockRef" , decoder : | buf : & [u8] | { let msg : TransactionTraceWithBlockRef = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_BLOCK_REF : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.BlockRef")] impl :: prost_wkt :: MessageSerde for BlockRef { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "BlockRef" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.BlockRef" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.BlockRef" , decoder : | buf : & [u8] | { let msg : BlockRef = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_ACTION_TRACES : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.ActionTraces")] impl :: prost_wkt :: MessageSerde for ActionTraces { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "ActionTraces" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.ActionTraces" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.ActionTraces" , decoder : | buf : & [u8] | { let msg : ActionTraces = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_TRANSACTION_TRACES : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.TransactionTraces")] impl :: prost_wkt :: MessageSerde for TransactionTraces { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "TransactionTraces" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.TransactionTraces" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.TransactionTraces" , decoder : | buf : & [u8] | { let msg : TransactionTraces = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_DB_OPS : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.DBOps")] impl :: prost_wkt :: MessageSerde for DbOps { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "DBOps" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.DBOps" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.DBOps" , decoder : | buf : & [u8] | { let msg : DbOps = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_BLOCK : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.Block")] impl :: prost_wkt :: MessageSerde for Block { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "Block" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.Block" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.Block" , decoder : | buf : & [u8] | { let msg : Block = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_BLOCK_WITH_REFS : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.BlockWithRefs")] impl :: prost_wkt :: MessageSerde for BlockWithRefs { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "BlockWithRefs" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.BlockWithRefs" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.BlockWithRefs" , decoder : | buf : & [u8] | { let msg : BlockWithRefs = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_TRANSACTION_REFS : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.TransactionRefs")] impl :: prost_wkt :: MessageSerde for TransactionRefs { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "TransactionRefs" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.TransactionRefs" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.TransactionRefs" , decoder : | buf : & [u8] | { let msg : TransactionRefs = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_ACTIVATED_PROTOCOL_FEATURES : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.ActivatedProtocolFeatures")] impl :: prost_wkt :: MessageSerde for ActivatedProtocolFeatures { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "ActivatedProtocolFeatures" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.ActivatedProtocolFeatures" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.ActivatedProtocolFeatures" , decoder : | buf : & [u8] | { let msg : ActivatedProtocolFeatures = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_PENDING_PRODUCER_SCHEDULE : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.PendingProducerSchedule")] impl :: prost_wkt :: MessageSerde for PendingProducerSchedule { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "PendingProducerSchedule" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.PendingProducerSchedule" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.PendingProducerSchedule" , decoder : | buf : & [u8] | { let msg : PendingProducerSchedule = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_PRODUCER_SCHEDULE : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.ProducerSchedule")] impl :: prost_wkt :: MessageSerde for ProducerSchedule { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "ProducerSchedule" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.ProducerSchedule" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.ProducerSchedule" , decoder : | buf : & [u8] | { let msg : ProducerSchedule = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_PRODUCER_KEY : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.ProducerKey")] impl :: prost_wkt :: MessageSerde for ProducerKey { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "ProducerKey" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.ProducerKey" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.ProducerKey" , decoder : | buf : & [u8] | { let msg : ProducerKey = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_PRODUCER_AUTHORITY_SCHEDULE : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.ProducerAuthoritySchedule")] impl :: prost_wkt :: MessageSerde for ProducerAuthoritySchedule { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "ProducerAuthoritySchedule" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.ProducerAuthoritySchedule" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.ProducerAuthoritySchedule" , decoder : | buf : & [u8] | { let msg : ProducerAuthoritySchedule = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_PRODUCER_AUTHORITY : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.ProducerAuthority")] impl :: prost_wkt :: MessageSerde for ProducerAuthority { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "ProducerAuthority" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.ProducerAuthority" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.ProducerAuthority" , decoder : | buf : & [u8] | { let msg : ProducerAuthority = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_BLOCK_SIGNING_AUTHORITY : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.BlockSigningAuthority")] impl :: prost_wkt :: MessageSerde for BlockSigningAuthority { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "BlockSigningAuthority" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.BlockSigningAuthority" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.BlockSigningAuthority" , decoder : | buf : & [u8] | { let msg : BlockSigningAuthority = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_BLOCK_SIGNING_AUTHORITY_V0 : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.BlockSigningAuthorityV0")] impl :: prost_wkt :: MessageSerde for BlockSigningAuthorityV0 { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "BlockSigningAuthorityV0" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.BlockSigningAuthorityV0" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.BlockSigningAuthorityV0" , decoder : | buf : & [u8] | { let msg : BlockSigningAuthorityV0 = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_BLOCK_ROOT_MERKLE : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.BlockRootMerkle")] impl :: prost_wkt :: MessageSerde for BlockRootMerkle { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "BlockRootMerkle" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.BlockRootMerkle" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.BlockRootMerkle" , decoder : | buf : & [u8] | { let msg : BlockRootMerkle = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_PRODUCER_TO_LAST_PRODUCED : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.ProducerToLastProduced")] impl :: prost_wkt :: MessageSerde for ProducerToLastProduced { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "ProducerToLastProduced" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.ProducerToLastProduced" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.ProducerToLastProduced" , decoder : | buf : & [u8] | { let msg : ProducerToLastProduced = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_PRODUCER_TO_LAST_IMPLIED_IRB : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.ProducerToLastImpliedIRB")] impl :: prost_wkt :: MessageSerde for ProducerToLastImpliedIrb { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "ProducerToLastImpliedIRB" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.ProducerToLastImpliedIRB" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.ProducerToLastImpliedIRB" , decoder : | buf : & [u8] | { let msg : ProducerToLastImpliedIrb = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_TRANSACTION_RECEIPT : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.TransactionReceipt")] impl :: prost_wkt :: MessageSerde for TransactionReceipt { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "TransactionReceipt" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.TransactionReceipt" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.TransactionReceipt" , decoder : | buf : & [u8] | { let msg : TransactionReceipt = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_PACKED_TRANSACTION : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.PackedTransaction")] impl :: prost_wkt :: MessageSerde for PackedTransaction { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "PackedTransaction" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.PackedTransaction" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.PackedTransaction" , decoder : | buf : & [u8] | { let msg : PackedTransaction = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_BLOCK_HEADER : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.BlockHeader")] impl :: prost_wkt :: MessageSerde for BlockHeader { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "BlockHeader" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.BlockHeader" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.BlockHeader" , decoder : | buf : & [u8] | { let msg : BlockHeader = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_TRANSACTION_EVENT : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.TransactionEvent")] impl :: prost_wkt :: MessageSerde for TransactionEvent { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "TransactionEvent" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.TransactionEvent" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.TransactionEvent" , decoder : | buf : & [u8] | { let msg : TransactionEvent = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_PUBLIC_KEYS : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.PublicKeys")] impl :: prost_wkt :: MessageSerde for PublicKeys { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "PublicKeys" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.PublicKeys" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.PublicKeys" , decoder : | buf : & [u8] | { let msg : PublicKeys = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_TRANSACTION_LIFECYCLE : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.TransactionLifecycle")] impl :: prost_wkt :: MessageSerde for TransactionLifecycle { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "TransactionLifecycle" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.TransactionLifecycle" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.TransactionLifecycle" , decoder : | buf : & [u8] | { let msg : TransactionLifecycle = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_SIGNED_TRANSACTION : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.SignedTransaction")] impl :: prost_wkt :: MessageSerde for SignedTransaction { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "SignedTransaction" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.SignedTransaction" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.SignedTransaction" , decoder : | buf : & [u8] | { let msg : SignedTransaction = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_TRANSACTION : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.Transaction")] impl :: prost_wkt :: MessageSerde for Transaction { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "Transaction" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.Transaction" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.Transaction" , decoder : | buf : & [u8] | { let msg : Transaction = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_TRANSACTION_HEADER : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.TransactionHeader")] impl :: prost_wkt :: MessageSerde for TransactionHeader { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "TransactionHeader" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.TransactionHeader" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.TransactionHeader" , decoder : | buf : & [u8] | { let msg : TransactionHeader = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_TRANSACTION_TRACE : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.TransactionTrace")] impl :: prost_wkt :: MessageSerde for TransactionTrace { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "TransactionTrace" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.TransactionTrace" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.TransactionTrace" , decoder : | buf : & [u8] | { let msg : TransactionTrace = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_TRANSACTION_RECEIPT_HEADER : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.TransactionReceiptHeader")] impl :: prost_wkt :: MessageSerde for TransactionReceiptHeader { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "TransactionReceiptHeader" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.TransactionReceiptHeader" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.TransactionReceiptHeader" , decoder : | buf : & [u8] | { let msg : TransactionReceiptHeader = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_ACTION : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.Action")] impl :: prost_wkt :: MessageSerde for Action { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "Action" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.Action" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.Action" , decoder : | buf : & [u8] | { let msg : Action = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_ACTION_TRACE : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.ActionTrace")] impl :: prost_wkt :: MessageSerde for ActionTrace { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "ActionTrace" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.ActionTrace" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.ActionTrace" , decoder : | buf : & [u8] | { let msg : ActionTrace = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_ACTION_RECEIPT : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.ActionReceipt")] impl :: prost_wkt :: MessageSerde for ActionReceipt { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "ActionReceipt" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.ActionReceipt" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.ActionReceipt" , decoder : | buf : & [u8] | { let msg : ActionReceipt = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_AUTH_SEQUENCE : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.AuthSequence")] impl :: prost_wkt :: MessageSerde for AuthSequence { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "AuthSequence" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.AuthSequence" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.AuthSequence" , decoder : | buf : & [u8] | { let msg : AuthSequence = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_ACCOUNT_RAM_DELTA : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.AccountRAMDelta")] impl :: prost_wkt :: MessageSerde for AccountRamDelta { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "AccountRAMDelta" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.AccountRAMDelta" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.AccountRAMDelta" , decoder : | buf : & [u8] | { let msg : AccountRamDelta = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_ACCOUNT_DELTA : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.AccountDelta")] impl :: prost_wkt :: MessageSerde for AccountDelta { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "AccountDelta" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.AccountDelta" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.AccountDelta" , decoder : | buf : & [u8] | { let msg : AccountDelta = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_EXTENSION : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.Extension")] impl :: prost_wkt :: MessageSerde for Extension { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "Extension" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.Extension" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.Extension" , decoder : | buf : & [u8] | { let msg : Extension = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_TRX_OP : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.TrxOp")] impl :: prost_wkt :: MessageSerde for TrxOp { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "TrxOp" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.TrxOp" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.TrxOp" , decoder : | buf : & [u8] | { let msg : TrxOp = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_DB_OP : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.DBOp")] impl :: prost_wkt :: MessageSerde for DbOp { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "DBOp" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.DBOp" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.DBOp" , decoder : | buf : & [u8] | { let msg : DbOp = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_RAM_OP : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.RAMOp")] impl :: prost_wkt :: MessageSerde for RamOp { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "RAMOp" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.RAMOp" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.RAMOp" , decoder : | buf : & [u8] | { let msg : RamOp = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_RAM_CORRECTION_OP : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.RAMCorrectionOp")] impl :: prost_wkt :: MessageSerde for RamCorrectionOp { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "RAMCorrectionOp" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.RAMCorrectionOp" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.RAMCorrectionOp" , decoder : | buf : & [u8] | { let msg : RamCorrectionOp = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_TABLE_OP : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.TableOp")] impl :: prost_wkt :: MessageSerde for TableOp { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "TableOp" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.TableOp" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.TableOp" , decoder : | buf : & [u8] | { let msg : TableOp = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_D_TRX_OP : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.DTrxOp")] impl :: prost_wkt :: MessageSerde for DTrxOp { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "DTrxOp" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.DTrxOp" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.DTrxOp" , decoder : | buf : & [u8] | { let msg : DTrxOp = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_EXT_D_TRX_OP : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.ExtDTrxOp")] impl :: prost_wkt :: MessageSerde for ExtDTrxOp { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "ExtDTrxOp" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.ExtDTrxOp" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.ExtDTrxOp" , decoder : | buf : & [u8] | { let msg : ExtDTrxOp = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_FEATURE_OP : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.FeatureOp")] impl :: prost_wkt :: MessageSerde for FeatureOp { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "FeatureOp" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.FeatureOp" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.FeatureOp" , decoder : | buf : & [u8] | { let msg : FeatureOp = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_CREATION_FLAT_NODE : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.CreationFlatNode")] impl :: prost_wkt :: MessageSerde for CreationFlatNode { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "CreationFlatNode" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.CreationFlatNode" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.CreationFlatNode" , decoder : | buf : & [u8] | { let msg : CreationFlatNode = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_PERM_OP : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.PermOp")] impl :: prost_wkt :: MessageSerde for PermOp { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "PermOp" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.PermOp" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.PermOp" , decoder : | buf : & [u8] | { let msg : PermOp = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_PERMISSION_OBJECT : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.PermissionObject")] impl :: prost_wkt :: MessageSerde for PermissionObject { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "PermissionObject" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.PermissionObject" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.PermissionObject" , decoder : | buf : & [u8] | { let msg : PermissionObject = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_PERMISSION : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.Permission")] impl :: prost_wkt :: MessageSerde for Permission { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "Permission" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.Permission" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.Permission" , decoder : | buf : & [u8] | { let msg : Permission = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_AUTHORITY : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.Authority")] impl :: prost_wkt :: MessageSerde for Authority { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "Authority" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.Authority" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.Authority" , decoder : | buf : & [u8] | { let msg : Authority = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_KEY_WEIGHT : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.KeyWeight")] impl :: prost_wkt :: MessageSerde for KeyWeight { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "KeyWeight" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.KeyWeight" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.KeyWeight" , decoder : | buf : & [u8] | { let msg : KeyWeight = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_PERMISSION_LEVEL : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.PermissionLevel")] impl :: prost_wkt :: MessageSerde for PermissionLevel { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "PermissionLevel" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.PermissionLevel" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.PermissionLevel" , decoder : | buf : & [u8] | { let msg : PermissionLevel = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_PERMISSION_LEVEL_WEIGHT : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.PermissionLevelWeight")] impl :: prost_wkt :: MessageSerde for PermissionLevelWeight { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "PermissionLevelWeight" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.PermissionLevelWeight" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.PermissionLevelWeight" , decoder : | buf : & [u8] | { let msg : PermissionLevelWeight = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_WAIT_WEIGHT : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.WaitWeight")] impl :: prost_wkt :: MessageSerde for WaitWeight { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "WaitWeight" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.WaitWeight" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.WaitWeight" , decoder : | buf : & [u8] | { let msg : WaitWeight = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_RLIMIT_OP : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.RlimitOp")] impl :: prost_wkt :: MessageSerde for RlimitOp { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "RlimitOp" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.RlimitOp" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.RlimitOp" , decoder : | buf : & [u8] | { let msg : RlimitOp = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_RLIMIT_STATE : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.RlimitState")] impl :: prost_wkt :: MessageSerde for RlimitState { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "RlimitState" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.RlimitState" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.RlimitState" , decoder : | buf : & [u8] | { let msg : RlimitState = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_RLIMIT_CONFIG : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.RlimitConfig")] impl :: prost_wkt :: MessageSerde for RlimitConfig { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "RlimitConfig" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.RlimitConfig" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.RlimitConfig" , decoder : | buf : & [u8] | { let msg : RlimitConfig = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_RLIMIT_ACCOUNT_LIMITS : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.RlimitAccountLimits")] impl :: prost_wkt :: MessageSerde for RlimitAccountLimits { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "RlimitAccountLimits" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.RlimitAccountLimits" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.RlimitAccountLimits" , decoder : | buf : & [u8] | { let msg : RlimitAccountLimits = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_RLIMIT_ACCOUNT_USAGE : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.RlimitAccountUsage")] impl :: prost_wkt :: MessageSerde for RlimitAccountUsage { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "RlimitAccountUsage" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.RlimitAccountUsage" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.RlimitAccountUsage" , decoder : | buf : & [u8] | { let msg : RlimitAccountUsage = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_USAGE_ACCUMULATOR : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.UsageAccumulator")] impl :: prost_wkt :: MessageSerde for UsageAccumulator { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "UsageAccumulator" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.UsageAccumulator" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.UsageAccumulator" , decoder : | buf : & [u8] | { let msg : UsageAccumulator = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_ELASTIC_LIMIT_PARAMETERS : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.ElasticLimitParameters")] impl :: prost_wkt :: MessageSerde for ElasticLimitParameters { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "ElasticLimitParameters" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.ElasticLimitParameters" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.ElasticLimitParameters" , decoder : | buf : & [u8] | { let msg : ElasticLimitParameters = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_RATIO : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.Ratio")] impl :: prost_wkt :: MessageSerde for Ratio { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "Ratio" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.Ratio" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.Ratio" , decoder : | buf : & [u8] | { let msg : Ratio = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_EXCEPTION : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.Exception")] impl :: prost_wkt :: MessageSerde for Exception { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "Exception" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.Exception" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.Exception" , decoder : | buf : & [u8] | { let msg : Exception = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_FEATURE : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.Feature")] impl :: prost_wkt :: MessageSerde for Feature { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "Feature" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.Feature" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.Feature" , decoder : | buf : & [u8] | { let msg : Feature = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_SUBJECTIVE_RESTRICTIONS : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.SubjectiveRestrictions")] impl :: prost_wkt :: MessageSerde for SubjectiveRestrictions { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "SubjectiveRestrictions" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.SubjectiveRestrictions" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.SubjectiveRestrictions" , decoder : | buf : & [u8] | { let msg : SubjectiveRestrictions = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_SPECIFICATION : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.Specification")] impl :: prost_wkt :: MessageSerde for Specification { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "Specification" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.Specification" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.Specification" , decoder : | buf : & [u8] | { let msg : Specification = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_ACCOUNT_CREATION_REF : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.AccountCreationRef")] impl :: prost_wkt :: MessageSerde for AccountCreationRef { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "AccountCreationRef" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.AccountCreationRef" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.AccountCreationRef" , decoder : | buf : & [u8] | { let msg : AccountCreationRef = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_HEADER_ONLY_BLOCK : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.HeaderOnlyBlock")] impl :: prost_wkt :: MessageSerde for HeaderOnlyBlock { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "HeaderOnlyBlock" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.HeaderOnlyBlock" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.HeaderOnlyBlock" , decoder : | buf : & [u8] | { let msg : HeaderOnlyBlock = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_TRANSACTION_TRACE_WITH_BLOCK_REF : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.TransactionTraceWithBlockRef")] impl :: prost_wkt :: MessageSerde for TransactionTraceWithBlockRef { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "TransactionTraceWithBlockRef" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.TransactionTraceWithBlockRef" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.TransactionTraceWithBlockRef" , decoder : | buf : & [u8] | { let msg : TransactionTraceWithBlockRef = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_BLOCK_REF : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.BlockRef")] impl :: prost_wkt :: MessageSerde for BlockRef { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "BlockRef" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.BlockRef" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.BlockRef" , decoder : | buf : & [u8] | { let msg : BlockRef = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_ACTION_TRACES : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.ActionTraces")] impl :: prost_wkt :: MessageSerde for ActionTraces { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "ActionTraces" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.ActionTraces" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.ActionTraces" , decoder : | buf : & [u8] | { let msg : ActionTraces = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_TRANSACTION_TRACES : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.TransactionTraces")] impl :: prost_wkt :: MessageSerde for TransactionTraces { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "TransactionTraces" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.TransactionTraces" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.TransactionTraces" , decoder : | buf : & [u8] | { let msg : TransactionTraces = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_DB_OPS : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.DBOps")] impl :: prost_wkt :: MessageSerde for DbOps { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "DBOps" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.DBOps" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.DBOps" , decoder : | buf : & [u8] | { let msg : DbOps = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_BLOCK : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.Block")] impl :: prost_wkt :: MessageSerde for Block { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "Block" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.Block" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.Block" , decoder : | buf : & [u8] | { let msg : Block = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_BLOCK_WITH_REFS : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.BlockWithRefs")] impl :: prost_wkt :: MessageSerde for BlockWithRefs { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "BlockWithRefs" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.BlockWithRefs" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.BlockWithRefs" , decoder : | buf : & [u8] | { let msg : BlockWithRefs = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_TRANSACTION_REFS : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.TransactionRefs")] impl :: prost_wkt :: MessageSerde for TransactionRefs { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "TransactionRefs" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.TransactionRefs" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.TransactionRefs" , decoder : | buf : & [u8] | { let msg : TransactionRefs = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_ACTIVATED_PROTOCOL_FEATURES : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.ActivatedProtocolFeatures")] impl :: prost_wkt :: MessageSerde for ActivatedProtocolFeatures { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "ActivatedProtocolFeatures" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.ActivatedProtocolFeatures" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.ActivatedProtocolFeatures" , decoder : | buf : & [u8] | { let msg : ActivatedProtocolFeatures = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_PENDING_PRODUCER_SCHEDULE : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.PendingProducerSchedule")] impl :: prost_wkt :: MessageSerde for PendingProducerSchedule { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "PendingProducerSchedule" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.PendingProducerSchedule" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.PendingProducerSchedule" , decoder : | buf : & [u8] | { let msg : PendingProducerSchedule = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_PRODUCER_SCHEDULE : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.ProducerSchedule")] impl :: prost_wkt :: MessageSerde for ProducerSchedule { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "ProducerSchedule" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.ProducerSchedule" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.ProducerSchedule" , decoder : | buf : & [u8] | { let msg : ProducerSchedule = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_PRODUCER_KEY : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.ProducerKey")] impl :: prost_wkt :: MessageSerde for ProducerKey { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "ProducerKey" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.ProducerKey" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.ProducerKey" , decoder : | buf : & [u8] | { let msg : ProducerKey = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_PRODUCER_AUTHORITY_SCHEDULE : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.ProducerAuthoritySchedule")] impl :: prost_wkt :: MessageSerde for ProducerAuthoritySchedule { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "ProducerAuthoritySchedule" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.ProducerAuthoritySchedule" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.ProducerAuthoritySchedule" , decoder : | buf : & [u8] | { let msg : ProducerAuthoritySchedule = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_PRODUCER_AUTHORITY : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.ProducerAuthority")] impl :: prost_wkt :: MessageSerde for ProducerAuthority { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "ProducerAuthority" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.ProducerAuthority" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.ProducerAuthority" , decoder : | buf : & [u8] | { let msg : ProducerAuthority = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_BLOCK_SIGNING_AUTHORITY : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.BlockSigningAuthority")] impl :: prost_wkt :: MessageSerde for BlockSigningAuthority { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "BlockSigningAuthority" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.BlockSigningAuthority" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.BlockSigningAuthority" , decoder : | buf : & [u8] | { let msg : BlockSigningAuthority = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_BLOCK_SIGNING_AUTHORITY_V0 : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.BlockSigningAuthorityV0")] impl :: prost_wkt :: MessageSerde for BlockSigningAuthorityV0 { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "BlockSigningAuthorityV0" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.BlockSigningAuthorityV0" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.BlockSigningAuthorityV0" , decoder : | buf : & [u8] | { let msg : BlockSigningAuthorityV0 = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_BLOCK_ROOT_MERKLE : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.BlockRootMerkle")] impl :: prost_wkt :: MessageSerde for BlockRootMerkle { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "BlockRootMerkle" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.BlockRootMerkle" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.BlockRootMerkle" , decoder : | buf : & [u8] | { let msg : BlockRootMerkle = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_PRODUCER_TO_LAST_PRODUCED : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.ProducerToLastProduced")] impl :: prost_wkt :: MessageSerde for ProducerToLastProduced { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "ProducerToLastProduced" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.ProducerToLastProduced" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.ProducerToLastProduced" , decoder : | buf : & [u8] | { let msg : ProducerToLastProduced = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_PRODUCER_TO_LAST_IMPLIED_IRB : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.ProducerToLastImpliedIRB")] impl :: prost_wkt :: MessageSerde for ProducerToLastImpliedIrb { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "ProducerToLastImpliedIRB" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.ProducerToLastImpliedIRB" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.ProducerToLastImpliedIRB" , decoder : | buf : & [u8] | { let msg : ProducerToLastImpliedIrb = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_TRANSACTION_RECEIPT : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.TransactionReceipt")] impl :: prost_wkt :: MessageSerde for TransactionReceipt { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "TransactionReceipt" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.TransactionReceipt" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.TransactionReceipt" , decoder : | buf : & [u8] | { let msg : TransactionReceipt = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_PACKED_TRANSACTION : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.PackedTransaction")] impl :: prost_wkt :: MessageSerde for PackedTransaction { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "PackedTransaction" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.PackedTransaction" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.PackedTransaction" , decoder : | buf : & [u8] | { let msg : PackedTransaction = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_BLOCK_HEADER : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.BlockHeader")] impl :: prost_wkt :: MessageSerde for BlockHeader { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "BlockHeader" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.BlockHeader" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.BlockHeader" , decoder : | buf : & [u8] | { let msg : BlockHeader = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_TRANSACTION_EVENT : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.TransactionEvent")] impl :: prost_wkt :: MessageSerde for TransactionEvent { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "TransactionEvent" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.TransactionEvent" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.TransactionEvent" , decoder : | buf : & [u8] | { let msg : TransactionEvent = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_PUBLIC_KEYS : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.PublicKeys")] impl :: prost_wkt :: MessageSerde for PublicKeys { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "PublicKeys" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.PublicKeys" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.PublicKeys" , decoder : | buf : & [u8] | { let msg : PublicKeys = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_TRANSACTION_LIFECYCLE : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.TransactionLifecycle")] impl :: prost_wkt :: MessageSerde for TransactionLifecycle { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "TransactionLifecycle" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.TransactionLifecycle" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.TransactionLifecycle" , decoder : | buf : & [u8] | { let msg : TransactionLifecycle = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_SIGNED_TRANSACTION : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.SignedTransaction")] impl :: prost_wkt :: MessageSerde for SignedTransaction { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "SignedTransaction" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.SignedTransaction" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.SignedTransaction" , decoder : | buf : & [u8] | { let msg : SignedTransaction = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_TRANSACTION : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.Transaction")] impl :: prost_wkt :: MessageSerde for Transaction { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "Transaction" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.Transaction" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.Transaction" , decoder : | buf : & [u8] | { let msg : Transaction = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_TRANSACTION_HEADER : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.TransactionHeader")] impl :: prost_wkt :: MessageSerde for TransactionHeader { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "TransactionHeader" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.TransactionHeader" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.TransactionHeader" , decoder : | buf : & [u8] | { let msg : TransactionHeader = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_TRANSACTION_TRACE : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.TransactionTrace")] impl :: prost_wkt :: MessageSerde for TransactionTrace { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "TransactionTrace" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.TransactionTrace" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.TransactionTrace" , decoder : | buf : & [u8] | { let msg : TransactionTrace = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_TRANSACTION_RECEIPT_HEADER : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.TransactionReceiptHeader")] impl :: prost_wkt :: MessageSerde for TransactionReceiptHeader { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "TransactionReceiptHeader" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.TransactionReceiptHeader" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.TransactionReceiptHeader" , decoder : | buf : & [u8] | { let msg : TransactionReceiptHeader = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_ACTION : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.Action")] impl :: prost_wkt :: MessageSerde for Action { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "Action" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.Action" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.Action" , decoder : | buf : & [u8] | { let msg : Action = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_ACTION_TRACE : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.ActionTrace")] impl :: prost_wkt :: MessageSerde for ActionTrace { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "ActionTrace" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.ActionTrace" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.ActionTrace" , decoder : | buf : & [u8] | { let msg : ActionTrace = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_ACTION_RECEIPT : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.ActionReceipt")] impl :: prost_wkt :: MessageSerde for ActionReceipt { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "ActionReceipt" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.ActionReceipt" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.ActionReceipt" , decoder : | buf : & [u8] | { let msg : ActionReceipt = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_AUTH_SEQUENCE : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.AuthSequence")] impl :: prost_wkt :: MessageSerde for AuthSequence { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "AuthSequence" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.AuthSequence" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.AuthSequence" , decoder : | buf : & [u8] | { let msg : AuthSequence = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_ACCOUNT_RAM_DELTA : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.AccountRAMDelta")] impl :: prost_wkt :: MessageSerde for AccountRamDelta { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "AccountRAMDelta" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.AccountRAMDelta" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.AccountRAMDelta" , decoder : | buf : & [u8] | { let msg : AccountRamDelta = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_ACCOUNT_DELTA : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.AccountDelta")] impl :: prost_wkt :: MessageSerde for AccountDelta { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "AccountDelta" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.AccountDelta" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.AccountDelta" , decoder : | buf : & [u8] | { let msg : AccountDelta = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_EXTENSION : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.Extension")] impl :: prost_wkt :: MessageSerde for Extension { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "Extension" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.Extension" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.Extension" , decoder : | buf : & [u8] | { let msg : Extension = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_TRX_OP : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.TrxOp")] impl :: prost_wkt :: MessageSerde for TrxOp { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "TrxOp" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.TrxOp" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.TrxOp" , decoder : | buf : & [u8] | { let msg : TrxOp = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_DB_OP : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.DBOp")] impl :: prost_wkt :: MessageSerde for DbOp { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "DBOp" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.DBOp" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.DBOp" , decoder : | buf : & [u8] | { let msg : DbOp = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_RAM_OP : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.RAMOp")] impl :: prost_wkt :: MessageSerde for RamOp { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "RAMOp" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.RAMOp" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.RAMOp" , decoder : | buf : & [u8] | { let msg : RamOp = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_RAM_CORRECTION_OP : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.RAMCorrectionOp")] impl :: prost_wkt :: MessageSerde for RamCorrectionOp { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "RAMCorrectionOp" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.RAMCorrectionOp" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.RAMCorrectionOp" , decoder : | buf : & [u8] | { let msg : RamCorrectionOp = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_TABLE_OP : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.TableOp")] impl :: prost_wkt :: MessageSerde for TableOp { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "TableOp" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.TableOp" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.TableOp" , decoder : | buf : & [u8] | { let msg : TableOp = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_D_TRX_OP : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.DTrxOp")] impl :: prost_wkt :: MessageSerde for DTrxOp { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "DTrxOp" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.DTrxOp" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.DTrxOp" , decoder : | buf : & [u8] | { let msg : DTrxOp = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_EXT_D_TRX_OP : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.ExtDTrxOp")] impl :: prost_wkt :: MessageSerde for ExtDTrxOp { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "ExtDTrxOp" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.ExtDTrxOp" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.ExtDTrxOp" , decoder : | buf : & [u8] | { let msg : ExtDTrxOp = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_FEATURE_OP : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.FeatureOp")] impl :: prost_wkt :: MessageSerde for FeatureOp { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "FeatureOp" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.FeatureOp" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.FeatureOp" , decoder : | buf : & [u8] | { let msg : FeatureOp = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_CREATION_FLAT_NODE : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.CreationFlatNode")] impl :: prost_wkt :: MessageSerde for CreationFlatNode { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "CreationFlatNode" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.CreationFlatNode" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.CreationFlatNode" , decoder : | buf : & [u8] | { let msg : CreationFlatNode = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_PERM_OP : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.PermOp")] impl :: prost_wkt :: MessageSerde for PermOp { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "PermOp" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.PermOp" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.PermOp" , decoder : | buf : & [u8] | { let msg : PermOp = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_PERMISSION_OBJECT : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.PermissionObject")] impl :: prost_wkt :: MessageSerde for PermissionObject { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "PermissionObject" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.PermissionObject" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.PermissionObject" , decoder : | buf : & [u8] | { let msg : PermissionObject = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_PERMISSION : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.Permission")] impl :: prost_wkt :: MessageSerde for Permission { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "Permission" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.Permission" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.Permission" , decoder : | buf : & [u8] | { let msg : Permission = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_AUTHORITY : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.Authority")] impl :: prost_wkt :: MessageSerde for Authority { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "Authority" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.Authority" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.Authority" , decoder : | buf : & [u8] | { let msg : Authority = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_KEY_WEIGHT : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.KeyWeight")] impl :: prost_wkt :: MessageSerde for KeyWeight { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "KeyWeight" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.KeyWeight" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.KeyWeight" , decoder : | buf : & [u8] | { let msg : KeyWeight = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_PERMISSION_LEVEL : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.PermissionLevel")] impl :: prost_wkt :: MessageSerde for PermissionLevel { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "PermissionLevel" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.PermissionLevel" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.PermissionLevel" , decoder : | buf : & [u8] | { let msg : PermissionLevel = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_PERMISSION_LEVEL_WEIGHT : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.PermissionLevelWeight")] impl :: prost_wkt :: MessageSerde for PermissionLevelWeight { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "PermissionLevelWeight" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.PermissionLevelWeight" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.PermissionLevelWeight" , decoder : | buf : & [u8] | { let msg : PermissionLevelWeight = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_WAIT_WEIGHT : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.WaitWeight")] impl :: prost_wkt :: MessageSerde for WaitWeight { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "WaitWeight" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.WaitWeight" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.WaitWeight" , decoder : | buf : & [u8] | { let msg : WaitWeight = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_RLIMIT_OP : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.RlimitOp")] impl :: prost_wkt :: MessageSerde for RlimitOp { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "RlimitOp" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.RlimitOp" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.RlimitOp" , decoder : | buf : & [u8] | { let msg : RlimitOp = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_RLIMIT_STATE : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.RlimitState")] impl :: prost_wkt :: MessageSerde for RlimitState { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "RlimitState" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.RlimitState" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.RlimitState" , decoder : | buf : & [u8] | { let msg : RlimitState = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_RLIMIT_CONFIG : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.RlimitConfig")] impl :: prost_wkt :: MessageSerde for RlimitConfig { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "RlimitConfig" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.RlimitConfig" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.RlimitConfig" , decoder : | buf : & [u8] | { let msg : RlimitConfig = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_RLIMIT_ACCOUNT_LIMITS : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.RlimitAccountLimits")] impl :: prost_wkt :: MessageSerde for RlimitAccountLimits { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "RlimitAccountLimits" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.RlimitAccountLimits" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.RlimitAccountLimits" , decoder : | buf : & [u8] | { let msg : RlimitAccountLimits = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_RLIMIT_ACCOUNT_USAGE : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.RlimitAccountUsage")] impl :: prost_wkt :: MessageSerde for RlimitAccountUsage { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "RlimitAccountUsage" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.RlimitAccountUsage" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.RlimitAccountUsage" , decoder : | buf : & [u8] | { let msg : RlimitAccountUsage = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_USAGE_ACCUMULATOR : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.UsageAccumulator")] impl :: prost_wkt :: MessageSerde for UsageAccumulator { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "UsageAccumulator" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.UsageAccumulator" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.UsageAccumulator" , decoder : | buf : & [u8] | { let msg : UsageAccumulator = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_ELASTIC_LIMIT_PARAMETERS : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.ElasticLimitParameters")] impl :: prost_wkt :: MessageSerde for ElasticLimitParameters { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "ElasticLimitParameters" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.ElasticLimitParameters" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.ElasticLimitParameters" , decoder : | buf : & [u8] | { let msg : ElasticLimitParameters = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_RATIO : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.Ratio")] impl :: prost_wkt :: MessageSerde for Ratio { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "Ratio" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.Ratio" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.Ratio" , decoder : | buf : & [u8] | { let msg : Ratio = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_EXCEPTION : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.Exception")] impl :: prost_wkt :: MessageSerde for Exception { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "Exception" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.Exception" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.Exception" , decoder : | buf : & [u8] | { let msg : Exception = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_FEATURE : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.Feature")] impl :: prost_wkt :: MessageSerde for Feature { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "Feature" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.Feature" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.Feature" , decoder : | buf : & [u8] | { let msg : Feature = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_SUBJECTIVE_RESTRICTIONS : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.SubjectiveRestrictions")] impl :: prost_wkt :: MessageSerde for SubjectiveRestrictions { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "SubjectiveRestrictions" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.SubjectiveRestrictions" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.SubjectiveRestrictions" , decoder : | buf : & [u8] | { let msg : SubjectiveRestrictions = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_SPECIFICATION : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.Specification")] impl :: prost_wkt :: MessageSerde for Specification { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "Specification" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.Specification" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.Specification" , decoder : | buf : & [u8] | { let msg : Specification = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_ACCOUNT_CREATION_REF : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.AccountCreationRef")] impl :: prost_wkt :: MessageSerde for AccountCreationRef { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "AccountCreationRef" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.AccountCreationRef" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.AccountCreationRef" , decoder : | buf : & [u8] | { let msg : AccountCreationRef = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_HEADER_ONLY_BLOCK : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.HeaderOnlyBlock")] impl :: prost_wkt :: MessageSerde for HeaderOnlyBlock { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "HeaderOnlyBlock" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.HeaderOnlyBlock" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.HeaderOnlyBlock" , decoder : | buf : & [u8] | { let msg : HeaderOnlyBlock = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_TRANSACTION_TRACE_WITH_BLOCK_REF : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.TransactionTraceWithBlockRef")] impl :: prost_wkt :: MessageSerde for TransactionTraceWithBlockRef { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "TransactionTraceWithBlockRef" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.TransactionTraceWithBlockRef" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.TransactionTraceWithBlockRef" , decoder : | buf : & [u8] | { let msg : TransactionTraceWithBlockRef = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_BLOCK_REF : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.BlockRef")] impl :: prost_wkt :: MessageSerde for BlockRef { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "BlockRef" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.BlockRef" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.BlockRef" , decoder : | buf : & [u8] | { let msg : BlockRef = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_ACTION_TRACES : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.ActionTraces")] impl :: prost_wkt :: MessageSerde for ActionTraces { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "ActionTraces" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.ActionTraces" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.ActionTraces" , decoder : | buf : & [u8] | { let msg : ActionTraces = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_TRANSACTION_TRACES : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.TransactionTraces")] impl :: prost_wkt :: MessageSerde for TransactionTraces { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "TransactionTraces" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.TransactionTraces" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.TransactionTraces" , decoder : | buf : & [u8] | { let msg : TransactionTraces = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_DB_OPS : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.DBOps")] impl :: prost_wkt :: MessageSerde for DbOps { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "DBOps" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.DBOps" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.DBOps" , decoder : | buf : & [u8] | { let msg : DbOps = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_BLOCK : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.Block")] impl :: prost_wkt :: MessageSerde for Block { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "Block" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.Block" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.Block" , decoder : | buf : & [u8] | { let msg : Block = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_BLOCK_WITH_REFS : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.BlockWithRefs")] impl :: prost_wkt :: MessageSerde for BlockWithRefs { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "BlockWithRefs" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.BlockWithRefs" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.BlockWithRefs" , decoder : | buf : & [u8] | { let msg : BlockWithRefs = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_TRANSACTION_REFS : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.TransactionRefs")] impl :: prost_wkt :: MessageSerde for TransactionRefs { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "TransactionRefs" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.TransactionRefs" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.TransactionRefs" , decoder : | buf : & [u8] | { let msg : TransactionRefs = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_ACTIVATED_PROTOCOL_FEATURES : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.ActivatedProtocolFeatures")] impl :: prost_wkt :: MessageSerde for ActivatedProtocolFeatures { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "ActivatedProtocolFeatures" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.ActivatedProtocolFeatures" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.ActivatedProtocolFeatures" , decoder : | buf : & [u8] | { let msg : ActivatedProtocolFeatures = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_PENDING_PRODUCER_SCHEDULE : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.PendingProducerSchedule")] impl :: prost_wkt :: MessageSerde for PendingProducerSchedule { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "PendingProducerSchedule" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.PendingProducerSchedule" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.PendingProducerSchedule" , decoder : | buf : & [u8] | { let msg : PendingProducerSchedule = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_PRODUCER_SCHEDULE : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.ProducerSchedule")] impl :: prost_wkt :: MessageSerde for ProducerSchedule { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "ProducerSchedule" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.ProducerSchedule" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.ProducerSchedule" , decoder : | buf : & [u8] | { let msg : ProducerSchedule = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_PRODUCER_KEY : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.ProducerKey")] impl :: prost_wkt :: MessageSerde for ProducerKey { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "ProducerKey" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.ProducerKey" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.ProducerKey" , decoder : | buf : & [u8] | { let msg : ProducerKey = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_PRODUCER_AUTHORITY_SCHEDULE : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.ProducerAuthoritySchedule")] impl :: prost_wkt :: MessageSerde for ProducerAuthoritySchedule { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "ProducerAuthoritySchedule" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.ProducerAuthoritySchedule" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.ProducerAuthoritySchedule" , decoder : | buf : & [u8] | { let msg : ProducerAuthoritySchedule = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_PRODUCER_AUTHORITY : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.ProducerAuthority")] impl :: prost_wkt :: MessageSerde for ProducerAuthority { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "ProducerAuthority" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.ProducerAuthority" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.ProducerAuthority" , decoder : | buf : & [u8] | { let msg : ProducerAuthority = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_BLOCK_SIGNING_AUTHORITY : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.BlockSigningAuthority")] impl :: prost_wkt :: MessageSerde for BlockSigningAuthority { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "BlockSigningAuthority" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.BlockSigningAuthority" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.BlockSigningAuthority" , decoder : | buf : & [u8] | { let msg : BlockSigningAuthority = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_BLOCK_SIGNING_AUTHORITY_V0 : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.BlockSigningAuthorityV0")] impl :: prost_wkt :: MessageSerde for BlockSigningAuthorityV0 { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "BlockSigningAuthorityV0" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.BlockSigningAuthorityV0" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.BlockSigningAuthorityV0" , decoder : | buf : & [u8] | { let msg : BlockSigningAuthorityV0 = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_BLOCK_ROOT_MERKLE : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.BlockRootMerkle")] impl :: prost_wkt :: MessageSerde for BlockRootMerkle { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "BlockRootMerkle" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.BlockRootMerkle" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.BlockRootMerkle" , decoder : | buf : & [u8] | { let msg : BlockRootMerkle = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_PRODUCER_TO_LAST_PRODUCED : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.ProducerToLastProduced")] impl :: prost_wkt :: MessageSerde for ProducerToLastProduced { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "ProducerToLastProduced" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.ProducerToLastProduced" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.ProducerToLastProduced" , decoder : | buf : & [u8] | { let msg : ProducerToLastProduced = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_PRODUCER_TO_LAST_IMPLIED_IRB : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.ProducerToLastImpliedIRB")] impl :: prost_wkt :: MessageSerde for ProducerToLastImpliedIrb { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "ProducerToLastImpliedIRB" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.ProducerToLastImpliedIRB" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.ProducerToLastImpliedIRB" , decoder : | buf : & [u8] | { let msg : ProducerToLastImpliedIrb = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_TRANSACTION_RECEIPT : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.TransactionReceipt")] impl :: prost_wkt :: MessageSerde for TransactionReceipt { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "TransactionReceipt" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.TransactionReceipt" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.TransactionReceipt" , decoder : | buf : & [u8] | { let msg : TransactionReceipt = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_PACKED_TRANSACTION : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.PackedTransaction")] impl :: prost_wkt :: MessageSerde for PackedTransaction { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "PackedTransaction" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.PackedTransaction" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.PackedTransaction" , decoder : | buf : & [u8] | { let msg : PackedTransaction = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_BLOCK_HEADER : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.BlockHeader")] impl :: prost_wkt :: MessageSerde for BlockHeader { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "BlockHeader" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.BlockHeader" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.BlockHeader" , decoder : | buf : & [u8] | { let msg : BlockHeader = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_TRANSACTION_EVENT : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.TransactionEvent")] impl :: prost_wkt :: MessageSerde for TransactionEvent { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "TransactionEvent" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.TransactionEvent" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.TransactionEvent" , decoder : | buf : & [u8] | { let msg : TransactionEvent = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_PUBLIC_KEYS : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.PublicKeys")] impl :: prost_wkt :: MessageSerde for PublicKeys { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "PublicKeys" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.PublicKeys" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.PublicKeys" , decoder : | buf : & [u8] | { let msg : PublicKeys = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_TRANSACTION_LIFECYCLE : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.TransactionLifecycle")] impl :: prost_wkt :: MessageSerde for TransactionLifecycle { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "TransactionLifecycle" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.TransactionLifecycle" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.TransactionLifecycle" , decoder : | buf : & [u8] | { let msg : TransactionLifecycle = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_SIGNED_TRANSACTION : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.SignedTransaction")] impl :: prost_wkt :: MessageSerde for SignedTransaction { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "SignedTransaction" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.SignedTransaction" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.SignedTransaction" , decoder : | buf : & [u8] | { let msg : SignedTransaction = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_TRANSACTION : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.Transaction")] impl :: prost_wkt :: MessageSerde for Transaction { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "Transaction" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.Transaction" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.Transaction" , decoder : | buf : & [u8] | { let msg : Transaction = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_TRANSACTION_HEADER : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.TransactionHeader")] impl :: prost_wkt :: MessageSerde for TransactionHeader { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "TransactionHeader" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.TransactionHeader" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.TransactionHeader" , decoder : | buf : & [u8] | { let msg : TransactionHeader = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_TRANSACTION_TRACE : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.TransactionTrace")] impl :: prost_wkt :: MessageSerde for TransactionTrace { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "TransactionTrace" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.TransactionTrace" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.TransactionTrace" , decoder : | buf : & [u8] | { let msg : TransactionTrace = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_TRANSACTION_RECEIPT_HEADER : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.TransactionReceiptHeader")] impl :: prost_wkt :: MessageSerde for TransactionReceiptHeader { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "TransactionReceiptHeader" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.TransactionReceiptHeader" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.TransactionReceiptHeader" , decoder : | buf : & [u8] | { let msg : TransactionReceiptHeader = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_ACTION : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.Action")] impl :: prost_wkt :: MessageSerde for Action { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "Action" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.Action" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.Action" , decoder : | buf : & [u8] | { let msg : Action = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_ACTION_TRACE : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.ActionTrace")] impl :: prost_wkt :: MessageSerde for ActionTrace { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "ActionTrace" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.ActionTrace" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.ActionTrace" , decoder : | buf : & [u8] | { let msg : ActionTrace = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_ACTION_RECEIPT : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.ActionReceipt")] impl :: prost_wkt :: MessageSerde for ActionReceipt { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "ActionReceipt" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.ActionReceipt" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.ActionReceipt" , decoder : | buf : & [u8] | { let msg : ActionReceipt = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_AUTH_SEQUENCE : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.AuthSequence")] impl :: prost_wkt :: MessageSerde for AuthSequence { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "AuthSequence" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.AuthSequence" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.AuthSequence" , decoder : | buf : & [u8] | { let msg : AuthSequence = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_ACCOUNT_RAM_DELTA : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.AccountRAMDelta")] impl :: prost_wkt :: MessageSerde for AccountRamDelta { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "AccountRAMDelta" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.AccountRAMDelta" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.AccountRAMDelta" , decoder : | buf : & [u8] | { let msg : AccountRamDelta = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_ACCOUNT_DELTA : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.AccountDelta")] impl :: prost_wkt :: MessageSerde for AccountDelta { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "AccountDelta" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.AccountDelta" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.AccountDelta" , decoder : | buf : & [u8] | { let msg : AccountDelta = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_EXTENSION : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.Extension")] impl :: prost_wkt :: MessageSerde for Extension { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "Extension" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.Extension" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.Extension" , decoder : | buf : & [u8] | { let msg : Extension = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_TRX_OP : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.TrxOp")] impl :: prost_wkt :: MessageSerde for TrxOp { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "TrxOp" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.TrxOp" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.TrxOp" , decoder : | buf : & [u8] | { let msg : TrxOp = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_DB_OP : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.DBOp")] impl :: prost_wkt :: MessageSerde for DbOp { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "DBOp" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.DBOp" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.DBOp" , decoder : | buf : & [u8] | { let msg : DbOp = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_RAM_OP : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.RAMOp")] impl :: prost_wkt :: MessageSerde for RamOp { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "RAMOp" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.RAMOp" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.RAMOp" , decoder : | buf : & [u8] | { let msg : RamOp = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_RAM_CORRECTION_OP : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.RAMCorrectionOp")] impl :: prost_wkt :: MessageSerde for RamCorrectionOp { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "RAMCorrectionOp" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.RAMCorrectionOp" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.RAMCorrectionOp" , decoder : | buf : & [u8] | { let msg : RamCorrectionOp = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_TABLE_OP : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.TableOp")] impl :: prost_wkt :: MessageSerde for TableOp { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "TableOp" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.TableOp" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.TableOp" , decoder : | buf : & [u8] | { let msg : TableOp = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_D_TRX_OP : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.DTrxOp")] impl :: prost_wkt :: MessageSerde for DTrxOp { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "DTrxOp" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.DTrxOp" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.DTrxOp" , decoder : | buf : & [u8] | { let msg : DTrxOp = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_EXT_D_TRX_OP : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.ExtDTrxOp")] impl :: prost_wkt :: MessageSerde for ExtDTrxOp { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "ExtDTrxOp" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.ExtDTrxOp" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.ExtDTrxOp" , decoder : | buf : & [u8] | { let msg : ExtDTrxOp = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_FEATURE_OP : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.FeatureOp")] impl :: prost_wkt :: MessageSerde for FeatureOp { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "FeatureOp" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.FeatureOp" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.FeatureOp" , decoder : | buf : & [u8] | { let msg : FeatureOp = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_CREATION_FLAT_NODE : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.CreationFlatNode")] impl :: prost_wkt :: MessageSerde for CreationFlatNode { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "CreationFlatNode" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.CreationFlatNode" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.CreationFlatNode" , decoder : | buf : & [u8] | { let msg : CreationFlatNode = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_PERM_OP : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.PermOp")] impl :: prost_wkt :: MessageSerde for PermOp { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "PermOp" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.PermOp" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.PermOp" , decoder : | buf : & [u8] | { let msg : PermOp = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_PERMISSION_OBJECT : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.PermissionObject")] impl :: prost_wkt :: MessageSerde for PermissionObject { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "PermissionObject" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.PermissionObject" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.PermissionObject" , decoder : | buf : & [u8] | { let msg : PermissionObject = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_PERMISSION : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.Permission")] impl :: prost_wkt :: MessageSerde for Permission { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "Permission" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.Permission" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.Permission" , decoder : | buf : & [u8] | { let msg : Permission = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_AUTHORITY : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.Authority")] impl :: prost_wkt :: MessageSerde for Authority { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "Authority" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.Authority" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.Authority" , decoder : | buf : & [u8] | { let msg : Authority = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_KEY_WEIGHT : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.KeyWeight")] impl :: prost_wkt :: MessageSerde for KeyWeight { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "KeyWeight" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.KeyWeight" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.KeyWeight" , decoder : | buf : & [u8] | { let msg : KeyWeight = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_PERMISSION_LEVEL : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.PermissionLevel")] impl :: prost_wkt :: MessageSerde for PermissionLevel { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "PermissionLevel" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.PermissionLevel" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.PermissionLevel" , decoder : | buf : & [u8] | { let msg : PermissionLevel = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_PERMISSION_LEVEL_WEIGHT : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.PermissionLevelWeight")] impl :: prost_wkt :: MessageSerde for PermissionLevelWeight { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "PermissionLevelWeight" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.PermissionLevelWeight" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.PermissionLevelWeight" , decoder : | buf : & [u8] | { let msg : PermissionLevelWeight = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_WAIT_WEIGHT : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.WaitWeight")] impl :: prost_wkt :: MessageSerde for WaitWeight { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "WaitWeight" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.WaitWeight" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.WaitWeight" , decoder : | buf : & [u8] | { let msg : WaitWeight = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_RLIMIT_OP : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.RlimitOp")] impl :: prost_wkt :: MessageSerde for RlimitOp { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "RlimitOp" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.RlimitOp" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.RlimitOp" , decoder : | buf : & [u8] | { let msg : RlimitOp = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_RLIMIT_STATE : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.RlimitState")] impl :: prost_wkt :: MessageSerde for RlimitState { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "RlimitState" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.RlimitState" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.RlimitState" , decoder : | buf : & [u8] | { let msg : RlimitState = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_RLIMIT_CONFIG : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.RlimitConfig")] impl :: prost_wkt :: MessageSerde for RlimitConfig { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "RlimitConfig" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.RlimitConfig" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.RlimitConfig" , decoder : | buf : & [u8] | { let msg : RlimitConfig = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_RLIMIT_ACCOUNT_LIMITS : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.RlimitAccountLimits")] impl :: prost_wkt :: MessageSerde for RlimitAccountLimits { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "RlimitAccountLimits" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.RlimitAccountLimits" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.RlimitAccountLimits" , decoder : | buf : & [u8] | { let msg : RlimitAccountLimits = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_RLIMIT_ACCOUNT_USAGE : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.RlimitAccountUsage")] impl :: prost_wkt :: MessageSerde for RlimitAccountUsage { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "RlimitAccountUsage" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.RlimitAccountUsage" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.RlimitAccountUsage" , decoder : | buf : & [u8] | { let msg : RlimitAccountUsage = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_USAGE_ACCUMULATOR : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.UsageAccumulator")] impl :: prost_wkt :: MessageSerde for UsageAccumulator { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "UsageAccumulator" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.UsageAccumulator" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.UsageAccumulator" , decoder : | buf : & [u8] | { let msg : UsageAccumulator = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_ELASTIC_LIMIT_PARAMETERS : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.ElasticLimitParameters")] impl :: prost_wkt :: MessageSerde for ElasticLimitParameters { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "ElasticLimitParameters" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.ElasticLimitParameters" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.ElasticLimitParameters" , decoder : | buf : & [u8] | { let msg : ElasticLimitParameters = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_RATIO : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.Ratio")] impl :: prost_wkt :: MessageSerde for Ratio { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "Ratio" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.Ratio" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.Ratio" , decoder : | buf : & [u8] | { let msg : Ratio = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_EXCEPTION : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.Exception")] impl :: prost_wkt :: MessageSerde for Exception { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "Exception" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.Exception" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.Exception" , decoder : | buf : & [u8] | { let msg : Exception = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_FEATURE : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.Feature")] impl :: prost_wkt :: MessageSerde for Feature { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "Feature" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.Feature" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.Feature" , decoder : | buf : & [u8] | { let msg : Feature = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_SUBJECTIVE_RESTRICTIONS : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.SubjectiveRestrictions")] impl :: prost_wkt :: MessageSerde for SubjectiveRestrictions { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "SubjectiveRestrictions" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.SubjectiveRestrictions" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.SubjectiveRestrictions" , decoder : | buf : & [u8] | { let msg : SubjectiveRestrictions = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_SPECIFICATION : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.Specification")] impl :: prost_wkt :: MessageSerde for Specification { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "Specification" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.Specification" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.Specification" , decoder : | buf : & [u8] | { let msg : Specification = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_ACCOUNT_CREATION_REF : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.AccountCreationRef")] impl :: prost_wkt :: MessageSerde for AccountCreationRef { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "AccountCreationRef" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.AccountCreationRef" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.AccountCreationRef" , decoder : | buf : & [u8] | { let msg : AccountCreationRef = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_HEADER_ONLY_BLOCK : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.HeaderOnlyBlock")] impl :: prost_wkt :: MessageSerde for HeaderOnlyBlock { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "HeaderOnlyBlock" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.HeaderOnlyBlock" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.HeaderOnlyBlock" , decoder : | buf : & [u8] | { let msg : HeaderOnlyBlock = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_TRANSACTION_TRACE_WITH_BLOCK_REF : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.TransactionTraceWithBlockRef")] impl :: prost_wkt :: MessageSerde for TransactionTraceWithBlockRef { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "TransactionTraceWithBlockRef" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.TransactionTraceWithBlockRef" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.TransactionTraceWithBlockRef" , decoder : | buf : & [u8] | { let msg : TransactionTraceWithBlockRef = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_BLOCK_REF : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.BlockRef")] impl :: prost_wkt :: MessageSerde for BlockRef { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "BlockRef" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.BlockRef" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.BlockRef" , decoder : | buf : & [u8] | { let msg : BlockRef = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_ACTION_TRACES : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.ActionTraces")] impl :: prost_wkt :: MessageSerde for ActionTraces { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "ActionTraces" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.ActionTraces" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.ActionTraces" , decoder : | buf : & [u8] | { let msg : ActionTraces = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_TRANSACTION_TRACES : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.TransactionTraces")] impl :: prost_wkt :: MessageSerde for TransactionTraces { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "TransactionTraces" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.TransactionTraces" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.TransactionTraces" , decoder : | buf : & [u8] | { let msg : TransactionTraces = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_DB_OPS : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.DBOps")] impl :: prost_wkt :: MessageSerde for DbOps { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "DBOps" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.DBOps" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.DBOps" , decoder : | buf : & [u8] | { let msg : DbOps = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_BLOCK : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.Block")] impl :: prost_wkt :: MessageSerde for Block { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "Block" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.Block" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.Block" , decoder : | buf : & [u8] | { let msg : Block = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_BLOCK_WITH_REFS : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.BlockWithRefs")] impl :: prost_wkt :: MessageSerde for BlockWithRefs { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "BlockWithRefs" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.BlockWithRefs" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.BlockWithRefs" , decoder : | buf : & [u8] | { let msg : BlockWithRefs = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_TRANSACTION_REFS : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.TransactionRefs")] impl :: prost_wkt :: MessageSerde for TransactionRefs { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "TransactionRefs" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.TransactionRefs" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.TransactionRefs" , decoder : | buf : & [u8] | { let msg : TransactionRefs = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_ACTIVATED_PROTOCOL_FEATURES : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.ActivatedProtocolFeatures")] impl :: prost_wkt :: MessageSerde for ActivatedProtocolFeatures { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "ActivatedProtocolFeatures" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.ActivatedProtocolFeatures" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.ActivatedProtocolFeatures" , decoder : | buf : & [u8] | { let msg : ActivatedProtocolFeatures = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_PENDING_PRODUCER_SCHEDULE : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.PendingProducerSchedule")] impl :: prost_wkt :: MessageSerde for PendingProducerSchedule { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "PendingProducerSchedule" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.PendingProducerSchedule" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.PendingProducerSchedule" , decoder : | buf : & [u8] | { let msg : PendingProducerSchedule = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_PRODUCER_SCHEDULE : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.ProducerSchedule")] impl :: prost_wkt :: MessageSerde for ProducerSchedule { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "ProducerSchedule" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.ProducerSchedule" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.ProducerSchedule" , decoder : | buf : & [u8] | { let msg : ProducerSchedule = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_PRODUCER_KEY : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.ProducerKey")] impl :: prost_wkt :: MessageSerde for ProducerKey { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "ProducerKey" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.ProducerKey" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.ProducerKey" , decoder : | buf : & [u8] | { let msg : ProducerKey = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_PRODUCER_AUTHORITY_SCHEDULE : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.ProducerAuthoritySchedule")] impl :: prost_wkt :: MessageSerde for ProducerAuthoritySchedule { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "ProducerAuthoritySchedule" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.ProducerAuthoritySchedule" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.ProducerAuthoritySchedule" , decoder : | buf : & [u8] | { let msg : ProducerAuthoritySchedule = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_PRODUCER_AUTHORITY : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.ProducerAuthority")] impl :: prost_wkt :: MessageSerde for ProducerAuthority { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "ProducerAuthority" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.ProducerAuthority" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.ProducerAuthority" , decoder : | buf : & [u8] | { let msg : ProducerAuthority = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_BLOCK_SIGNING_AUTHORITY : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.BlockSigningAuthority")] impl :: prost_wkt :: MessageSerde for BlockSigningAuthority { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "BlockSigningAuthority" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.BlockSigningAuthority" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.BlockSigningAuthority" , decoder : | buf : & [u8] | { let msg : BlockSigningAuthority = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_BLOCK_SIGNING_AUTHORITY_V0 : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.BlockSigningAuthorityV0")] impl :: prost_wkt :: MessageSerde for BlockSigningAuthorityV0 { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "BlockSigningAuthorityV0" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.BlockSigningAuthorityV0" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.BlockSigningAuthorityV0" , decoder : | buf : & [u8] | { let msg : BlockSigningAuthorityV0 = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_BLOCK_ROOT_MERKLE : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.BlockRootMerkle")] impl :: prost_wkt :: MessageSerde for BlockRootMerkle { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "BlockRootMerkle" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.BlockRootMerkle" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.BlockRootMerkle" , decoder : | buf : & [u8] | { let msg : BlockRootMerkle = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_PRODUCER_TO_LAST_PRODUCED : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.ProducerToLastProduced")] impl :: prost_wkt :: MessageSerde for ProducerToLastProduced { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "ProducerToLastProduced" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.ProducerToLastProduced" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.ProducerToLastProduced" , decoder : | buf : & [u8] | { let msg : ProducerToLastProduced = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_PRODUCER_TO_LAST_IMPLIED_IRB : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.ProducerToLastImpliedIRB")] impl :: prost_wkt :: MessageSerde for ProducerToLastImpliedIrb { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "ProducerToLastImpliedIRB" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.ProducerToLastImpliedIRB" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.ProducerToLastImpliedIRB" , decoder : | buf : & [u8] | { let msg : ProducerToLastImpliedIrb = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_TRANSACTION_RECEIPT : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.TransactionReceipt")] impl :: prost_wkt :: MessageSerde for TransactionReceipt { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "TransactionReceipt" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.TransactionReceipt" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.TransactionReceipt" , decoder : | buf : & [u8] | { let msg : TransactionReceipt = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_PACKED_TRANSACTION : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.PackedTransaction")] impl :: prost_wkt :: MessageSerde for PackedTransaction { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "PackedTransaction" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.PackedTransaction" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.PackedTransaction" , decoder : | buf : & [u8] | { let msg : PackedTransaction = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_BLOCK_HEADER : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.BlockHeader")] impl :: prost_wkt :: MessageSerde for BlockHeader { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "BlockHeader" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.BlockHeader" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.BlockHeader" , decoder : | buf : & [u8] | { let msg : BlockHeader = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_TRANSACTION_EVENT : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.TransactionEvent")] impl :: prost_wkt :: MessageSerde for TransactionEvent { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "TransactionEvent" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.TransactionEvent" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.TransactionEvent" , decoder : | buf : & [u8] | { let msg : TransactionEvent = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_PUBLIC_KEYS : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.PublicKeys")] impl :: prost_wkt :: MessageSerde for PublicKeys { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "PublicKeys" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.PublicKeys" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.PublicKeys" , decoder : | buf : & [u8] | { let msg : PublicKeys = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_TRANSACTION_LIFECYCLE : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.TransactionLifecycle")] impl :: prost_wkt :: MessageSerde for TransactionLifecycle { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "TransactionLifecycle" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.TransactionLifecycle" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.TransactionLifecycle" , decoder : | buf : & [u8] | { let msg : TransactionLifecycle = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_SIGNED_TRANSACTION : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.SignedTransaction")] impl :: prost_wkt :: MessageSerde for SignedTransaction { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "SignedTransaction" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.SignedTransaction" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.SignedTransaction" , decoder : | buf : & [u8] | { let msg : SignedTransaction = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_TRANSACTION : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.Transaction")] impl :: prost_wkt :: MessageSerde for Transaction { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "Transaction" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.Transaction" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.Transaction" , decoder : | buf : & [u8] | { let msg : Transaction = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_TRANSACTION_HEADER : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.TransactionHeader")] impl :: prost_wkt :: MessageSerde for TransactionHeader { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "TransactionHeader" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.TransactionHeader" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.TransactionHeader" , decoder : | buf : & [u8] | { let msg : TransactionHeader = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_TRANSACTION_TRACE : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.TransactionTrace")] impl :: prost_wkt :: MessageSerde for TransactionTrace { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "TransactionTrace" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.TransactionTrace" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.TransactionTrace" , decoder : | buf : & [u8] | { let msg : TransactionTrace = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_TRANSACTION_RECEIPT_HEADER : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.TransactionReceiptHeader")] impl :: prost_wkt :: MessageSerde for TransactionReceiptHeader { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "TransactionReceiptHeader" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.TransactionReceiptHeader" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.TransactionReceiptHeader" , decoder : | buf : & [u8] | { let msg : TransactionReceiptHeader = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_ACTION : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.Action")] impl :: prost_wkt :: MessageSerde for Action { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "Action" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.Action" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.Action" , decoder : | buf : & [u8] | { let msg : Action = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_ACTION_TRACE : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.ActionTrace")] impl :: prost_wkt :: MessageSerde for ActionTrace { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "ActionTrace" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.ActionTrace" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.ActionTrace" , decoder : | buf : & [u8] | { let msg : ActionTrace = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_ACTION_RECEIPT : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.ActionReceipt")] impl :: prost_wkt :: MessageSerde for ActionReceipt { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "ActionReceipt" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.ActionReceipt" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.ActionReceipt" , decoder : | buf : & [u8] | { let msg : ActionReceipt = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_AUTH_SEQUENCE : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.AuthSequence")] impl :: prost_wkt :: MessageSerde for AuthSequence { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "AuthSequence" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.AuthSequence" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.AuthSequence" , decoder : | buf : & [u8] | { let msg : AuthSequence = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_ACCOUNT_RAM_DELTA : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.AccountRAMDelta")] impl :: prost_wkt :: MessageSerde for AccountRamDelta { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "AccountRAMDelta" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.AccountRAMDelta" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.AccountRAMDelta" , decoder : | buf : & [u8] | { let msg : AccountRamDelta = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_ACCOUNT_DELTA : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.AccountDelta")] impl :: prost_wkt :: MessageSerde for AccountDelta { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "AccountDelta" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.AccountDelta" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.AccountDelta" , decoder : | buf : & [u8] | { let msg : AccountDelta = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_EXTENSION : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.Extension")] impl :: prost_wkt :: MessageSerde for Extension { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "Extension" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.Extension" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.Extension" , decoder : | buf : & [u8] | { let msg : Extension = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_TRX_OP : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.TrxOp")] impl :: prost_wkt :: MessageSerde for TrxOp { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "TrxOp" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.TrxOp" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.TrxOp" , decoder : | buf : & [u8] | { let msg : TrxOp = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_DB_OP : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.DBOp")] impl :: prost_wkt :: MessageSerde for DbOp { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "DBOp" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.DBOp" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.DBOp" , decoder : | buf : & [u8] | { let msg : DbOp = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_RAM_OP : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.RAMOp")] impl :: prost_wkt :: MessageSerde for RamOp { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "RAMOp" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.RAMOp" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.RAMOp" , decoder : | buf : & [u8] | { let msg : RamOp = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_RAM_CORRECTION_OP : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.RAMCorrectionOp")] impl :: prost_wkt :: MessageSerde for RamCorrectionOp { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "RAMCorrectionOp" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.RAMCorrectionOp" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.RAMCorrectionOp" , decoder : | buf : & [u8] | { let msg : RamCorrectionOp = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_TABLE_OP : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.TableOp")] impl :: prost_wkt :: MessageSerde for TableOp { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "TableOp" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.TableOp" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.TableOp" , decoder : | buf : & [u8] | { let msg : TableOp = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_D_TRX_OP : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.DTrxOp")] impl :: prost_wkt :: MessageSerde for DTrxOp { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "DTrxOp" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.DTrxOp" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.DTrxOp" , decoder : | buf : & [u8] | { let msg : DTrxOp = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_EXT_D_TRX_OP : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.ExtDTrxOp")] impl :: prost_wkt :: MessageSerde for ExtDTrxOp { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "ExtDTrxOp" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.ExtDTrxOp" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.ExtDTrxOp" , decoder : | buf : & [u8] | { let msg : ExtDTrxOp = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_FEATURE_OP : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.FeatureOp")] impl :: prost_wkt :: MessageSerde for FeatureOp { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "FeatureOp" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.FeatureOp" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.FeatureOp" , decoder : | buf : & [u8] | { let msg : FeatureOp = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_CREATION_FLAT_NODE : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.CreationFlatNode")] impl :: prost_wkt :: MessageSerde for CreationFlatNode { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "CreationFlatNode" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.CreationFlatNode" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.CreationFlatNode" , decoder : | buf : & [u8] | { let msg : CreationFlatNode = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_PERM_OP : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.PermOp")] impl :: prost_wkt :: MessageSerde for PermOp { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "PermOp" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.PermOp" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.PermOp" , decoder : | buf : & [u8] | { let msg : PermOp = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_PERMISSION_OBJECT : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.PermissionObject")] impl :: prost_wkt :: MessageSerde for PermissionObject { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "PermissionObject" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.PermissionObject" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.PermissionObject" , decoder : | buf : & [u8] | { let msg : PermissionObject = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_PERMISSION : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.Permission")] impl :: prost_wkt :: MessageSerde for Permission { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "Permission" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.Permission" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.Permission" , decoder : | buf : & [u8] | { let msg : Permission = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_AUTHORITY : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.Authority")] impl :: prost_wkt :: MessageSerde for Authority { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "Authority" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.Authority" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.Authority" , decoder : | buf : & [u8] | { let msg : Authority = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_KEY_WEIGHT : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.KeyWeight")] impl :: prost_wkt :: MessageSerde for KeyWeight { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "KeyWeight" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.KeyWeight" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.KeyWeight" , decoder : | buf : & [u8] | { let msg : KeyWeight = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_PERMISSION_LEVEL : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.PermissionLevel")] impl :: prost_wkt :: MessageSerde for PermissionLevel { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "PermissionLevel" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.PermissionLevel" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.PermissionLevel" , decoder : | buf : & [u8] | { let msg : PermissionLevel = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_PERMISSION_LEVEL_WEIGHT : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.PermissionLevelWeight")] impl :: prost_wkt :: MessageSerde for PermissionLevelWeight { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "PermissionLevelWeight" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.PermissionLevelWeight" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.PermissionLevelWeight" , decoder : | buf : & [u8] | { let msg : PermissionLevelWeight = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_WAIT_WEIGHT : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.WaitWeight")] impl :: prost_wkt :: MessageSerde for WaitWeight { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "WaitWeight" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.WaitWeight" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.WaitWeight" , decoder : | buf : & [u8] | { let msg : WaitWeight = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_RLIMIT_OP : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.RlimitOp")] impl :: prost_wkt :: MessageSerde for RlimitOp { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "RlimitOp" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.RlimitOp" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.RlimitOp" , decoder : | buf : & [u8] | { let msg : RlimitOp = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_RLIMIT_STATE : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.RlimitState")] impl :: prost_wkt :: MessageSerde for RlimitState { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "RlimitState" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.RlimitState" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.RlimitState" , decoder : | buf : & [u8] | { let msg : RlimitState = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_RLIMIT_CONFIG : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.RlimitConfig")] impl :: prost_wkt :: MessageSerde for RlimitConfig { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "RlimitConfig" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.RlimitConfig" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.RlimitConfig" , decoder : | buf : & [u8] | { let msg : RlimitConfig = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_RLIMIT_ACCOUNT_LIMITS : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.RlimitAccountLimits")] impl :: prost_wkt :: MessageSerde for RlimitAccountLimits { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "RlimitAccountLimits" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.RlimitAccountLimits" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.RlimitAccountLimits" , decoder : | buf : & [u8] | { let msg : RlimitAccountLimits = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_RLIMIT_ACCOUNT_USAGE : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.RlimitAccountUsage")] impl :: prost_wkt :: MessageSerde for RlimitAccountUsage { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "RlimitAccountUsage" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.RlimitAccountUsage" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.RlimitAccountUsage" , decoder : | buf : & [u8] | { let msg : RlimitAccountUsage = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_USAGE_ACCUMULATOR : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.UsageAccumulator")] impl :: prost_wkt :: MessageSerde for UsageAccumulator { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "UsageAccumulator" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.UsageAccumulator" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.UsageAccumulator" , decoder : | buf : & [u8] | { let msg : UsageAccumulator = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_ELASTIC_LIMIT_PARAMETERS : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.ElasticLimitParameters")] impl :: prost_wkt :: MessageSerde for ElasticLimitParameters { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "ElasticLimitParameters" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.ElasticLimitParameters" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.ElasticLimitParameters" , decoder : | buf : & [u8] | { let msg : ElasticLimitParameters = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_RATIO : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.Ratio")] impl :: prost_wkt :: MessageSerde for Ratio { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "Ratio" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.Ratio" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.Ratio" , decoder : | buf : & [u8] | { let msg : Ratio = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_EXCEPTION : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.Exception")] impl :: prost_wkt :: MessageSerde for Exception { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "Exception" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.Exception" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.Exception" , decoder : | buf : & [u8] | { let msg : Exception = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_FEATURE : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.Feature")] impl :: prost_wkt :: MessageSerde for Feature { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "Feature" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.Feature" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.Feature" , decoder : | buf : & [u8] | { let msg : Feature = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_SUBJECTIVE_RESTRICTIONS : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.SubjectiveRestrictions")] impl :: prost_wkt :: MessageSerde for SubjectiveRestrictions { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "SubjectiveRestrictions" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.SubjectiveRestrictions" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.SubjectiveRestrictions" , decoder : | buf : & [u8] | { let msg : SubjectiveRestrictions = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_SPECIFICATION : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.Specification")] impl :: prost_wkt :: MessageSerde for Specification { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "Specification" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.Specification" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.Specification" , decoder : | buf : & [u8] | { let msg : Specification = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_ACCOUNT_CREATION_REF : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.AccountCreationRef")] impl :: prost_wkt :: MessageSerde for AccountCreationRef { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "AccountCreationRef" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.AccountCreationRef" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.AccountCreationRef" , decoder : | buf : & [u8] | { let msg : AccountCreationRef = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_HEADER_ONLY_BLOCK : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.HeaderOnlyBlock")] impl :: prost_wkt :: MessageSerde for HeaderOnlyBlock { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "HeaderOnlyBlock" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.HeaderOnlyBlock" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.HeaderOnlyBlock" , decoder : | buf : & [u8] | { let msg : HeaderOnlyBlock = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_TRANSACTION_TRACE_WITH_BLOCK_REF : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.TransactionTraceWithBlockRef")] impl :: prost_wkt :: MessageSerde for TransactionTraceWithBlockRef { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "TransactionTraceWithBlockRef" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.TransactionTraceWithBlockRef" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.TransactionTraceWithBlockRef" , decoder : | buf : & [u8] | { let msg : TransactionTraceWithBlockRef = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_BLOCK_REF : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.BlockRef")] impl :: prost_wkt :: MessageSerde for BlockRef { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "BlockRef" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.BlockRef" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.BlockRef" , decoder : | buf : & [u8] | { let msg : BlockRef = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_ACTION_TRACES : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.ActionTraces")] impl :: prost_wkt :: MessageSerde for ActionTraces { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "ActionTraces" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.ActionTraces" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.ActionTraces" , decoder : | buf : & [u8] | { let msg : ActionTraces = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_TRANSACTION_TRACES : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.TransactionTraces")] impl :: prost_wkt :: MessageSerde for TransactionTraces { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "TransactionTraces" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.TransactionTraces" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.TransactionTraces" , decoder : | buf : & [u8] | { let msg : TransactionTraces = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_DB_OPS : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.DBOps")] impl :: prost_wkt :: MessageSerde for DbOps { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "DBOps" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.DBOps" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.DBOps" , decoder : | buf : & [u8] | { let msg : DbOps = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_BLOCK : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.Block")] impl :: prost_wkt :: MessageSerde for Block { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "Block" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.Block" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.Block" , decoder : | buf : & [u8] | { let msg : Block = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_BLOCK_WITH_REFS : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.BlockWithRefs")] impl :: prost_wkt :: MessageSerde for BlockWithRefs { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "BlockWithRefs" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.BlockWithRefs" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.BlockWithRefs" , decoder : | buf : & [u8] | { let msg : BlockWithRefs = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_TRANSACTION_REFS : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.TransactionRefs")] impl :: prost_wkt :: MessageSerde for TransactionRefs { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "TransactionRefs" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.TransactionRefs" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.TransactionRefs" , decoder : | buf : & [u8] | { let msg : TransactionRefs = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_ACTIVATED_PROTOCOL_FEATURES : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.ActivatedProtocolFeatures")] impl :: prost_wkt :: MessageSerde for ActivatedProtocolFeatures { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "ActivatedProtocolFeatures" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.ActivatedProtocolFeatures" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.ActivatedProtocolFeatures" , decoder : | buf : & [u8] | { let msg : ActivatedProtocolFeatures = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_PENDING_PRODUCER_SCHEDULE : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.PendingProducerSchedule")] impl :: prost_wkt :: MessageSerde for PendingProducerSchedule { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "PendingProducerSchedule" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.PendingProducerSchedule" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.PendingProducerSchedule" , decoder : | buf : & [u8] | { let msg : PendingProducerSchedule = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_PRODUCER_SCHEDULE : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.ProducerSchedule")] impl :: prost_wkt :: MessageSerde for ProducerSchedule { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "ProducerSchedule" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.ProducerSchedule" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.ProducerSchedule" , decoder : | buf : & [u8] | { let msg : ProducerSchedule = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_PRODUCER_KEY : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.ProducerKey")] impl :: prost_wkt :: MessageSerde for ProducerKey { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "ProducerKey" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.ProducerKey" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.ProducerKey" , decoder : | buf : & [u8] | { let msg : ProducerKey = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_PRODUCER_AUTHORITY_SCHEDULE : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.ProducerAuthoritySchedule")] impl :: prost_wkt :: MessageSerde for ProducerAuthoritySchedule { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "ProducerAuthoritySchedule" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.ProducerAuthoritySchedule" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.ProducerAuthoritySchedule" , decoder : | buf : & [u8] | { let msg : ProducerAuthoritySchedule = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_PRODUCER_AUTHORITY : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.ProducerAuthority")] impl :: prost_wkt :: MessageSerde for ProducerAuthority { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "ProducerAuthority" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.ProducerAuthority" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.ProducerAuthority" , decoder : | buf : & [u8] | { let msg : ProducerAuthority = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_BLOCK_SIGNING_AUTHORITY : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.BlockSigningAuthority")] impl :: prost_wkt :: MessageSerde for BlockSigningAuthority { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "BlockSigningAuthority" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.BlockSigningAuthority" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.BlockSigningAuthority" , decoder : | buf : & [u8] | { let msg : BlockSigningAuthority = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_BLOCK_SIGNING_AUTHORITY_V0 : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.BlockSigningAuthorityV0")] impl :: prost_wkt :: MessageSerde for BlockSigningAuthorityV0 { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "BlockSigningAuthorityV0" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.BlockSigningAuthorityV0" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.BlockSigningAuthorityV0" , decoder : | buf : & [u8] | { let msg : BlockSigningAuthorityV0 = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_BLOCK_ROOT_MERKLE : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.BlockRootMerkle")] impl :: prost_wkt :: MessageSerde for BlockRootMerkle { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "BlockRootMerkle" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.BlockRootMerkle" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.BlockRootMerkle" , decoder : | buf : & [u8] | { let msg : BlockRootMerkle = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_PRODUCER_TO_LAST_PRODUCED : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.ProducerToLastProduced")] impl :: prost_wkt :: MessageSerde for ProducerToLastProduced { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "ProducerToLastProduced" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.ProducerToLastProduced" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.ProducerToLastProduced" , decoder : | buf : & [u8] | { let msg : ProducerToLastProduced = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_PRODUCER_TO_LAST_IMPLIED_IRB : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.ProducerToLastImpliedIRB")] impl :: prost_wkt :: MessageSerde for ProducerToLastImpliedIrb { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "ProducerToLastImpliedIRB" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.ProducerToLastImpliedIRB" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.ProducerToLastImpliedIRB" , decoder : | buf : & [u8] | { let msg : ProducerToLastImpliedIrb = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_TRANSACTION_RECEIPT : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.TransactionReceipt")] impl :: prost_wkt :: MessageSerde for TransactionReceipt { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "TransactionReceipt" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.TransactionReceipt" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.TransactionReceipt" , decoder : | buf : & [u8] | { let msg : TransactionReceipt = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_PACKED_TRANSACTION : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.PackedTransaction")] impl :: prost_wkt :: MessageSerde for PackedTransaction { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "PackedTransaction" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.PackedTransaction" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.PackedTransaction" , decoder : | buf : & [u8] | { let msg : PackedTransaction = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_BLOCK_HEADER : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.BlockHeader")] impl :: prost_wkt :: MessageSerde for BlockHeader { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "BlockHeader" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.BlockHeader" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.BlockHeader" , decoder : | buf : & [u8] | { let msg : BlockHeader = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_TRANSACTION_EVENT : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.TransactionEvent")] impl :: prost_wkt :: MessageSerde for TransactionEvent { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "TransactionEvent" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.TransactionEvent" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.TransactionEvent" , decoder : | buf : & [u8] | { let msg : TransactionEvent = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_PUBLIC_KEYS : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.PublicKeys")] impl :: prost_wkt :: MessageSerde for PublicKeys { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "PublicKeys" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.PublicKeys" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.PublicKeys" , decoder : | buf : & [u8] | { let msg : PublicKeys = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_TRANSACTION_LIFECYCLE : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.TransactionLifecycle")] impl :: prost_wkt :: MessageSerde for TransactionLifecycle { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "TransactionLifecycle" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.TransactionLifecycle" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.TransactionLifecycle" , decoder : | buf : & [u8] | { let msg : TransactionLifecycle = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_SIGNED_TRANSACTION : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.SignedTransaction")] impl :: prost_wkt :: MessageSerde for SignedTransaction { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "SignedTransaction" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.SignedTransaction" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.SignedTransaction" , decoder : | buf : & [u8] | { let msg : SignedTransaction = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_TRANSACTION : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.Transaction")] impl :: prost_wkt :: MessageSerde for Transaction { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "Transaction" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.Transaction" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.Transaction" , decoder : | buf : & [u8] | { let msg : Transaction = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_TRANSACTION_HEADER : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.TransactionHeader")] impl :: prost_wkt :: MessageSerde for TransactionHeader { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "TransactionHeader" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.TransactionHeader" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.TransactionHeader" , decoder : | buf : & [u8] | { let msg : TransactionHeader = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_TRANSACTION_TRACE : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.TransactionTrace")] impl :: prost_wkt :: MessageSerde for TransactionTrace { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "TransactionTrace" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.TransactionTrace" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.TransactionTrace" , decoder : | buf : & [u8] | { let msg : TransactionTrace = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_TRANSACTION_RECEIPT_HEADER : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.TransactionReceiptHeader")] impl :: prost_wkt :: MessageSerde for TransactionReceiptHeader { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "TransactionReceiptHeader" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.TransactionReceiptHeader" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.TransactionReceiptHeader" , decoder : | buf : & [u8] | { let msg : TransactionReceiptHeader = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_ACTION : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.Action")] impl :: prost_wkt :: MessageSerde for Action { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "Action" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.Action" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.Action" , decoder : | buf : & [u8] | { let msg : Action = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_ACTION_TRACE : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.ActionTrace")] impl :: prost_wkt :: MessageSerde for ActionTrace { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "ActionTrace" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.ActionTrace" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.ActionTrace" , decoder : | buf : & [u8] | { let msg : ActionTrace = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_ACTION_RECEIPT : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.ActionReceipt")] impl :: prost_wkt :: MessageSerde for ActionReceipt { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "ActionReceipt" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.ActionReceipt" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.ActionReceipt" , decoder : | buf : & [u8] | { let msg : ActionReceipt = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_AUTH_SEQUENCE : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.AuthSequence")] impl :: prost_wkt :: MessageSerde for AuthSequence { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "AuthSequence" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.AuthSequence" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.AuthSequence" , decoder : | buf : & [u8] | { let msg : AuthSequence = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_ACCOUNT_RAM_DELTA : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.AccountRAMDelta")] impl :: prost_wkt :: MessageSerde for AccountRamDelta { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "AccountRAMDelta" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.AccountRAMDelta" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.AccountRAMDelta" , decoder : | buf : & [u8] | { let msg : AccountRamDelta = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_ACCOUNT_DELTA : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.AccountDelta")] impl :: prost_wkt :: MessageSerde for AccountDelta { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "AccountDelta" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.AccountDelta" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.AccountDelta" , decoder : | buf : & [u8] | { let msg : AccountDelta = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_EXTENSION : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.Extension")] impl :: prost_wkt :: MessageSerde for Extension { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "Extension" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.Extension" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.Extension" , decoder : | buf : & [u8] | { let msg : Extension = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_TRX_OP : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.TrxOp")] impl :: prost_wkt :: MessageSerde for TrxOp { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "TrxOp" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.TrxOp" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.TrxOp" , decoder : | buf : & [u8] | { let msg : TrxOp = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_DB_OP : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.DBOp")] impl :: prost_wkt :: MessageSerde for DbOp { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "DBOp" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.DBOp" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.DBOp" , decoder : | buf : & [u8] | { let msg : DbOp = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_RAM_OP : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.RAMOp")] impl :: prost_wkt :: MessageSerde for RamOp { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "RAMOp" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.RAMOp" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.RAMOp" , decoder : | buf : & [u8] | { let msg : RamOp = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_RAM_CORRECTION_OP : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.RAMCorrectionOp")] impl :: prost_wkt :: MessageSerde for RamCorrectionOp { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "RAMCorrectionOp" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.RAMCorrectionOp" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.RAMCorrectionOp" , decoder : | buf : & [u8] | { let msg : RamCorrectionOp = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_TABLE_OP : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.TableOp")] impl :: prost_wkt :: MessageSerde for TableOp { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "TableOp" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.TableOp" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.TableOp" , decoder : | buf : & [u8] | { let msg : TableOp = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_D_TRX_OP : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.DTrxOp")] impl :: prost_wkt :: MessageSerde for DTrxOp { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "DTrxOp" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.DTrxOp" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.DTrxOp" , decoder : | buf : & [u8] | { let msg : DTrxOp = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_EXT_D_TRX_OP : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.ExtDTrxOp")] impl :: prost_wkt :: MessageSerde for ExtDTrxOp { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "ExtDTrxOp" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.ExtDTrxOp" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.ExtDTrxOp" , decoder : | buf : & [u8] | { let msg : ExtDTrxOp = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_FEATURE_OP : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.FeatureOp")] impl :: prost_wkt :: MessageSerde for FeatureOp { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "FeatureOp" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.FeatureOp" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.FeatureOp" , decoder : | buf : & [u8] | { let msg : FeatureOp = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_CREATION_FLAT_NODE : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.CreationFlatNode")] impl :: prost_wkt :: MessageSerde for CreationFlatNode { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "CreationFlatNode" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.CreationFlatNode" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.CreationFlatNode" , decoder : | buf : & [u8] | { let msg : CreationFlatNode = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_PERM_OP : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.PermOp")] impl :: prost_wkt :: MessageSerde for PermOp { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "PermOp" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.PermOp" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.PermOp" , decoder : | buf : & [u8] | { let msg : PermOp = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_PERMISSION_OBJECT : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.PermissionObject")] impl :: prost_wkt :: MessageSerde for PermissionObject { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "PermissionObject" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.PermissionObject" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.PermissionObject" , decoder : | buf : & [u8] | { let msg : PermissionObject = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_PERMISSION : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.Permission")] impl :: prost_wkt :: MessageSerde for Permission { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "Permission" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.Permission" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.Permission" , decoder : | buf : & [u8] | { let msg : Permission = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_AUTHORITY : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.Authority")] impl :: prost_wkt :: MessageSerde for Authority { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "Authority" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.Authority" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.Authority" , decoder : | buf : & [u8] | { let msg : Authority = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_KEY_WEIGHT : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.KeyWeight")] impl :: prost_wkt :: MessageSerde for KeyWeight { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "KeyWeight" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.KeyWeight" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.KeyWeight" , decoder : | buf : & [u8] | { let msg : KeyWeight = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_PERMISSION_LEVEL : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.PermissionLevel")] impl :: prost_wkt :: MessageSerde for PermissionLevel { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "PermissionLevel" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.PermissionLevel" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.PermissionLevel" , decoder : | buf : & [u8] | { let msg : PermissionLevel = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_PERMISSION_LEVEL_WEIGHT : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.PermissionLevelWeight")] impl :: prost_wkt :: MessageSerde for PermissionLevelWeight { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "PermissionLevelWeight" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.PermissionLevelWeight" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.PermissionLevelWeight" , decoder : | buf : & [u8] | { let msg : PermissionLevelWeight = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_WAIT_WEIGHT : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.WaitWeight")] impl :: prost_wkt :: MessageSerde for WaitWeight { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "WaitWeight" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.WaitWeight" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.WaitWeight" , decoder : | buf : & [u8] | { let msg : WaitWeight = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_RLIMIT_OP : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.RlimitOp")] impl :: prost_wkt :: MessageSerde for RlimitOp { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "RlimitOp" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.RlimitOp" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.RlimitOp" , decoder : | buf : & [u8] | { let msg : RlimitOp = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_RLIMIT_STATE : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.RlimitState")] impl :: prost_wkt :: MessageSerde for RlimitState { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "RlimitState" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.RlimitState" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.RlimitState" , decoder : | buf : & [u8] | { let msg : RlimitState = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_RLIMIT_CONFIG : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.RlimitConfig")] impl :: prost_wkt :: MessageSerde for RlimitConfig { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "RlimitConfig" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.RlimitConfig" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.RlimitConfig" , decoder : | buf : & [u8] | { let msg : RlimitConfig = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_RLIMIT_ACCOUNT_LIMITS : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.RlimitAccountLimits")] impl :: prost_wkt :: MessageSerde for RlimitAccountLimits { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "RlimitAccountLimits" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.RlimitAccountLimits" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.RlimitAccountLimits" , decoder : | buf : & [u8] | { let msg : RlimitAccountLimits = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_RLIMIT_ACCOUNT_USAGE : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.RlimitAccountUsage")] impl :: prost_wkt :: MessageSerde for RlimitAccountUsage { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "RlimitAccountUsage" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.RlimitAccountUsage" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.RlimitAccountUsage" , decoder : | buf : & [u8] | { let msg : RlimitAccountUsage = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_USAGE_ACCUMULATOR : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.UsageAccumulator")] impl :: prost_wkt :: MessageSerde for UsageAccumulator { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "UsageAccumulator" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.UsageAccumulator" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.UsageAccumulator" , decoder : | buf : & [u8] | { let msg : UsageAccumulator = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_ELASTIC_LIMIT_PARAMETERS : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.ElasticLimitParameters")] impl :: prost_wkt :: MessageSerde for ElasticLimitParameters { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "ElasticLimitParameters" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.ElasticLimitParameters" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.ElasticLimitParameters" , decoder : | buf : & [u8] | { let msg : ElasticLimitParameters = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_RATIO : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.Ratio")] impl :: prost_wkt :: MessageSerde for Ratio { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "Ratio" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.Ratio" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.Ratio" , decoder : | buf : & [u8] | { let msg : Ratio = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_EXCEPTION : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.Exception")] impl :: prost_wkt :: MessageSerde for Exception { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "Exception" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.Exception" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.Exception" , decoder : | buf : & [u8] | { let msg : Exception = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_FEATURE : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.Feature")] impl :: prost_wkt :: MessageSerde for Feature { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "Feature" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.Feature" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.Feature" , decoder : | buf : & [u8] | { let msg : Feature = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_SUBJECTIVE_RESTRICTIONS : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.SubjectiveRestrictions")] impl :: prost_wkt :: MessageSerde for SubjectiveRestrictions { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "SubjectiveRestrictions" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.SubjectiveRestrictions" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.SubjectiveRestrictions" , decoder : | buf : & [u8] | { let msg : SubjectiveRestrictions = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_SPECIFICATION : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.Specification")] impl :: prost_wkt :: MessageSerde for Specification { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "Specification" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.Specification" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.Specification" , decoder : | buf : & [u8] | { let msg : Specification = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_ACCOUNT_CREATION_REF : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.AccountCreationRef")] impl :: prost_wkt :: MessageSerde for AccountCreationRef { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "AccountCreationRef" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.AccountCreationRef" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.AccountCreationRef" , decoder : | buf : & [u8] | { let msg : AccountCreationRef = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_HEADER_ONLY_BLOCK : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.HeaderOnlyBlock")] impl :: prost_wkt :: MessageSerde for HeaderOnlyBlock { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "HeaderOnlyBlock" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.HeaderOnlyBlock" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.HeaderOnlyBlock" , decoder : | buf : & [u8] | { let msg : HeaderOnlyBlock = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_TRANSACTION_TRACE_WITH_BLOCK_REF : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.TransactionTraceWithBlockRef")] impl :: prost_wkt :: MessageSerde for TransactionTraceWithBlockRef { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "TransactionTraceWithBlockRef" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.TransactionTraceWithBlockRef" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.TransactionTraceWithBlockRef" , decoder : | buf : & [u8] | { let msg : TransactionTraceWithBlockRef = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_BLOCK_REF : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.BlockRef")] impl :: prost_wkt :: MessageSerde for BlockRef { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "BlockRef" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.BlockRef" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.BlockRef" , decoder : | buf : & [u8] | { let msg : BlockRef = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_ACTION_TRACES : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.ActionTraces")] impl :: prost_wkt :: MessageSerde for ActionTraces { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "ActionTraces" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.ActionTraces" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.ActionTraces" , decoder : | buf : & [u8] | { let msg : ActionTraces = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_TRANSACTION_TRACES : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.TransactionTraces")] impl :: prost_wkt :: MessageSerde for TransactionTraces { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "TransactionTraces" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.TransactionTraces" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.TransactionTraces" , decoder : | buf : & [u8] | { let msg : TransactionTraces = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_DB_OPS : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.DBOps")] impl :: prost_wkt :: MessageSerde for DbOps { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "DBOps" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.DBOps" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.DBOps" , decoder : | buf : & [u8] | { let msg : DbOps = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_BLOCK : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.Block")] impl :: prost_wkt :: MessageSerde for Block { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "Block" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.Block" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.Block" , decoder : | buf : & [u8] | { let msg : Block = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_BLOCK_WITH_REFS : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.BlockWithRefs")] impl :: prost_wkt :: MessageSerde for BlockWithRefs { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "BlockWithRefs" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.BlockWithRefs" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.BlockWithRefs" , decoder : | buf : & [u8] | { let msg : BlockWithRefs = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_TRANSACTION_REFS : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.TransactionRefs")] impl :: prost_wkt :: MessageSerde for TransactionRefs { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "TransactionRefs" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.TransactionRefs" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.TransactionRefs" , decoder : | buf : & [u8] | { let msg : TransactionRefs = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_ACTIVATED_PROTOCOL_FEATURES : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.ActivatedProtocolFeatures")] impl :: prost_wkt :: MessageSerde for ActivatedProtocolFeatures { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "ActivatedProtocolFeatures" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.ActivatedProtocolFeatures" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.ActivatedProtocolFeatures" , decoder : | buf : & [u8] | { let msg : ActivatedProtocolFeatures = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_PENDING_PRODUCER_SCHEDULE : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.PendingProducerSchedule")] impl :: prost_wkt :: MessageSerde for PendingProducerSchedule { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "PendingProducerSchedule" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.PendingProducerSchedule" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.PendingProducerSchedule" , decoder : | buf : & [u8] | { let msg : PendingProducerSchedule = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_PRODUCER_SCHEDULE : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.ProducerSchedule")] impl :: prost_wkt :: MessageSerde for ProducerSchedule { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "ProducerSchedule" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.ProducerSchedule" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.ProducerSchedule" , decoder : | buf : & [u8] | { let msg : ProducerSchedule = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_PRODUCER_KEY : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.ProducerKey")] impl :: prost_wkt :: MessageSerde for ProducerKey { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "ProducerKey" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.ProducerKey" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.ProducerKey" , decoder : | buf : & [u8] | { let msg : ProducerKey = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_PRODUCER_AUTHORITY_SCHEDULE : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.ProducerAuthoritySchedule")] impl :: prost_wkt :: MessageSerde for ProducerAuthoritySchedule { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "ProducerAuthoritySchedule" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.ProducerAuthoritySchedule" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.ProducerAuthoritySchedule" , decoder : | buf : & [u8] | { let msg : ProducerAuthoritySchedule = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_PRODUCER_AUTHORITY : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.ProducerAuthority")] impl :: prost_wkt :: MessageSerde for ProducerAuthority { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "ProducerAuthority" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.ProducerAuthority" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.ProducerAuthority" , decoder : | buf : & [u8] | { let msg : ProducerAuthority = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_BLOCK_SIGNING_AUTHORITY : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.BlockSigningAuthority")] impl :: prost_wkt :: MessageSerde for BlockSigningAuthority { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "BlockSigningAuthority" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.BlockSigningAuthority" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.BlockSigningAuthority" , decoder : | buf : & [u8] | { let msg : BlockSigningAuthority = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_BLOCK_SIGNING_AUTHORITY_V0 : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.BlockSigningAuthorityV0")] impl :: prost_wkt :: MessageSerde for BlockSigningAuthorityV0 { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "BlockSigningAuthorityV0" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.BlockSigningAuthorityV0" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.BlockSigningAuthorityV0" , decoder : | buf : & [u8] | { let msg : BlockSigningAuthorityV0 = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_BLOCK_ROOT_MERKLE : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.BlockRootMerkle")] impl :: prost_wkt :: MessageSerde for BlockRootMerkle { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "BlockRootMerkle" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.BlockRootMerkle" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.BlockRootMerkle" , decoder : | buf : & [u8] | { let msg : BlockRootMerkle = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_PRODUCER_TO_LAST_PRODUCED : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.ProducerToLastProduced")] impl :: prost_wkt :: MessageSerde for ProducerToLastProduced { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "ProducerToLastProduced" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.ProducerToLastProduced" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.ProducerToLastProduced" , decoder : | buf : & [u8] | { let msg : ProducerToLastProduced = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_PRODUCER_TO_LAST_IMPLIED_IRB : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.ProducerToLastImpliedIRB")] impl :: prost_wkt :: MessageSerde for ProducerToLastImpliedIrb { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "ProducerToLastImpliedIRB" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.ProducerToLastImpliedIRB" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.ProducerToLastImpliedIRB" , decoder : | buf : & [u8] | { let msg : ProducerToLastImpliedIrb = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_TRANSACTION_RECEIPT : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.TransactionReceipt")] impl :: prost_wkt :: MessageSerde for TransactionReceipt { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "TransactionReceipt" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.TransactionReceipt" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.TransactionReceipt" , decoder : | buf : & [u8] | { let msg : TransactionReceipt = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_PACKED_TRANSACTION : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.PackedTransaction")] impl :: prost_wkt :: MessageSerde for PackedTransaction { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "PackedTransaction" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.PackedTransaction" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.PackedTransaction" , decoder : | buf : & [u8] | { let msg : PackedTransaction = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_BLOCK_HEADER : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.BlockHeader")] impl :: prost_wkt :: MessageSerde for BlockHeader { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "BlockHeader" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.BlockHeader" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.BlockHeader" , decoder : | buf : & [u8] | { let msg : BlockHeader = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_TRANSACTION_EVENT : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.TransactionEvent")] impl :: prost_wkt :: MessageSerde for TransactionEvent { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "TransactionEvent" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.TransactionEvent" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.TransactionEvent" , decoder : | buf : & [u8] | { let msg : TransactionEvent = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_PUBLIC_KEYS : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.PublicKeys")] impl :: prost_wkt :: MessageSerde for PublicKeys { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "PublicKeys" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.PublicKeys" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.PublicKeys" , decoder : | buf : & [u8] | { let msg : PublicKeys = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_TRANSACTION_LIFECYCLE : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.TransactionLifecycle")] impl :: prost_wkt :: MessageSerde for TransactionLifecycle { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "TransactionLifecycle" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.TransactionLifecycle" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.TransactionLifecycle" , decoder : | buf : & [u8] | { let msg : TransactionLifecycle = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_SIGNED_TRANSACTION : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.SignedTransaction")] impl :: prost_wkt :: MessageSerde for SignedTransaction { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "SignedTransaction" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.SignedTransaction" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.SignedTransaction" , decoder : | buf : & [u8] | { let msg : SignedTransaction = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_TRANSACTION : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.Transaction")] impl :: prost_wkt :: MessageSerde for Transaction { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "Transaction" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.Transaction" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.Transaction" , decoder : | buf : & [u8] | { let msg : Transaction = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_TRANSACTION_HEADER : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.TransactionHeader")] impl :: prost_wkt :: MessageSerde for TransactionHeader { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "TransactionHeader" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.TransactionHeader" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.TransactionHeader" , decoder : | buf : & [u8] | { let msg : TransactionHeader = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_TRANSACTION_TRACE : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.TransactionTrace")] impl :: prost_wkt :: MessageSerde for TransactionTrace { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "TransactionTrace" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.TransactionTrace" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.TransactionTrace" , decoder : | buf : & [u8] | { let msg : TransactionTrace = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_TRANSACTION_RECEIPT_HEADER : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.TransactionReceiptHeader")] impl :: prost_wkt :: MessageSerde for TransactionReceiptHeader { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "TransactionReceiptHeader" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.TransactionReceiptHeader" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.TransactionReceiptHeader" , decoder : | buf : & [u8] | { let msg : TransactionReceiptHeader = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_ACTION : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.Action")] impl :: prost_wkt :: MessageSerde for Action { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "Action" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.Action" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.Action" , decoder : | buf : & [u8] | { let msg : Action = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_ACTION_TRACE : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.ActionTrace")] impl :: prost_wkt :: MessageSerde for ActionTrace { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "ActionTrace" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.ActionTrace" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.ActionTrace" , decoder : | buf : & [u8] | { let msg : ActionTrace = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_ACTION_RECEIPT : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.ActionReceipt")] impl :: prost_wkt :: MessageSerde for ActionReceipt { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "ActionReceipt" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.ActionReceipt" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.ActionReceipt" , decoder : | buf : & [u8] | { let msg : ActionReceipt = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_AUTH_SEQUENCE : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.AuthSequence")] impl :: prost_wkt :: MessageSerde for AuthSequence { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "AuthSequence" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.AuthSequence" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.AuthSequence" , decoder : | buf : & [u8] | { let msg : AuthSequence = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_ACCOUNT_RAM_DELTA : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.AccountRAMDelta")] impl :: prost_wkt :: MessageSerde for AccountRamDelta { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "AccountRAMDelta" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.AccountRAMDelta" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.AccountRAMDelta" , decoder : | buf : & [u8] | { let msg : AccountRamDelta = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_ACCOUNT_DELTA : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.AccountDelta")] impl :: prost_wkt :: MessageSerde for AccountDelta { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "AccountDelta" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.AccountDelta" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.AccountDelta" , decoder : | buf : & [u8] | { let msg : AccountDelta = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_EXTENSION : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.Extension")] impl :: prost_wkt :: MessageSerde for Extension { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "Extension" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.Extension" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.Extension" , decoder : | buf : & [u8] | { let msg : Extension = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_TRX_OP : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.TrxOp")] impl :: prost_wkt :: MessageSerde for TrxOp { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "TrxOp" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.TrxOp" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.TrxOp" , decoder : | buf : & [u8] | { let msg : TrxOp = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_DB_OP : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.DBOp")] impl :: prost_wkt :: MessageSerde for DbOp { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "DBOp" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.DBOp" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.DBOp" , decoder : | buf : & [u8] | { let msg : DbOp = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_RAM_OP : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.RAMOp")] impl :: prost_wkt :: MessageSerde for RamOp { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "RAMOp" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.RAMOp" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.RAMOp" , decoder : | buf : & [u8] | { let msg : RamOp = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_RAM_CORRECTION_OP : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.RAMCorrectionOp")] impl :: prost_wkt :: MessageSerde for RamCorrectionOp { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "RAMCorrectionOp" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.RAMCorrectionOp" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.RAMCorrectionOp" , decoder : | buf : & [u8] | { let msg : RamCorrectionOp = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_TABLE_OP : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.TableOp")] impl :: prost_wkt :: MessageSerde for TableOp { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "TableOp" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.TableOp" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.TableOp" , decoder : | buf : & [u8] | { let msg : TableOp = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_D_TRX_OP : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.DTrxOp")] impl :: prost_wkt :: MessageSerde for DTrxOp { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "DTrxOp" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.DTrxOp" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.DTrxOp" , decoder : | buf : & [u8] | { let msg : DTrxOp = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_EXT_D_TRX_OP : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.ExtDTrxOp")] impl :: prost_wkt :: MessageSerde for ExtDTrxOp { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "ExtDTrxOp" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.ExtDTrxOp" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.ExtDTrxOp" , decoder : | buf : & [u8] | { let msg : ExtDTrxOp = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_FEATURE_OP : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.FeatureOp")] impl :: prost_wkt :: MessageSerde for FeatureOp { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "FeatureOp" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.FeatureOp" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.FeatureOp" , decoder : | buf : & [u8] | { let msg : FeatureOp = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_CREATION_FLAT_NODE : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.CreationFlatNode")] impl :: prost_wkt :: MessageSerde for CreationFlatNode { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "CreationFlatNode" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.CreationFlatNode" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.CreationFlatNode" , decoder : | buf : & [u8] | { let msg : CreationFlatNode = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_PERM_OP : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.PermOp")] impl :: prost_wkt :: MessageSerde for PermOp { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "PermOp" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.PermOp" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.PermOp" , decoder : | buf : & [u8] | { let msg : PermOp = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_PERMISSION_OBJECT : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.PermissionObject")] impl :: prost_wkt :: MessageSerde for PermissionObject { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "PermissionObject" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.PermissionObject" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.PermissionObject" , decoder : | buf : & [u8] | { let msg : PermissionObject = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_PERMISSION : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.Permission")] impl :: prost_wkt :: MessageSerde for Permission { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "Permission" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.Permission" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.Permission" , decoder : | buf : & [u8] | { let msg : Permission = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_AUTHORITY : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.Authority")] impl :: prost_wkt :: MessageSerde for Authority { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "Authority" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.Authority" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.Authority" , decoder : | buf : & [u8] | { let msg : Authority = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_KEY_WEIGHT : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.KeyWeight")] impl :: prost_wkt :: MessageSerde for KeyWeight { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "KeyWeight" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.KeyWeight" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.KeyWeight" , decoder : | buf : & [u8] | { let msg : KeyWeight = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_PERMISSION_LEVEL : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.PermissionLevel")] impl :: prost_wkt :: MessageSerde for PermissionLevel { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "PermissionLevel" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.PermissionLevel" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.PermissionLevel" , decoder : | buf : & [u8] | { let msg : PermissionLevel = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_PERMISSION_LEVEL_WEIGHT : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.PermissionLevelWeight")] impl :: prost_wkt :: MessageSerde for PermissionLevelWeight { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "PermissionLevelWeight" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.PermissionLevelWeight" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.PermissionLevelWeight" , decoder : | buf : & [u8] | { let msg : PermissionLevelWeight = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_WAIT_WEIGHT : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.WaitWeight")] impl :: prost_wkt :: MessageSerde for WaitWeight { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "WaitWeight" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.WaitWeight" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.WaitWeight" , decoder : | buf : & [u8] | { let msg : WaitWeight = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_RLIMIT_OP : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.RlimitOp")] impl :: prost_wkt :: MessageSerde for RlimitOp { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "RlimitOp" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.RlimitOp" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.RlimitOp" , decoder : | buf : & [u8] | { let msg : RlimitOp = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_RLIMIT_STATE : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.RlimitState")] impl :: prost_wkt :: MessageSerde for RlimitState { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "RlimitState" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.RlimitState" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.RlimitState" , decoder : | buf : & [u8] | { let msg : RlimitState = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_RLIMIT_CONFIG : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.RlimitConfig")] impl :: prost_wkt :: MessageSerde for RlimitConfig { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "RlimitConfig" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.RlimitConfig" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.RlimitConfig" , decoder : | buf : & [u8] | { let msg : RlimitConfig = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_RLIMIT_ACCOUNT_LIMITS : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.RlimitAccountLimits")] impl :: prost_wkt :: MessageSerde for RlimitAccountLimits { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "RlimitAccountLimits" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.RlimitAccountLimits" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.RlimitAccountLimits" , decoder : | buf : & [u8] | { let msg : RlimitAccountLimits = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_RLIMIT_ACCOUNT_USAGE : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.RlimitAccountUsage")] impl :: prost_wkt :: MessageSerde for RlimitAccountUsage { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "RlimitAccountUsage" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.RlimitAccountUsage" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.RlimitAccountUsage" , decoder : | buf : & [u8] | { let msg : RlimitAccountUsage = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_USAGE_ACCUMULATOR : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.UsageAccumulator")] impl :: prost_wkt :: MessageSerde for UsageAccumulator { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "UsageAccumulator" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.UsageAccumulator" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.UsageAccumulator" , decoder : | buf : & [u8] | { let msg : UsageAccumulator = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_ELASTIC_LIMIT_PARAMETERS : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.ElasticLimitParameters")] impl :: prost_wkt :: MessageSerde for ElasticLimitParameters { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "ElasticLimitParameters" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.ElasticLimitParameters" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.ElasticLimitParameters" , decoder : | buf : & [u8] | { let msg : ElasticLimitParameters = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_RATIO : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.Ratio")] impl :: prost_wkt :: MessageSerde for Ratio { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "Ratio" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.Ratio" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.Ratio" , decoder : | buf : & [u8] | { let msg : Ratio = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_EXCEPTION : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.Exception")] impl :: prost_wkt :: MessageSerde for Exception { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "Exception" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.Exception" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.Exception" , decoder : | buf : & [u8] | { let msg : Exception = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_FEATURE : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.Feature")] impl :: prost_wkt :: MessageSerde for Feature { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "Feature" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.Feature" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.Feature" , decoder : | buf : & [u8] | { let msg : Feature = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_SUBJECTIVE_RESTRICTIONS : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.SubjectiveRestrictions")] impl :: prost_wkt :: MessageSerde for SubjectiveRestrictions { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "SubjectiveRestrictions" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.SubjectiveRestrictions" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.SubjectiveRestrictions" , decoder : | buf : & [u8] | { let msg : SubjectiveRestrictions = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_SPECIFICATION : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.Specification")] impl :: prost_wkt :: MessageSerde for Specification { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "Specification" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.Specification" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.Specification" , decoder : | buf : & [u8] | { let msg : Specification = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_ACCOUNT_CREATION_REF : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.AccountCreationRef")] impl :: prost_wkt :: MessageSerde for AccountCreationRef { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "AccountCreationRef" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.AccountCreationRef" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.AccountCreationRef" , decoder : | buf : & [u8] | { let msg : AccountCreationRef = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_HEADER_ONLY_BLOCK : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.HeaderOnlyBlock")] impl :: prost_wkt :: MessageSerde for HeaderOnlyBlock { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "HeaderOnlyBlock" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.HeaderOnlyBlock" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.HeaderOnlyBlock" , decoder : | buf : & [u8] | { let msg : HeaderOnlyBlock = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_TRANSACTION_TRACE_WITH_BLOCK_REF : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.TransactionTraceWithBlockRef")] impl :: prost_wkt :: MessageSerde for TransactionTraceWithBlockRef { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "TransactionTraceWithBlockRef" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.TransactionTraceWithBlockRef" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.TransactionTraceWithBlockRef" , decoder : | buf : & [u8] | { let msg : TransactionTraceWithBlockRef = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_BLOCK_REF : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.BlockRef")] impl :: prost_wkt :: MessageSerde for BlockRef { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "BlockRef" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.BlockRef" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.BlockRef" , decoder : | buf : & [u8] | { let msg : BlockRef = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_ACTION_TRACES : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.ActionTraces")] impl :: prost_wkt :: MessageSerde for ActionTraces { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "ActionTraces" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.ActionTraces" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.ActionTraces" , decoder : | buf : & [u8] | { let msg : ActionTraces = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_TRANSACTION_TRACES : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.TransactionTraces")] impl :: prost_wkt :: MessageSerde for TransactionTraces { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "TransactionTraces" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.TransactionTraces" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.TransactionTraces" , decoder : | buf : & [u8] | { let msg : TransactionTraces = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_DB_OPS : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.DBOps")] impl :: prost_wkt :: MessageSerde for DbOps { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "DBOps" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.DBOps" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.DBOps" , decoder : | buf : & [u8] | { let msg : DbOps = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_BLOCK : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.Block")] impl :: prost_wkt :: MessageSerde for Block { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "Block" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.Block" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.Block" , decoder : | buf : & [u8] | { let msg : Block = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_BLOCK_WITH_REFS : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.BlockWithRefs")] impl :: prost_wkt :: MessageSerde for BlockWithRefs { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "BlockWithRefs" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.BlockWithRefs" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.BlockWithRefs" , decoder : | buf : & [u8] | { let msg : BlockWithRefs = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_TRANSACTION_REFS : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.TransactionRefs")] impl :: prost_wkt :: MessageSerde for TransactionRefs { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "TransactionRefs" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.TransactionRefs" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.TransactionRefs" , decoder : | buf : & [u8] | { let msg : TransactionRefs = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_ACTIVATED_PROTOCOL_FEATURES : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.ActivatedProtocolFeatures")] impl :: prost_wkt :: MessageSerde for ActivatedProtocolFeatures { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "ActivatedProtocolFeatures" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.ActivatedProtocolFeatures" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.ActivatedProtocolFeatures" , decoder : | buf : & [u8] | { let msg : ActivatedProtocolFeatures = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_PENDING_PRODUCER_SCHEDULE : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.PendingProducerSchedule")] impl :: prost_wkt :: MessageSerde for PendingProducerSchedule { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "PendingProducerSchedule" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.PendingProducerSchedule" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.PendingProducerSchedule" , decoder : | buf : & [u8] | { let msg : PendingProducerSchedule = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_PRODUCER_SCHEDULE : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.ProducerSchedule")] impl :: prost_wkt :: MessageSerde for ProducerSchedule { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "ProducerSchedule" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.ProducerSchedule" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.ProducerSchedule" , decoder : | buf : & [u8] | { let msg : ProducerSchedule = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_PRODUCER_KEY : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.ProducerKey")] impl :: prost_wkt :: MessageSerde for ProducerKey { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "ProducerKey" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.ProducerKey" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.ProducerKey" , decoder : | buf : & [u8] | { let msg : ProducerKey = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_PRODUCER_AUTHORITY_SCHEDULE : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.ProducerAuthoritySchedule")] impl :: prost_wkt :: MessageSerde for ProducerAuthoritySchedule { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "ProducerAuthoritySchedule" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.ProducerAuthoritySchedule" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.ProducerAuthoritySchedule" , decoder : | buf : & [u8] | { let msg : ProducerAuthoritySchedule = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_PRODUCER_AUTHORITY : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.ProducerAuthority")] impl :: prost_wkt :: MessageSerde for ProducerAuthority { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "ProducerAuthority" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.ProducerAuthority" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.ProducerAuthority" , decoder : | buf : & [u8] | { let msg : ProducerAuthority = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_BLOCK_SIGNING_AUTHORITY : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.BlockSigningAuthority")] impl :: prost_wkt :: MessageSerde for BlockSigningAuthority { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "BlockSigningAuthority" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.BlockSigningAuthority" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.BlockSigningAuthority" , decoder : | buf : & [u8] | { let msg : BlockSigningAuthority = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_BLOCK_SIGNING_AUTHORITY_V0 : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.BlockSigningAuthorityV0")] impl :: prost_wkt :: MessageSerde for BlockSigningAuthorityV0 { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "BlockSigningAuthorityV0" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.BlockSigningAuthorityV0" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.BlockSigningAuthorityV0" , decoder : | buf : & [u8] | { let msg : BlockSigningAuthorityV0 = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_BLOCK_ROOT_MERKLE : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.BlockRootMerkle")] impl :: prost_wkt :: MessageSerde for BlockRootMerkle { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "BlockRootMerkle" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.BlockRootMerkle" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.BlockRootMerkle" , decoder : | buf : & [u8] | { let msg : BlockRootMerkle = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_PRODUCER_TO_LAST_PRODUCED : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.ProducerToLastProduced")] impl :: prost_wkt :: MessageSerde for ProducerToLastProduced { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "ProducerToLastProduced" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.ProducerToLastProduced" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.ProducerToLastProduced" , decoder : | buf : & [u8] | { let msg : ProducerToLastProduced = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_PRODUCER_TO_LAST_IMPLIED_IRB : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.ProducerToLastImpliedIRB")] impl :: prost_wkt :: MessageSerde for ProducerToLastImpliedIrb { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "ProducerToLastImpliedIRB" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.ProducerToLastImpliedIRB" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.ProducerToLastImpliedIRB" , decoder : | buf : & [u8] | { let msg : ProducerToLastImpliedIrb = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_TRANSACTION_RECEIPT : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.TransactionReceipt")] impl :: prost_wkt :: MessageSerde for TransactionReceipt { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "TransactionReceipt" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.TransactionReceipt" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.TransactionReceipt" , decoder : | buf : & [u8] | { let msg : TransactionReceipt = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_PACKED_TRANSACTION : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.PackedTransaction")] impl :: prost_wkt :: MessageSerde for PackedTransaction { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "PackedTransaction" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.PackedTransaction" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.PackedTransaction" , decoder : | buf : & [u8] | { let msg : PackedTransaction = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_BLOCK_HEADER : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.BlockHeader")] impl :: prost_wkt :: MessageSerde for BlockHeader { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "BlockHeader" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.BlockHeader" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.BlockHeader" , decoder : | buf : & [u8] | { let msg : BlockHeader = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_TRANSACTION_EVENT : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.TransactionEvent")] impl :: prost_wkt :: MessageSerde for TransactionEvent { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "TransactionEvent" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.TransactionEvent" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.TransactionEvent" , decoder : | buf : & [u8] | { let msg : TransactionEvent = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_PUBLIC_KEYS : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.PublicKeys")] impl :: prost_wkt :: MessageSerde for PublicKeys { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "PublicKeys" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.PublicKeys" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.PublicKeys" , decoder : | buf : & [u8] | { let msg : PublicKeys = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_TRANSACTION_LIFECYCLE : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.TransactionLifecycle")] impl :: prost_wkt :: MessageSerde for TransactionLifecycle { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "TransactionLifecycle" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.TransactionLifecycle" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.TransactionLifecycle" , decoder : | buf : & [u8] | { let msg : TransactionLifecycle = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_SIGNED_TRANSACTION : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.SignedTransaction")] impl :: prost_wkt :: MessageSerde for SignedTransaction { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "SignedTransaction" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.SignedTransaction" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.SignedTransaction" , decoder : | buf : & [u8] | { let msg : SignedTransaction = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_TRANSACTION : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.Transaction")] impl :: prost_wkt :: MessageSerde for Transaction { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "Transaction" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.Transaction" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.Transaction" , decoder : | buf : & [u8] | { let msg : Transaction = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_TRANSACTION_HEADER : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.TransactionHeader")] impl :: prost_wkt :: MessageSerde for TransactionHeader { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "TransactionHeader" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.TransactionHeader" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.TransactionHeader" , decoder : | buf : & [u8] | { let msg : TransactionHeader = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_TRANSACTION_TRACE : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.TransactionTrace")] impl :: prost_wkt :: MessageSerde for TransactionTrace { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "TransactionTrace" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.TransactionTrace" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.TransactionTrace" , decoder : | buf : & [u8] | { let msg : TransactionTrace = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_TRANSACTION_RECEIPT_HEADER : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.TransactionReceiptHeader")] impl :: prost_wkt :: MessageSerde for TransactionReceiptHeader { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "TransactionReceiptHeader" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.TransactionReceiptHeader" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.TransactionReceiptHeader" , decoder : | buf : & [u8] | { let msg : TransactionReceiptHeader = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_ACTION : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.Action")] impl :: prost_wkt :: MessageSerde for Action { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "Action" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.Action" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.Action" , decoder : | buf : & [u8] | { let msg : Action = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_ACTION_TRACE : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.ActionTrace")] impl :: prost_wkt :: MessageSerde for ActionTrace { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "ActionTrace" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.ActionTrace" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.ActionTrace" , decoder : | buf : & [u8] | { let msg : ActionTrace = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_ACTION_RECEIPT : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.ActionReceipt")] impl :: prost_wkt :: MessageSerde for ActionReceipt { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "ActionReceipt" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.ActionReceipt" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.ActionReceipt" , decoder : | buf : & [u8] | { let msg : ActionReceipt = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_AUTH_SEQUENCE : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.AuthSequence")] impl :: prost_wkt :: MessageSerde for AuthSequence { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "AuthSequence" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.AuthSequence" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.AuthSequence" , decoder : | buf : & [u8] | { let msg : AuthSequence = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_ACCOUNT_RAM_DELTA : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.AccountRAMDelta")] impl :: prost_wkt :: MessageSerde for AccountRamDelta { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "AccountRAMDelta" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.AccountRAMDelta" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.AccountRAMDelta" , decoder : | buf : & [u8] | { let msg : AccountRamDelta = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_ACCOUNT_DELTA : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.AccountDelta")] impl :: prost_wkt :: MessageSerde for AccountDelta { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "AccountDelta" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.AccountDelta" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.AccountDelta" , decoder : | buf : & [u8] | { let msg : AccountDelta = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_EXTENSION : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.Extension")] impl :: prost_wkt :: MessageSerde for Extension { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "Extension" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.Extension" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.Extension" , decoder : | buf : & [u8] | { let msg : Extension = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_TRX_OP : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.TrxOp")] impl :: prost_wkt :: MessageSerde for TrxOp { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "TrxOp" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.TrxOp" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.TrxOp" , decoder : | buf : & [u8] | { let msg : TrxOp = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_DB_OP : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.DBOp")] impl :: prost_wkt :: MessageSerde for DbOp { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "DBOp" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.DBOp" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.DBOp" , decoder : | buf : & [u8] | { let msg : DbOp = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_RAM_OP : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.RAMOp")] impl :: prost_wkt :: MessageSerde for RamOp { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "RAMOp" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.RAMOp" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.RAMOp" , decoder : | buf : & [u8] | { let msg : RamOp = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_RAM_CORRECTION_OP : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.RAMCorrectionOp")] impl :: prost_wkt :: MessageSerde for RamCorrectionOp { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "RAMCorrectionOp" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.RAMCorrectionOp" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.RAMCorrectionOp" , decoder : | buf : & [u8] | { let msg : RamCorrectionOp = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_TABLE_OP : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.TableOp")] impl :: prost_wkt :: MessageSerde for TableOp { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "TableOp" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.TableOp" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.TableOp" , decoder : | buf : & [u8] | { let msg : TableOp = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_D_TRX_OP : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.DTrxOp")] impl :: prost_wkt :: MessageSerde for DTrxOp { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "DTrxOp" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.DTrxOp" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.DTrxOp" , decoder : | buf : & [u8] | { let msg : DTrxOp = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_EXT_D_TRX_OP : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.ExtDTrxOp")] impl :: prost_wkt :: MessageSerde for ExtDTrxOp { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "ExtDTrxOp" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.ExtDTrxOp" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.ExtDTrxOp" , decoder : | buf : & [u8] | { let msg : ExtDTrxOp = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_FEATURE_OP : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.FeatureOp")] impl :: prost_wkt :: MessageSerde for FeatureOp { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "FeatureOp" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.FeatureOp" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.FeatureOp" , decoder : | buf : & [u8] | { let msg : FeatureOp = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_CREATION_FLAT_NODE : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.CreationFlatNode")] impl :: prost_wkt :: MessageSerde for CreationFlatNode { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "CreationFlatNode" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.CreationFlatNode" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.CreationFlatNode" , decoder : | buf : & [u8] | { let msg : CreationFlatNode = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_PERM_OP : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.PermOp")] impl :: prost_wkt :: MessageSerde for PermOp { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "PermOp" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.PermOp" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.PermOp" , decoder : | buf : & [u8] | { let msg : PermOp = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_PERMISSION_OBJECT : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.PermissionObject")] impl :: prost_wkt :: MessageSerde for PermissionObject { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "PermissionObject" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.PermissionObject" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.PermissionObject" , decoder : | buf : & [u8] | { let msg : PermissionObject = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_PERMISSION : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.Permission")] impl :: prost_wkt :: MessageSerde for Permission { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "Permission" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.Permission" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.Permission" , decoder : | buf : & [u8] | { let msg : Permission = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_AUTHORITY : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.Authority")] impl :: prost_wkt :: MessageSerde for Authority { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "Authority" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.Authority" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.Authority" , decoder : | buf : & [u8] | { let msg : Authority = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_KEY_WEIGHT : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.KeyWeight")] impl :: prost_wkt :: MessageSerde for KeyWeight { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "KeyWeight" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.KeyWeight" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.KeyWeight" , decoder : | buf : & [u8] | { let msg : KeyWeight = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_PERMISSION_LEVEL : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.PermissionLevel")] impl :: prost_wkt :: MessageSerde for PermissionLevel { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "PermissionLevel" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.PermissionLevel" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.PermissionLevel" , decoder : | buf : & [u8] | { let msg : PermissionLevel = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_PERMISSION_LEVEL_WEIGHT : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.PermissionLevelWeight")] impl :: prost_wkt :: MessageSerde for PermissionLevelWeight { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "PermissionLevelWeight" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.PermissionLevelWeight" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.PermissionLevelWeight" , decoder : | buf : & [u8] | { let msg : PermissionLevelWeight = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_WAIT_WEIGHT : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.WaitWeight")] impl :: prost_wkt :: MessageSerde for WaitWeight { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "WaitWeight" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.WaitWeight" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.WaitWeight" , decoder : | buf : & [u8] | { let msg : WaitWeight = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_RLIMIT_OP : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.RlimitOp")] impl :: prost_wkt :: MessageSerde for RlimitOp { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "RlimitOp" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.RlimitOp" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.RlimitOp" , decoder : | buf : & [u8] | { let msg : RlimitOp = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_RLIMIT_STATE : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.RlimitState")] impl :: prost_wkt :: MessageSerde for RlimitState { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "RlimitState" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.RlimitState" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.RlimitState" , decoder : | buf : & [u8] | { let msg : RlimitState = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_RLIMIT_CONFIG : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.RlimitConfig")] impl :: prost_wkt :: MessageSerde for RlimitConfig { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "RlimitConfig" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.RlimitConfig" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.RlimitConfig" , decoder : | buf : & [u8] | { let msg : RlimitConfig = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_RLIMIT_ACCOUNT_LIMITS : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.RlimitAccountLimits")] impl :: prost_wkt :: MessageSerde for RlimitAccountLimits { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "RlimitAccountLimits" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.RlimitAccountLimits" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.RlimitAccountLimits" , decoder : | buf : & [u8] | { let msg : RlimitAccountLimits = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_RLIMIT_ACCOUNT_USAGE : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.RlimitAccountUsage")] impl :: prost_wkt :: MessageSerde for RlimitAccountUsage { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "RlimitAccountUsage" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.RlimitAccountUsage" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.RlimitAccountUsage" , decoder : | buf : & [u8] | { let msg : RlimitAccountUsage = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_USAGE_ACCUMULATOR : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.UsageAccumulator")] impl :: prost_wkt :: MessageSerde for UsageAccumulator { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "UsageAccumulator" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.UsageAccumulator" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.UsageAccumulator" , decoder : | buf : & [u8] | { let msg : UsageAccumulator = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_ELASTIC_LIMIT_PARAMETERS : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.ElasticLimitParameters")] impl :: prost_wkt :: MessageSerde for ElasticLimitParameters { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "ElasticLimitParameters" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.ElasticLimitParameters" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.ElasticLimitParameters" , decoder : | buf : & [u8] | { let msg : ElasticLimitParameters = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_RATIO : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.Ratio")] impl :: prost_wkt :: MessageSerde for Ratio { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "Ratio" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.Ratio" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.Ratio" , decoder : | buf : & [u8] | { let msg : Ratio = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_EXCEPTION : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.Exception")] impl :: prost_wkt :: MessageSerde for Exception { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "Exception" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.Exception" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.Exception" , decoder : | buf : & [u8] | { let msg : Exception = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_FEATURE : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.Feature")] impl :: prost_wkt :: MessageSerde for Feature { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "Feature" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.Feature" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.Feature" , decoder : | buf : & [u8] | { let msg : Feature = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_SUBJECTIVE_RESTRICTIONS : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.SubjectiveRestrictions")] impl :: prost_wkt :: MessageSerde for SubjectiveRestrictions { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "SubjectiveRestrictions" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.SubjectiveRestrictions" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.SubjectiveRestrictions" , decoder : | buf : & [u8] | { let msg : SubjectiveRestrictions = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_SPECIFICATION : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.Specification")] impl :: prost_wkt :: MessageSerde for Specification { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "Specification" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.Specification" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.Specification" , decoder : | buf : & [u8] | { let msg : Specification = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_ACCOUNT_CREATION_REF : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.AccountCreationRef")] impl :: prost_wkt :: MessageSerde for AccountCreationRef { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "AccountCreationRef" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.AccountCreationRef" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.AccountCreationRef" , decoder : | buf : & [u8] | { let msg : AccountCreationRef = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_HEADER_ONLY_BLOCK : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.HeaderOnlyBlock")] impl :: prost_wkt :: MessageSerde for HeaderOnlyBlock { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "HeaderOnlyBlock" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.HeaderOnlyBlock" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.HeaderOnlyBlock" , decoder : | buf : & [u8] | { let msg : HeaderOnlyBlock = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_TRANSACTION_TRACE_WITH_BLOCK_REF : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.TransactionTraceWithBlockRef")] impl :: prost_wkt :: MessageSerde for TransactionTraceWithBlockRef { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "TransactionTraceWithBlockRef" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.TransactionTraceWithBlockRef" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.TransactionTraceWithBlockRef" , decoder : | buf : & [u8] | { let msg : TransactionTraceWithBlockRef = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_BLOCK_REF : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.BlockRef")] impl :: prost_wkt :: MessageSerde for BlockRef { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "BlockRef" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.BlockRef" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.BlockRef" , decoder : | buf : & [u8] | { let msg : BlockRef = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_ACTION_TRACES : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.ActionTraces")] impl :: prost_wkt :: MessageSerde for ActionTraces { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "ActionTraces" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.ActionTraces" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.ActionTraces" , decoder : | buf : & [u8] | { let msg : ActionTraces = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_TRANSACTION_TRACES : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.TransactionTraces")] impl :: prost_wkt :: MessageSerde for TransactionTraces { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "TransactionTraces" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.TransactionTraces" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.TransactionTraces" , decoder : | buf : & [u8] | { let msg : TransactionTraces = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_DB_OPS : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.DBOps")] impl :: prost_wkt :: MessageSerde for DbOps { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "DBOps" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.DBOps" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.DBOps" , decoder : | buf : & [u8] | { let msg : DbOps = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_BLOCK : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.Block")] impl :: prost_wkt :: MessageSerde for Block { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "Block" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.Block" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.Block" , decoder : | buf : & [u8] | { let msg : Block = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_BLOCK_WITH_REFS : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.BlockWithRefs")] impl :: prost_wkt :: MessageSerde for BlockWithRefs { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "BlockWithRefs" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.BlockWithRefs" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.BlockWithRefs" , decoder : | buf : & [u8] | { let msg : BlockWithRefs = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_TRANSACTION_REFS : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.TransactionRefs")] impl :: prost_wkt :: MessageSerde for TransactionRefs { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "TransactionRefs" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.TransactionRefs" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.TransactionRefs" , decoder : | buf : & [u8] | { let msg : TransactionRefs = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_ACTIVATED_PROTOCOL_FEATURES : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.ActivatedProtocolFeatures")] impl :: prost_wkt :: MessageSerde for ActivatedProtocolFeatures { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "ActivatedProtocolFeatures" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.ActivatedProtocolFeatures" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.ActivatedProtocolFeatures" , decoder : | buf : & [u8] | { let msg : ActivatedProtocolFeatures = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_PENDING_PRODUCER_SCHEDULE : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.PendingProducerSchedule")] impl :: prost_wkt :: MessageSerde for PendingProducerSchedule { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "PendingProducerSchedule" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.PendingProducerSchedule" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.PendingProducerSchedule" , decoder : | buf : & [u8] | { let msg : PendingProducerSchedule = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_PRODUCER_SCHEDULE : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.ProducerSchedule")] impl :: prost_wkt :: MessageSerde for ProducerSchedule { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "ProducerSchedule" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.ProducerSchedule" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.ProducerSchedule" , decoder : | buf : & [u8] | { let msg : ProducerSchedule = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_PRODUCER_KEY : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.ProducerKey")] impl :: prost_wkt :: MessageSerde for ProducerKey { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "ProducerKey" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.ProducerKey" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.ProducerKey" , decoder : | buf : & [u8] | { let msg : ProducerKey = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_PRODUCER_AUTHORITY_SCHEDULE : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.ProducerAuthoritySchedule")] impl :: prost_wkt :: MessageSerde for ProducerAuthoritySchedule { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "ProducerAuthoritySchedule" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.ProducerAuthoritySchedule" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.ProducerAuthoritySchedule" , decoder : | buf : & [u8] | { let msg : ProducerAuthoritySchedule = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_PRODUCER_AUTHORITY : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.ProducerAuthority")] impl :: prost_wkt :: MessageSerde for ProducerAuthority { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "ProducerAuthority" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.ProducerAuthority" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.ProducerAuthority" , decoder : | buf : & [u8] | { let msg : ProducerAuthority = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_BLOCK_SIGNING_AUTHORITY : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.BlockSigningAuthority")] impl :: prost_wkt :: MessageSerde for BlockSigningAuthority { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "BlockSigningAuthority" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.BlockSigningAuthority" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.BlockSigningAuthority" , decoder : | buf : & [u8] | { let msg : BlockSigningAuthority = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_BLOCK_SIGNING_AUTHORITY_V0 : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.BlockSigningAuthorityV0")] impl :: prost_wkt :: MessageSerde for BlockSigningAuthorityV0 { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "BlockSigningAuthorityV0" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.BlockSigningAuthorityV0" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.BlockSigningAuthorityV0" , decoder : | buf : & [u8] | { let msg : BlockSigningAuthorityV0 = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_BLOCK_ROOT_MERKLE : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.BlockRootMerkle")] impl :: prost_wkt :: MessageSerde for BlockRootMerkle { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "BlockRootMerkle" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.BlockRootMerkle" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.BlockRootMerkle" , decoder : | buf : & [u8] | { let msg : BlockRootMerkle = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_PRODUCER_TO_LAST_PRODUCED : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.ProducerToLastProduced")] impl :: prost_wkt :: MessageSerde for ProducerToLastProduced { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "ProducerToLastProduced" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.ProducerToLastProduced" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.ProducerToLastProduced" , decoder : | buf : & [u8] | { let msg : ProducerToLastProduced = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_PRODUCER_TO_LAST_IMPLIED_IRB : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.ProducerToLastImpliedIRB")] impl :: prost_wkt :: MessageSerde for ProducerToLastImpliedIrb { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "ProducerToLastImpliedIRB" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.ProducerToLastImpliedIRB" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.ProducerToLastImpliedIRB" , decoder : | buf : & [u8] | { let msg : ProducerToLastImpliedIrb = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_TRANSACTION_RECEIPT : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.TransactionReceipt")] impl :: prost_wkt :: MessageSerde for TransactionReceipt { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "TransactionReceipt" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.TransactionReceipt" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.TransactionReceipt" , decoder : | buf : & [u8] | { let msg : TransactionReceipt = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_PACKED_TRANSACTION : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.PackedTransaction")] impl :: prost_wkt :: MessageSerde for PackedTransaction { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "PackedTransaction" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.PackedTransaction" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.PackedTransaction" , decoder : | buf : & [u8] | { let msg : PackedTransaction = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_BLOCK_HEADER : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.BlockHeader")] impl :: prost_wkt :: MessageSerde for BlockHeader { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "BlockHeader" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.BlockHeader" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.BlockHeader" , decoder : | buf : & [u8] | { let msg : BlockHeader = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_TRANSACTION_EVENT : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.TransactionEvent")] impl :: prost_wkt :: MessageSerde for TransactionEvent { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "TransactionEvent" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.TransactionEvent" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.TransactionEvent" , decoder : | buf : & [u8] | { let msg : TransactionEvent = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_PUBLIC_KEYS : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.PublicKeys")] impl :: prost_wkt :: MessageSerde for PublicKeys { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "PublicKeys" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.PublicKeys" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.PublicKeys" , decoder : | buf : & [u8] | { let msg : PublicKeys = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_TRANSACTION_LIFECYCLE : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.TransactionLifecycle")] impl :: prost_wkt :: MessageSerde for TransactionLifecycle { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "TransactionLifecycle" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.TransactionLifecycle" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.TransactionLifecycle" , decoder : | buf : & [u8] | { let msg : TransactionLifecycle = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_SIGNED_TRANSACTION : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.SignedTransaction")] impl :: prost_wkt :: MessageSerde for SignedTransaction { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "SignedTransaction" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.SignedTransaction" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.SignedTransaction" , decoder : | buf : & [u8] | { let msg : SignedTransaction = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_TRANSACTION : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.Transaction")] impl :: prost_wkt :: MessageSerde for Transaction { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "Transaction" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.Transaction" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.Transaction" , decoder : | buf : & [u8] | { let msg : Transaction = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_TRANSACTION_HEADER : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.TransactionHeader")] impl :: prost_wkt :: MessageSerde for TransactionHeader { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "TransactionHeader" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.TransactionHeader" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.TransactionHeader" , decoder : | buf : & [u8] | { let msg : TransactionHeader = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_TRANSACTION_TRACE : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.TransactionTrace")] impl :: prost_wkt :: MessageSerde for TransactionTrace { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "TransactionTrace" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.TransactionTrace" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.TransactionTrace" , decoder : | buf : & [u8] | { let msg : TransactionTrace = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_TRANSACTION_RECEIPT_HEADER : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.TransactionReceiptHeader")] impl :: prost_wkt :: MessageSerde for TransactionReceiptHeader { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "TransactionReceiptHeader" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.TransactionReceiptHeader" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.TransactionReceiptHeader" , decoder : | buf : & [u8] | { let msg : TransactionReceiptHeader = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_ACTION : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.Action")] impl :: prost_wkt :: MessageSerde for Action { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "Action" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.Action" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.Action" , decoder : | buf : & [u8] | { let msg : Action = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_ACTION_TRACE : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.ActionTrace")] impl :: prost_wkt :: MessageSerde for ActionTrace { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "ActionTrace" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.ActionTrace" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.ActionTrace" , decoder : | buf : & [u8] | { let msg : ActionTrace = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_ACTION_RECEIPT : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.ActionReceipt")] impl :: prost_wkt :: MessageSerde for ActionReceipt { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "ActionReceipt" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.ActionReceipt" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.ActionReceipt" , decoder : | buf : & [u8] | { let msg : ActionReceipt = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_AUTH_SEQUENCE : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.AuthSequence")] impl :: prost_wkt :: MessageSerde for AuthSequence { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "AuthSequence" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.AuthSequence" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.AuthSequence" , decoder : | buf : & [u8] | { let msg : AuthSequence = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_ACCOUNT_RAM_DELTA : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.AccountRAMDelta")] impl :: prost_wkt :: MessageSerde for AccountRamDelta { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "AccountRAMDelta" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.AccountRAMDelta" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.AccountRAMDelta" , decoder : | buf : & [u8] | { let msg : AccountRamDelta = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_ACCOUNT_DELTA : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.AccountDelta")] impl :: prost_wkt :: MessageSerde for AccountDelta { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "AccountDelta" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.AccountDelta" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.AccountDelta" , decoder : | buf : & [u8] | { let msg : AccountDelta = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_EXTENSION : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.Extension")] impl :: prost_wkt :: MessageSerde for Extension { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "Extension" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.Extension" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.Extension" , decoder : | buf : & [u8] | { let msg : Extension = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_TRX_OP : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.TrxOp")] impl :: prost_wkt :: MessageSerde for TrxOp { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "TrxOp" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.TrxOp" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.TrxOp" , decoder : | buf : & [u8] | { let msg : TrxOp = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_DB_OP : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.DBOp")] impl :: prost_wkt :: MessageSerde for DbOp { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "DBOp" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.DBOp" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.DBOp" , decoder : | buf : & [u8] | { let msg : DbOp = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_RAM_OP : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.RAMOp")] impl :: prost_wkt :: MessageSerde for RamOp { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "RAMOp" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.RAMOp" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.RAMOp" , decoder : | buf : & [u8] | { let msg : RamOp = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_RAM_CORRECTION_OP : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.RAMCorrectionOp")] impl :: prost_wkt :: MessageSerde for RamCorrectionOp { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "RAMCorrectionOp" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.RAMCorrectionOp" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.RAMCorrectionOp" , decoder : | buf : & [u8] | { let msg : RamCorrectionOp = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_TABLE_OP : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.TableOp")] impl :: prost_wkt :: MessageSerde for TableOp { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "TableOp" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.TableOp" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.TableOp" , decoder : | buf : & [u8] | { let msg : TableOp = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_D_TRX_OP : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.DTrxOp")] impl :: prost_wkt :: MessageSerde for DTrxOp { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "DTrxOp" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.DTrxOp" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.DTrxOp" , decoder : | buf : & [u8] | { let msg : DTrxOp = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_EXT_D_TRX_OP : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.ExtDTrxOp")] impl :: prost_wkt :: MessageSerde for ExtDTrxOp { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "ExtDTrxOp" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.ExtDTrxOp" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.ExtDTrxOp" , decoder : | buf : & [u8] | { let msg : ExtDTrxOp = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_FEATURE_OP : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.FeatureOp")] impl :: prost_wkt :: MessageSerde for FeatureOp { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "FeatureOp" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.FeatureOp" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.FeatureOp" , decoder : | buf : & [u8] | { let msg : FeatureOp = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_CREATION_FLAT_NODE : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.CreationFlatNode")] impl :: prost_wkt :: MessageSerde for CreationFlatNode { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "CreationFlatNode" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.CreationFlatNode" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.CreationFlatNode" , decoder : | buf : & [u8] | { let msg : CreationFlatNode = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_PERM_OP : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.PermOp")] impl :: prost_wkt :: MessageSerde for PermOp { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "PermOp" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.PermOp" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.PermOp" , decoder : | buf : & [u8] | { let msg : PermOp = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_PERMISSION_OBJECT : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.PermissionObject")] impl :: prost_wkt :: MessageSerde for PermissionObject { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "PermissionObject" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.PermissionObject" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.PermissionObject" , decoder : | buf : & [u8] | { let msg : PermissionObject = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_PERMISSION : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.Permission")] impl :: prost_wkt :: MessageSerde for Permission { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "Permission" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.Permission" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.Permission" , decoder : | buf : & [u8] | { let msg : Permission = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_AUTHORITY : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.Authority")] impl :: prost_wkt :: MessageSerde for Authority { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "Authority" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.Authority" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.Authority" , decoder : | buf : & [u8] | { let msg : Authority = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_KEY_WEIGHT : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.KeyWeight")] impl :: prost_wkt :: MessageSerde for KeyWeight { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "KeyWeight" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.KeyWeight" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.KeyWeight" , decoder : | buf : & [u8] | { let msg : KeyWeight = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_PERMISSION_LEVEL : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.PermissionLevel")] impl :: prost_wkt :: MessageSerde for PermissionLevel { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "PermissionLevel" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.PermissionLevel" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.PermissionLevel" , decoder : | buf : & [u8] | { let msg : PermissionLevel = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_PERMISSION_LEVEL_WEIGHT : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.PermissionLevelWeight")] impl :: prost_wkt :: MessageSerde for PermissionLevelWeight { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "PermissionLevelWeight" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.PermissionLevelWeight" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.PermissionLevelWeight" , decoder : | buf : & [u8] | { let msg : PermissionLevelWeight = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_WAIT_WEIGHT : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.WaitWeight")] impl :: prost_wkt :: MessageSerde for WaitWeight { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "WaitWeight" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.WaitWeight" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.WaitWeight" , decoder : | buf : & [u8] | { let msg : WaitWeight = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_RLIMIT_OP : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.RlimitOp")] impl :: prost_wkt :: MessageSerde for RlimitOp { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "RlimitOp" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.RlimitOp" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.RlimitOp" , decoder : | buf : & [u8] | { let msg : RlimitOp = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_RLIMIT_STATE : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.RlimitState")] impl :: prost_wkt :: MessageSerde for RlimitState { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "RlimitState" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.RlimitState" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.RlimitState" , decoder : | buf : & [u8] | { let msg : RlimitState = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_RLIMIT_CONFIG : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.RlimitConfig")] impl :: prost_wkt :: MessageSerde for RlimitConfig { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "RlimitConfig" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.RlimitConfig" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.RlimitConfig" , decoder : | buf : & [u8] | { let msg : RlimitConfig = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_RLIMIT_ACCOUNT_LIMITS : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.RlimitAccountLimits")] impl :: prost_wkt :: MessageSerde for RlimitAccountLimits { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "RlimitAccountLimits" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.RlimitAccountLimits" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.RlimitAccountLimits" , decoder : | buf : & [u8] | { let msg : RlimitAccountLimits = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_RLIMIT_ACCOUNT_USAGE : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.RlimitAccountUsage")] impl :: prost_wkt :: MessageSerde for RlimitAccountUsage { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "RlimitAccountUsage" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.RlimitAccountUsage" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.RlimitAccountUsage" , decoder : | buf : & [u8] | { let msg : RlimitAccountUsage = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_USAGE_ACCUMULATOR : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.UsageAccumulator")] impl :: prost_wkt :: MessageSerde for UsageAccumulator { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "UsageAccumulator" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.UsageAccumulator" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.UsageAccumulator" , decoder : | buf : & [u8] | { let msg : UsageAccumulator = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_ELASTIC_LIMIT_PARAMETERS : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.ElasticLimitParameters")] impl :: prost_wkt :: MessageSerde for ElasticLimitParameters { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "ElasticLimitParameters" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.ElasticLimitParameters" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.ElasticLimitParameters" , decoder : | buf : & [u8] | { let msg : ElasticLimitParameters = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_RATIO : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.Ratio")] impl :: prost_wkt :: MessageSerde for Ratio { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "Ratio" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.Ratio" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.Ratio" , decoder : | buf : & [u8] | { let msg : Ratio = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_EXCEPTION : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.Exception")] impl :: prost_wkt :: MessageSerde for Exception { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "Exception" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.Exception" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.Exception" , decoder : | buf : & [u8] | { let msg : Exception = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_FEATURE : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.Feature")] impl :: prost_wkt :: MessageSerde for Feature { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "Feature" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.Feature" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.Feature" , decoder : | buf : & [u8] | { let msg : Feature = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_SUBJECTIVE_RESTRICTIONS : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.SubjectiveRestrictions")] impl :: prost_wkt :: MessageSerde for SubjectiveRestrictions { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "SubjectiveRestrictions" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.SubjectiveRestrictions" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.SubjectiveRestrictions" , decoder : | buf : & [u8] | { let msg : SubjectiveRestrictions = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_SPECIFICATION : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.Specification")] impl :: prost_wkt :: MessageSerde for Specification { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "Specification" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.Specification" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.Specification" , decoder : | buf : & [u8] | { let msg : Specification = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_ACCOUNT_CREATION_REF : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.AccountCreationRef")] impl :: prost_wkt :: MessageSerde for AccountCreationRef { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "AccountCreationRef" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.AccountCreationRef" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.AccountCreationRef" , decoder : | buf : & [u8] | { let msg : AccountCreationRef = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_HEADER_ONLY_BLOCK : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.HeaderOnlyBlock")] impl :: prost_wkt :: MessageSerde for HeaderOnlyBlock { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "HeaderOnlyBlock" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.HeaderOnlyBlock" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.HeaderOnlyBlock" , decoder : | buf : & [u8] | { let msg : HeaderOnlyBlock = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_TRANSACTION_TRACE_WITH_BLOCK_REF : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.TransactionTraceWithBlockRef")] impl :: prost_wkt :: MessageSerde for TransactionTraceWithBlockRef { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "TransactionTraceWithBlockRef" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.TransactionTraceWithBlockRef" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.TransactionTraceWithBlockRef" , decoder : | buf : & [u8] | { let msg : TransactionTraceWithBlockRef = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_BLOCK_REF : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.BlockRef")] impl :: prost_wkt :: MessageSerde for BlockRef { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "BlockRef" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.BlockRef" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.BlockRef" , decoder : | buf : & [u8] | { let msg : BlockRef = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_ACTION_TRACES : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.ActionTraces")] impl :: prost_wkt :: MessageSerde for ActionTraces { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "ActionTraces" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.ActionTraces" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.ActionTraces" , decoder : | buf : & [u8] | { let msg : ActionTraces = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_TRANSACTION_TRACES : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.TransactionTraces")] impl :: prost_wkt :: MessageSerde for TransactionTraces { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "TransactionTraces" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.TransactionTraces" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.TransactionTraces" , decoder : | buf : & [u8] | { let msg : TransactionTraces = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_DB_OPS : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.DBOps")] impl :: prost_wkt :: MessageSerde for DbOps { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "DBOps" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.DBOps" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.DBOps" , decoder : | buf : & [u8] | { let msg : DbOps = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_BLOCK : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.Block")] impl :: prost_wkt :: MessageSerde for Block { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "Block" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.Block" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.Block" , decoder : | buf : & [u8] | { let msg : Block = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_BLOCK_WITH_REFS : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.BlockWithRefs")] impl :: prost_wkt :: MessageSerde for BlockWithRefs { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "BlockWithRefs" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.BlockWithRefs" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.BlockWithRefs" , decoder : | buf : & [u8] | { let msg : BlockWithRefs = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_TRANSACTION_REFS : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.TransactionRefs")] impl :: prost_wkt :: MessageSerde for TransactionRefs { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "TransactionRefs" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.TransactionRefs" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.TransactionRefs" , decoder : | buf : & [u8] | { let msg : TransactionRefs = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_ACTIVATED_PROTOCOL_FEATURES : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.ActivatedProtocolFeatures")] impl :: prost_wkt :: MessageSerde for ActivatedProtocolFeatures { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "ActivatedProtocolFeatures" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.ActivatedProtocolFeatures" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.ActivatedProtocolFeatures" , decoder : | buf : & [u8] | { let msg : ActivatedProtocolFeatures = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_PENDING_PRODUCER_SCHEDULE : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.PendingProducerSchedule")] impl :: prost_wkt :: MessageSerde for PendingProducerSchedule { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "PendingProducerSchedule" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.PendingProducerSchedule" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.PendingProducerSchedule" , decoder : | buf : & [u8] | { let msg : PendingProducerSchedule = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_PRODUCER_SCHEDULE : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.ProducerSchedule")] impl :: prost_wkt :: MessageSerde for ProducerSchedule { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "ProducerSchedule" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.ProducerSchedule" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.ProducerSchedule" , decoder : | buf : & [u8] | { let msg : ProducerSchedule = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_PRODUCER_KEY : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.ProducerKey")] impl :: prost_wkt :: MessageSerde for ProducerKey { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "ProducerKey" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.ProducerKey" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.ProducerKey" , decoder : | buf : & [u8] | { let msg : ProducerKey = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_PRODUCER_AUTHORITY_SCHEDULE : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.ProducerAuthoritySchedule")] impl :: prost_wkt :: MessageSerde for ProducerAuthoritySchedule { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "ProducerAuthoritySchedule" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.ProducerAuthoritySchedule" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.ProducerAuthoritySchedule" , decoder : | buf : & [u8] | { let msg : ProducerAuthoritySchedule = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_PRODUCER_AUTHORITY : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.ProducerAuthority")] impl :: prost_wkt :: MessageSerde for ProducerAuthority { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "ProducerAuthority" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.ProducerAuthority" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.ProducerAuthority" , decoder : | buf : & [u8] | { let msg : ProducerAuthority = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_BLOCK_SIGNING_AUTHORITY : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.BlockSigningAuthority")] impl :: prost_wkt :: MessageSerde for BlockSigningAuthority { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "BlockSigningAuthority" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.BlockSigningAuthority" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.BlockSigningAuthority" , decoder : | buf : & [u8] | { let msg : BlockSigningAuthority = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_BLOCK_SIGNING_AUTHORITY_V0 : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.BlockSigningAuthorityV0")] impl :: prost_wkt :: MessageSerde for BlockSigningAuthorityV0 { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "BlockSigningAuthorityV0" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.BlockSigningAuthorityV0" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.BlockSigningAuthorityV0" , decoder : | buf : & [u8] | { let msg : BlockSigningAuthorityV0 = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_BLOCK_ROOT_MERKLE : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.BlockRootMerkle")] impl :: prost_wkt :: MessageSerde for BlockRootMerkle { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "BlockRootMerkle" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.BlockRootMerkle" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.BlockRootMerkle" , decoder : | buf : & [u8] | { let msg : BlockRootMerkle = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_PRODUCER_TO_LAST_PRODUCED : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.ProducerToLastProduced")] impl :: prost_wkt :: MessageSerde for ProducerToLastProduced { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "ProducerToLastProduced" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.ProducerToLastProduced" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.ProducerToLastProduced" , decoder : | buf : & [u8] | { let msg : ProducerToLastProduced = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_PRODUCER_TO_LAST_IMPLIED_IRB : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.ProducerToLastImpliedIRB")] impl :: prost_wkt :: MessageSerde for ProducerToLastImpliedIrb { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "ProducerToLastImpliedIRB" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.ProducerToLastImpliedIRB" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.ProducerToLastImpliedIRB" , decoder : | buf : & [u8] | { let msg : ProducerToLastImpliedIrb = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_TRANSACTION_RECEIPT : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.TransactionReceipt")] impl :: prost_wkt :: MessageSerde for TransactionReceipt { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "TransactionReceipt" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.TransactionReceipt" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.TransactionReceipt" , decoder : | buf : & [u8] | { let msg : TransactionReceipt = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_PACKED_TRANSACTION : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.PackedTransaction")] impl :: prost_wkt :: MessageSerde for PackedTransaction { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "PackedTransaction" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.PackedTransaction" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.PackedTransaction" , decoder : | buf : & [u8] | { let msg : PackedTransaction = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_BLOCK_HEADER : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.BlockHeader")] impl :: prost_wkt :: MessageSerde for BlockHeader { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "BlockHeader" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.BlockHeader" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.BlockHeader" , decoder : | buf : & [u8] | { let msg : BlockHeader = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_TRANSACTION_EVENT : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.TransactionEvent")] impl :: prost_wkt :: MessageSerde for TransactionEvent { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "TransactionEvent" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.TransactionEvent" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.TransactionEvent" , decoder : | buf : & [u8] | { let msg : TransactionEvent = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_PUBLIC_KEYS : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.PublicKeys")] impl :: prost_wkt :: MessageSerde for PublicKeys { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "PublicKeys" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.PublicKeys" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.PublicKeys" , decoder : | buf : & [u8] | { let msg : PublicKeys = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_TRANSACTION_LIFECYCLE : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.TransactionLifecycle")] impl :: prost_wkt :: MessageSerde for TransactionLifecycle { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "TransactionLifecycle" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.TransactionLifecycle" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.TransactionLifecycle" , decoder : | buf : & [u8] | { let msg : TransactionLifecycle = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_SIGNED_TRANSACTION : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.SignedTransaction")] impl :: prost_wkt :: MessageSerde for SignedTransaction { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "SignedTransaction" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.SignedTransaction" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.SignedTransaction" , decoder : | buf : & [u8] | { let msg : SignedTransaction = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_TRANSACTION : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.Transaction")] impl :: prost_wkt :: MessageSerde for Transaction { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "Transaction" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.Transaction" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.Transaction" , decoder : | buf : & [u8] | { let msg : Transaction = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_TRANSACTION_HEADER : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.TransactionHeader")] impl :: prost_wkt :: MessageSerde for TransactionHeader { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "TransactionHeader" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.TransactionHeader" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.TransactionHeader" , decoder : | buf : & [u8] | { let msg : TransactionHeader = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_TRANSACTION_TRACE : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.TransactionTrace")] impl :: prost_wkt :: MessageSerde for TransactionTrace { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "TransactionTrace" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.TransactionTrace" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.TransactionTrace" , decoder : | buf : & [u8] | { let msg : TransactionTrace = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_TRANSACTION_RECEIPT_HEADER : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.TransactionReceiptHeader")] impl :: prost_wkt :: MessageSerde for TransactionReceiptHeader { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "TransactionReceiptHeader" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.TransactionReceiptHeader" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.TransactionReceiptHeader" , decoder : | buf : & [u8] | { let msg : TransactionReceiptHeader = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_ACTION : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.Action")] impl :: prost_wkt :: MessageSerde for Action { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "Action" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.Action" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.Action" , decoder : | buf : & [u8] | { let msg : Action = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_ACTION_TRACE : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.ActionTrace")] impl :: prost_wkt :: MessageSerde for ActionTrace { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "ActionTrace" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.ActionTrace" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.ActionTrace" , decoder : | buf : & [u8] | { let msg : ActionTrace = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_ACTION_RECEIPT : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.ActionReceipt")] impl :: prost_wkt :: MessageSerde for ActionReceipt { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "ActionReceipt" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.ActionReceipt" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.ActionReceipt" , decoder : | buf : & [u8] | { let msg : ActionReceipt = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_AUTH_SEQUENCE : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.AuthSequence")] impl :: prost_wkt :: MessageSerde for AuthSequence { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "AuthSequence" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.AuthSequence" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.AuthSequence" , decoder : | buf : & [u8] | { let msg : AuthSequence = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_ACCOUNT_RAM_DELTA : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.AccountRAMDelta")] impl :: prost_wkt :: MessageSerde for AccountRamDelta { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "AccountRAMDelta" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.AccountRAMDelta" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.AccountRAMDelta" , decoder : | buf : & [u8] | { let msg : AccountRamDelta = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_ACCOUNT_DELTA : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.AccountDelta")] impl :: prost_wkt :: MessageSerde for AccountDelta { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "AccountDelta" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.AccountDelta" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.AccountDelta" , decoder : | buf : & [u8] | { let msg : AccountDelta = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_EXTENSION : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.Extension")] impl :: prost_wkt :: MessageSerde for Extension { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "Extension" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.Extension" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.Extension" , decoder : | buf : & [u8] | { let msg : Extension = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_TRX_OP : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.TrxOp")] impl :: prost_wkt :: MessageSerde for TrxOp { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "TrxOp" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.TrxOp" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.TrxOp" , decoder : | buf : & [u8] | { let msg : TrxOp = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_DB_OP : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.DBOp")] impl :: prost_wkt :: MessageSerde for DbOp { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "DBOp" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.DBOp" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.DBOp" , decoder : | buf : & [u8] | { let msg : DbOp = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_RAM_OP : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.RAMOp")] impl :: prost_wkt :: MessageSerde for RamOp { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "RAMOp" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.RAMOp" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.RAMOp" , decoder : | buf : & [u8] | { let msg : RamOp = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_RAM_CORRECTION_OP : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.RAMCorrectionOp")] impl :: prost_wkt :: MessageSerde for RamCorrectionOp { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "RAMCorrectionOp" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.RAMCorrectionOp" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.RAMCorrectionOp" , decoder : | buf : & [u8] | { let msg : RamCorrectionOp = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_TABLE_OP : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.TableOp")] impl :: prost_wkt :: MessageSerde for TableOp { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "TableOp" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.TableOp" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.TableOp" , decoder : | buf : & [u8] | { let msg : TableOp = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_D_TRX_OP : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.DTrxOp")] impl :: prost_wkt :: MessageSerde for DTrxOp { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "DTrxOp" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.DTrxOp" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.DTrxOp" , decoder : | buf : & [u8] | { let msg : DTrxOp = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_EXT_D_TRX_OP : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.ExtDTrxOp")] impl :: prost_wkt :: MessageSerde for ExtDTrxOp { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "ExtDTrxOp" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.ExtDTrxOp" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.ExtDTrxOp" , decoder : | buf : & [u8] | { let msg : ExtDTrxOp = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_FEATURE_OP : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.FeatureOp")] impl :: prost_wkt :: MessageSerde for FeatureOp { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "FeatureOp" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.FeatureOp" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.FeatureOp" , decoder : | buf : & [u8] | { let msg : FeatureOp = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_CREATION_FLAT_NODE : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.CreationFlatNode")] impl :: prost_wkt :: MessageSerde for CreationFlatNode { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "CreationFlatNode" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.CreationFlatNode" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.CreationFlatNode" , decoder : | buf : & [u8] | { let msg : CreationFlatNode = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_PERM_OP : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.PermOp")] impl :: prost_wkt :: MessageSerde for PermOp { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "PermOp" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.PermOp" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.PermOp" , decoder : | buf : & [u8] | { let msg : PermOp = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_PERMISSION_OBJECT : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.PermissionObject")] impl :: prost_wkt :: MessageSerde for PermissionObject { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "PermissionObject" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.PermissionObject" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.PermissionObject" , decoder : | buf : & [u8] | { let msg : PermissionObject = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_PERMISSION : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.Permission")] impl :: prost_wkt :: MessageSerde for Permission { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "Permission" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.Permission" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.Permission" , decoder : | buf : & [u8] | { let msg : Permission = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_AUTHORITY : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.Authority")] impl :: prost_wkt :: MessageSerde for Authority { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "Authority" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.Authority" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.Authority" , decoder : | buf : & [u8] | { let msg : Authority = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_KEY_WEIGHT : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.KeyWeight")] impl :: prost_wkt :: MessageSerde for KeyWeight { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "KeyWeight" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.KeyWeight" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.KeyWeight" , decoder : | buf : & [u8] | { let msg : KeyWeight = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_PERMISSION_LEVEL : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.PermissionLevel")] impl :: prost_wkt :: MessageSerde for PermissionLevel { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "PermissionLevel" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.PermissionLevel" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.PermissionLevel" , decoder : | buf : & [u8] | { let msg : PermissionLevel = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_PERMISSION_LEVEL_WEIGHT : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.PermissionLevelWeight")] impl :: prost_wkt :: MessageSerde for PermissionLevelWeight { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "PermissionLevelWeight" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.PermissionLevelWeight" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.PermissionLevelWeight" , decoder : | buf : & [u8] | { let msg : PermissionLevelWeight = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_WAIT_WEIGHT : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.WaitWeight")] impl :: prost_wkt :: MessageSerde for WaitWeight { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "WaitWeight" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.WaitWeight" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.WaitWeight" , decoder : | buf : & [u8] | { let msg : WaitWeight = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_RLIMIT_OP : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.RlimitOp")] impl :: prost_wkt :: MessageSerde for RlimitOp { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "RlimitOp" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.RlimitOp" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.RlimitOp" , decoder : | buf : & [u8] | { let msg : RlimitOp = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_RLIMIT_STATE : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.RlimitState")] impl :: prost_wkt :: MessageSerde for RlimitState { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "RlimitState" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.RlimitState" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.RlimitState" , decoder : | buf : & [u8] | { let msg : RlimitState = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_RLIMIT_CONFIG : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.RlimitConfig")] impl :: prost_wkt :: MessageSerde for RlimitConfig { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "RlimitConfig" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.RlimitConfig" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.RlimitConfig" , decoder : | buf : & [u8] | { let msg : RlimitConfig = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_RLIMIT_ACCOUNT_LIMITS : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.RlimitAccountLimits")] impl :: prost_wkt :: MessageSerde for RlimitAccountLimits { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "RlimitAccountLimits" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.RlimitAccountLimits" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.RlimitAccountLimits" , decoder : | buf : & [u8] | { let msg : RlimitAccountLimits = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_RLIMIT_ACCOUNT_USAGE : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.RlimitAccountUsage")] impl :: prost_wkt :: MessageSerde for RlimitAccountUsage { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "RlimitAccountUsage" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.RlimitAccountUsage" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.RlimitAccountUsage" , decoder : | buf : & [u8] | { let msg : RlimitAccountUsage = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_USAGE_ACCUMULATOR : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.UsageAccumulator")] impl :: prost_wkt :: MessageSerde for UsageAccumulator { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "UsageAccumulator" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.UsageAccumulator" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.UsageAccumulator" , decoder : | buf : & [u8] | { let msg : UsageAccumulator = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_ELASTIC_LIMIT_PARAMETERS : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.ElasticLimitParameters")] impl :: prost_wkt :: MessageSerde for ElasticLimitParameters { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "ElasticLimitParameters" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.ElasticLimitParameters" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.ElasticLimitParameters" , decoder : | buf : & [u8] | { let msg : ElasticLimitParameters = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_RATIO : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.Ratio")] impl :: prost_wkt :: MessageSerde for Ratio { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "Ratio" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.Ratio" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.Ratio" , decoder : | buf : & [u8] | { let msg : Ratio = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_EXCEPTION : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.Exception")] impl :: prost_wkt :: MessageSerde for Exception { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "Exception" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.Exception" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.Exception" , decoder : | buf : & [u8] | { let msg : Exception = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_FEATURE : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.Feature")] impl :: prost_wkt :: MessageSerde for Feature { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "Feature" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.Feature" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.Feature" , decoder : | buf : & [u8] | { let msg : Feature = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_SUBJECTIVE_RESTRICTIONS : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.SubjectiveRestrictions")] impl :: prost_wkt :: MessageSerde for SubjectiveRestrictions { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "SubjectiveRestrictions" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.SubjectiveRestrictions" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.SubjectiveRestrictions" , decoder : | buf : & [u8] | { let msg : SubjectiveRestrictions = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_SPECIFICATION : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.Specification")] impl :: prost_wkt :: MessageSerde for Specification { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "Specification" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.Specification" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.Specification" , decoder : | buf : & [u8] | { let msg : Specification = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_ACCOUNT_CREATION_REF : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.AccountCreationRef")] impl :: prost_wkt :: MessageSerde for AccountCreationRef { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "AccountCreationRef" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.AccountCreationRef" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.AccountCreationRef" , decoder : | buf : & [u8] | { let msg : AccountCreationRef = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_HEADER_ONLY_BLOCK : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.HeaderOnlyBlock")] impl :: prost_wkt :: MessageSerde for HeaderOnlyBlock { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "HeaderOnlyBlock" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.HeaderOnlyBlock" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.HeaderOnlyBlock" , decoder : | buf : & [u8] | { let msg : HeaderOnlyBlock = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_TRANSACTION_TRACE_WITH_BLOCK_REF : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.TransactionTraceWithBlockRef")] impl :: prost_wkt :: MessageSerde for TransactionTraceWithBlockRef { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "TransactionTraceWithBlockRef" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.TransactionTraceWithBlockRef" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.TransactionTraceWithBlockRef" , decoder : | buf : & [u8] | { let msg : TransactionTraceWithBlockRef = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_BLOCK_REF : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.BlockRef")] impl :: prost_wkt :: MessageSerde for BlockRef { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "BlockRef" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.BlockRef" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.BlockRef" , decoder : | buf : & [u8] | { let msg : BlockRef = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_ACTION_TRACES : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.ActionTraces")] impl :: prost_wkt :: MessageSerde for ActionTraces { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "ActionTraces" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.ActionTraces" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.ActionTraces" , decoder : | buf : & [u8] | { let msg : ActionTraces = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_TRANSACTION_TRACES : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.TransactionTraces")] impl :: prost_wkt :: MessageSerde for TransactionTraces { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "TransactionTraces" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.TransactionTraces" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.TransactionTraces" , decoder : | buf : & [u8] | { let msg : TransactionTraces = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_DB_OPS : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.DBOps")] impl :: prost_wkt :: MessageSerde for DbOps { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "DBOps" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.DBOps" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.DBOps" , decoder : | buf : & [u8] | { let msg : DbOps = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_BLOCK : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.Block")] impl :: prost_wkt :: MessageSerde for Block { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "Block" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.Block" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.Block" , decoder : | buf : & [u8] | { let msg : Block = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_BLOCK_WITH_REFS : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.BlockWithRefs")] impl :: prost_wkt :: MessageSerde for BlockWithRefs { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "BlockWithRefs" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.BlockWithRefs" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.BlockWithRefs" , decoder : | buf : & [u8] | { let msg : BlockWithRefs = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_TRANSACTION_REFS : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.TransactionRefs")] impl :: prost_wkt :: MessageSerde for TransactionRefs { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "TransactionRefs" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.TransactionRefs" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.TransactionRefs" , decoder : | buf : & [u8] | { let msg : TransactionRefs = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_ACTIVATED_PROTOCOL_FEATURES : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.ActivatedProtocolFeatures")] impl :: prost_wkt :: MessageSerde for ActivatedProtocolFeatures { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "ActivatedProtocolFeatures" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.ActivatedProtocolFeatures" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.ActivatedProtocolFeatures" , decoder : | buf : & [u8] | { let msg : ActivatedProtocolFeatures = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_PENDING_PRODUCER_SCHEDULE : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.PendingProducerSchedule")] impl :: prost_wkt :: MessageSerde for PendingProducerSchedule { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "PendingProducerSchedule" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.PendingProducerSchedule" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.PendingProducerSchedule" , decoder : | buf : & [u8] | { let msg : PendingProducerSchedule = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_PRODUCER_SCHEDULE : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.ProducerSchedule")] impl :: prost_wkt :: MessageSerde for ProducerSchedule { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "ProducerSchedule" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.ProducerSchedule" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.ProducerSchedule" , decoder : | buf : & [u8] | { let msg : ProducerSchedule = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_PRODUCER_KEY : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.ProducerKey")] impl :: prost_wkt :: MessageSerde for ProducerKey { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "ProducerKey" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.ProducerKey" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.ProducerKey" , decoder : | buf : & [u8] | { let msg : ProducerKey = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_PRODUCER_AUTHORITY_SCHEDULE : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.ProducerAuthoritySchedule")] impl :: prost_wkt :: MessageSerde for ProducerAuthoritySchedule { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "ProducerAuthoritySchedule" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.ProducerAuthoritySchedule" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.ProducerAuthoritySchedule" , decoder : | buf : & [u8] | { let msg : ProducerAuthoritySchedule = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_PRODUCER_AUTHORITY : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.ProducerAuthority")] impl :: prost_wkt :: MessageSerde for ProducerAuthority { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "ProducerAuthority" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.ProducerAuthority" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.ProducerAuthority" , decoder : | buf : & [u8] | { let msg : ProducerAuthority = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_BLOCK_SIGNING_AUTHORITY : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.BlockSigningAuthority")] impl :: prost_wkt :: MessageSerde for BlockSigningAuthority { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "BlockSigningAuthority" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.BlockSigningAuthority" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.BlockSigningAuthority" , decoder : | buf : & [u8] | { let msg : BlockSigningAuthority = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_BLOCK_SIGNING_AUTHORITY_V0 : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.BlockSigningAuthorityV0")] impl :: prost_wkt :: MessageSerde for BlockSigningAuthorityV0 { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "BlockSigningAuthorityV0" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.BlockSigningAuthorityV0" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.BlockSigningAuthorityV0" , decoder : | buf : & [u8] | { let msg : BlockSigningAuthorityV0 = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_BLOCK_ROOT_MERKLE : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.BlockRootMerkle")] impl :: prost_wkt :: MessageSerde for BlockRootMerkle { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "BlockRootMerkle" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.BlockRootMerkle" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.BlockRootMerkle" , decoder : | buf : & [u8] | { let msg : BlockRootMerkle = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_PRODUCER_TO_LAST_PRODUCED : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.ProducerToLastProduced")] impl :: prost_wkt :: MessageSerde for ProducerToLastProduced { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "ProducerToLastProduced" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.ProducerToLastProduced" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.ProducerToLastProduced" , decoder : | buf : & [u8] | { let msg : ProducerToLastProduced = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_PRODUCER_TO_LAST_IMPLIED_IRB : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.ProducerToLastImpliedIRB")] impl :: prost_wkt :: MessageSerde for ProducerToLastImpliedIrb { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "ProducerToLastImpliedIRB" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.ProducerToLastImpliedIRB" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.ProducerToLastImpliedIRB" , decoder : | buf : & [u8] | { let msg : ProducerToLastImpliedIrb = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_TRANSACTION_RECEIPT : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.TransactionReceipt")] impl :: prost_wkt :: MessageSerde for TransactionReceipt { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "TransactionReceipt" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.TransactionReceipt" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.TransactionReceipt" , decoder : | buf : & [u8] | { let msg : TransactionReceipt = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_PACKED_TRANSACTION : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.PackedTransaction")] impl :: prost_wkt :: MessageSerde for PackedTransaction { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "PackedTransaction" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.PackedTransaction" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.PackedTransaction" , decoder : | buf : & [u8] | { let msg : PackedTransaction = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_BLOCK_HEADER : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.BlockHeader")] impl :: prost_wkt :: MessageSerde for BlockHeader { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "BlockHeader" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.BlockHeader" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.BlockHeader" , decoder : | buf : & [u8] | { let msg : BlockHeader = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_TRANSACTION_EVENT : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.TransactionEvent")] impl :: prost_wkt :: MessageSerde for TransactionEvent { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "TransactionEvent" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.TransactionEvent" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.TransactionEvent" , decoder : | buf : & [u8] | { let msg : TransactionEvent = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_PUBLIC_KEYS : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.PublicKeys")] impl :: prost_wkt :: MessageSerde for PublicKeys { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "PublicKeys" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.PublicKeys" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.PublicKeys" , decoder : | buf : & [u8] | { let msg : PublicKeys = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_TRANSACTION_LIFECYCLE : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.TransactionLifecycle")] impl :: prost_wkt :: MessageSerde for TransactionLifecycle { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "TransactionLifecycle" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.TransactionLifecycle" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.TransactionLifecycle" , decoder : | buf : & [u8] | { let msg : TransactionLifecycle = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_SIGNED_TRANSACTION : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.SignedTransaction")] impl :: prost_wkt :: MessageSerde for SignedTransaction { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "SignedTransaction" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.SignedTransaction" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.SignedTransaction" , decoder : | buf : & [u8] | { let msg : SignedTransaction = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_TRANSACTION : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.Transaction")] impl :: prost_wkt :: MessageSerde for Transaction { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "Transaction" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.Transaction" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.Transaction" , decoder : | buf : & [u8] | { let msg : Transaction = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_TRANSACTION_HEADER : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.TransactionHeader")] impl :: prost_wkt :: MessageSerde for TransactionHeader { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "TransactionHeader" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.TransactionHeader" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.TransactionHeader" , decoder : | buf : & [u8] | { let msg : TransactionHeader = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_TRANSACTION_TRACE : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.TransactionTrace")] impl :: prost_wkt :: MessageSerde for TransactionTrace { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "TransactionTrace" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.TransactionTrace" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.TransactionTrace" , decoder : | buf : & [u8] | { let msg : TransactionTrace = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_TRANSACTION_RECEIPT_HEADER : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.TransactionReceiptHeader")] impl :: prost_wkt :: MessageSerde for TransactionReceiptHeader { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "TransactionReceiptHeader" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.TransactionReceiptHeader" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.TransactionReceiptHeader" , decoder : | buf : & [u8] | { let msg : TransactionReceiptHeader = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_ACTION : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.Action")] impl :: prost_wkt :: MessageSerde for Action { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "Action" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.Action" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.Action" , decoder : | buf : & [u8] | { let msg : Action = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_ACTION_TRACE : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.ActionTrace")] impl :: prost_wkt :: MessageSerde for ActionTrace { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "ActionTrace" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.ActionTrace" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.ActionTrace" , decoder : | buf : & [u8] | { let msg : ActionTrace = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_ACTION_RECEIPT : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.ActionReceipt")] impl :: prost_wkt :: MessageSerde for ActionReceipt { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "ActionReceipt" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.ActionReceipt" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.ActionReceipt" , decoder : | buf : & [u8] | { let msg : ActionReceipt = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_AUTH_SEQUENCE : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.AuthSequence")] impl :: prost_wkt :: MessageSerde for AuthSequence { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "AuthSequence" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.AuthSequence" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.AuthSequence" , decoder : | buf : & [u8] | { let msg : AuthSequence = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_ACCOUNT_RAM_DELTA : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.AccountRAMDelta")] impl :: prost_wkt :: MessageSerde for AccountRamDelta { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "AccountRAMDelta" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.AccountRAMDelta" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.AccountRAMDelta" , decoder : | buf : & [u8] | { let msg : AccountRamDelta = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_ACCOUNT_DELTA : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.AccountDelta")] impl :: prost_wkt :: MessageSerde for AccountDelta { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "AccountDelta" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.AccountDelta" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.AccountDelta" , decoder : | buf : & [u8] | { let msg : AccountDelta = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_EXTENSION : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.Extension")] impl :: prost_wkt :: MessageSerde for Extension { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "Extension" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.Extension" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.Extension" , decoder : | buf : & [u8] | { let msg : Extension = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_TRX_OP : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.TrxOp")] impl :: prost_wkt :: MessageSerde for TrxOp { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "TrxOp" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.TrxOp" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.TrxOp" , decoder : | buf : & [u8] | { let msg : TrxOp = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_DB_OP : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.DBOp")] impl :: prost_wkt :: MessageSerde for DbOp { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "DBOp" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.DBOp" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.DBOp" , decoder : | buf : & [u8] | { let msg : DbOp = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_RAM_OP : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.RAMOp")] impl :: prost_wkt :: MessageSerde for RamOp { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "RAMOp" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.RAMOp" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.RAMOp" , decoder : | buf : & [u8] | { let msg : RamOp = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_RAM_CORRECTION_OP : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.RAMCorrectionOp")] impl :: prost_wkt :: MessageSerde for RamCorrectionOp { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "RAMCorrectionOp" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.RAMCorrectionOp" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.RAMCorrectionOp" , decoder : | buf : & [u8] | { let msg : RamCorrectionOp = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_TABLE_OP : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.TableOp")] impl :: prost_wkt :: MessageSerde for TableOp { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "TableOp" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.TableOp" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.TableOp" , decoder : | buf : & [u8] | { let msg : TableOp = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_D_TRX_OP : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.DTrxOp")] impl :: prost_wkt :: MessageSerde for DTrxOp { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "DTrxOp" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.DTrxOp" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.DTrxOp" , decoder : | buf : & [u8] | { let msg : DTrxOp = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_EXT_D_TRX_OP : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.ExtDTrxOp")] impl :: prost_wkt :: MessageSerde for ExtDTrxOp { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "ExtDTrxOp" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.ExtDTrxOp" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.ExtDTrxOp" , decoder : | buf : & [u8] | { let msg : ExtDTrxOp = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_FEATURE_OP : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.FeatureOp")] impl :: prost_wkt :: MessageSerde for FeatureOp { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "FeatureOp" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.FeatureOp" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.FeatureOp" , decoder : | buf : & [u8] | { let msg : FeatureOp = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_CREATION_FLAT_NODE : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.CreationFlatNode")] impl :: prost_wkt :: MessageSerde for CreationFlatNode { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "CreationFlatNode" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.CreationFlatNode" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.CreationFlatNode" , decoder : | buf : & [u8] | { let msg : CreationFlatNode = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_PERM_OP : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.PermOp")] impl :: prost_wkt :: MessageSerde for PermOp { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "PermOp" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.PermOp" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.PermOp" , decoder : | buf : & [u8] | { let msg : PermOp = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_PERMISSION_OBJECT : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.PermissionObject")] impl :: prost_wkt :: MessageSerde for PermissionObject { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "PermissionObject" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.PermissionObject" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.PermissionObject" , decoder : | buf : & [u8] | { let msg : PermissionObject = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_PERMISSION : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.Permission")] impl :: prost_wkt :: MessageSerde for Permission { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "Permission" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.Permission" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.Permission" , decoder : | buf : & [u8] | { let msg : Permission = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_AUTHORITY : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.Authority")] impl :: prost_wkt :: MessageSerde for Authority { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "Authority" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.Authority" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.Authority" , decoder : | buf : & [u8] | { let msg : Authority = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_KEY_WEIGHT : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.KeyWeight")] impl :: prost_wkt :: MessageSerde for KeyWeight { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "KeyWeight" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.KeyWeight" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.KeyWeight" , decoder : | buf : & [u8] | { let msg : KeyWeight = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_PERMISSION_LEVEL : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.PermissionLevel")] impl :: prost_wkt :: MessageSerde for PermissionLevel { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "PermissionLevel" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.PermissionLevel" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.PermissionLevel" , decoder : | buf : & [u8] | { let msg : PermissionLevel = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_PERMISSION_LEVEL_WEIGHT : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.PermissionLevelWeight")] impl :: prost_wkt :: MessageSerde for PermissionLevelWeight { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "PermissionLevelWeight" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.PermissionLevelWeight" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.PermissionLevelWeight" , decoder : | buf : & [u8] | { let msg : PermissionLevelWeight = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_WAIT_WEIGHT : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.WaitWeight")] impl :: prost_wkt :: MessageSerde for WaitWeight { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "WaitWeight" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.WaitWeight" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.WaitWeight" , decoder : | buf : & [u8] | { let msg : WaitWeight = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_RLIMIT_OP : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.RlimitOp")] impl :: prost_wkt :: MessageSerde for RlimitOp { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "RlimitOp" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.RlimitOp" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.RlimitOp" , decoder : | buf : & [u8] | { let msg : RlimitOp = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_RLIMIT_STATE : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.RlimitState")] impl :: prost_wkt :: MessageSerde for RlimitState { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "RlimitState" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.RlimitState" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.RlimitState" , decoder : | buf : & [u8] | { let msg : RlimitState = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_RLIMIT_CONFIG : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.RlimitConfig")] impl :: prost_wkt :: MessageSerde for RlimitConfig { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "RlimitConfig" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.RlimitConfig" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.RlimitConfig" , decoder : | buf : & [u8] | { let msg : RlimitConfig = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_RLIMIT_ACCOUNT_LIMITS : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.RlimitAccountLimits")] impl :: prost_wkt :: MessageSerde for RlimitAccountLimits { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "RlimitAccountLimits" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.RlimitAccountLimits" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.RlimitAccountLimits" , decoder : | buf : & [u8] | { let msg : RlimitAccountLimits = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_RLIMIT_ACCOUNT_USAGE : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.RlimitAccountUsage")] impl :: prost_wkt :: MessageSerde for RlimitAccountUsage { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "RlimitAccountUsage" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.RlimitAccountUsage" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.RlimitAccountUsage" , decoder : | buf : & [u8] | { let msg : RlimitAccountUsage = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_USAGE_ACCUMULATOR : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.UsageAccumulator")] impl :: prost_wkt :: MessageSerde for UsageAccumulator { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "UsageAccumulator" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.UsageAccumulator" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.UsageAccumulator" , decoder : | buf : & [u8] | { let msg : UsageAccumulator = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_ELASTIC_LIMIT_PARAMETERS : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.ElasticLimitParameters")] impl :: prost_wkt :: MessageSerde for ElasticLimitParameters { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "ElasticLimitParameters" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.ElasticLimitParameters" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.ElasticLimitParameters" , decoder : | buf : & [u8] | { let msg : ElasticLimitParameters = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_RATIO : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.Ratio")] impl :: prost_wkt :: MessageSerde for Ratio { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "Ratio" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.Ratio" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.Ratio" , decoder : | buf : & [u8] | { let msg : Ratio = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_EXCEPTION : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.Exception")] impl :: prost_wkt :: MessageSerde for Exception { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "Exception" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.Exception" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.Exception" , decoder : | buf : & [u8] | { let msg : Exception = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_FEATURE : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.Feature")] impl :: prost_wkt :: MessageSerde for Feature { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "Feature" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.Feature" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.Feature" , decoder : | buf : & [u8] | { let msg : Feature = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_SUBJECTIVE_RESTRICTIONS : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.SubjectiveRestrictions")] impl :: prost_wkt :: MessageSerde for SubjectiveRestrictions { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "SubjectiveRestrictions" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.SubjectiveRestrictions" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.SubjectiveRestrictions" , decoder : | buf : & [u8] | { let msg : SubjectiveRestrictions = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_SPECIFICATION : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.Specification")] impl :: prost_wkt :: MessageSerde for Specification { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "Specification" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.Specification" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.Specification" , decoder : | buf : & [u8] | { let msg : Specification = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_ACCOUNT_CREATION_REF : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.AccountCreationRef")] impl :: prost_wkt :: MessageSerde for AccountCreationRef { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "AccountCreationRef" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.AccountCreationRef" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.AccountCreationRef" , decoder : | buf : & [u8] | { let msg : AccountCreationRef = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_HEADER_ONLY_BLOCK : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.HeaderOnlyBlock")] impl :: prost_wkt :: MessageSerde for HeaderOnlyBlock { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "HeaderOnlyBlock" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.HeaderOnlyBlock" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.HeaderOnlyBlock" , decoder : | buf : & [u8] | { let msg : HeaderOnlyBlock = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_TRANSACTION_TRACE_WITH_BLOCK_REF : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.TransactionTraceWithBlockRef")] impl :: prost_wkt :: MessageSerde for TransactionTraceWithBlockRef { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "TransactionTraceWithBlockRef" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.TransactionTraceWithBlockRef" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.TransactionTraceWithBlockRef" , decoder : | buf : & [u8] | { let msg : TransactionTraceWithBlockRef = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_BLOCK_REF : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.BlockRef")] impl :: prost_wkt :: MessageSerde for BlockRef { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "BlockRef" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.BlockRef" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.BlockRef" , decoder : | buf : & [u8] | { let msg : BlockRef = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_ACTION_TRACES : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.ActionTraces")] impl :: prost_wkt :: MessageSerde for ActionTraces { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "ActionTraces" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.ActionTraces" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.ActionTraces" , decoder : | buf : & [u8] | { let msg : ActionTraces = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_TRANSACTION_TRACES : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.TransactionTraces")] impl :: prost_wkt :: MessageSerde for TransactionTraces { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "TransactionTraces" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.TransactionTraces" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.TransactionTraces" , decoder : | buf : & [u8] | { let msg : TransactionTraces = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_DB_OPS : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.DBOps")] impl :: prost_wkt :: MessageSerde for DbOps { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "DBOps" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.DBOps" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.DBOps" , decoder : | buf : & [u8] | { let msg : DbOps = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_BLOCK : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.Block")] impl :: prost_wkt :: MessageSerde for Block { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "Block" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.Block" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.Block" , decoder : | buf : & [u8] | { let msg : Block = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_BLOCK_WITH_REFS : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.BlockWithRefs")] impl :: prost_wkt :: MessageSerde for BlockWithRefs { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "BlockWithRefs" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.BlockWithRefs" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.BlockWithRefs" , decoder : | buf : & [u8] | { let msg : BlockWithRefs = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_TRANSACTION_REFS : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.TransactionRefs")] impl :: prost_wkt :: MessageSerde for TransactionRefs { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "TransactionRefs" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.TransactionRefs" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.TransactionRefs" , decoder : | buf : & [u8] | { let msg : TransactionRefs = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_ACTIVATED_PROTOCOL_FEATURES : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.ActivatedProtocolFeatures")] impl :: prost_wkt :: MessageSerde for ActivatedProtocolFeatures { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "ActivatedProtocolFeatures" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.ActivatedProtocolFeatures" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.ActivatedProtocolFeatures" , decoder : | buf : & [u8] | { let msg : ActivatedProtocolFeatures = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_PENDING_PRODUCER_SCHEDULE : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.PendingProducerSchedule")] impl :: prost_wkt :: MessageSerde for PendingProducerSchedule { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "PendingProducerSchedule" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.PendingProducerSchedule" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.PendingProducerSchedule" , decoder : | buf : & [u8] | { let msg : PendingProducerSchedule = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_PRODUCER_SCHEDULE : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.ProducerSchedule")] impl :: prost_wkt :: MessageSerde for ProducerSchedule { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "ProducerSchedule" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.ProducerSchedule" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.ProducerSchedule" , decoder : | buf : & [u8] | { let msg : ProducerSchedule = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_PRODUCER_KEY : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.ProducerKey")] impl :: prost_wkt :: MessageSerde for ProducerKey { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "ProducerKey" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.ProducerKey" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.ProducerKey" , decoder : | buf : & [u8] | { let msg : ProducerKey = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_PRODUCER_AUTHORITY_SCHEDULE : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.ProducerAuthoritySchedule")] impl :: prost_wkt :: MessageSerde for ProducerAuthoritySchedule { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "ProducerAuthoritySchedule" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.ProducerAuthoritySchedule" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.ProducerAuthoritySchedule" , decoder : | buf : & [u8] | { let msg : ProducerAuthoritySchedule = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_PRODUCER_AUTHORITY : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.ProducerAuthority")] impl :: prost_wkt :: MessageSerde for ProducerAuthority { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "ProducerAuthority" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.ProducerAuthority" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.ProducerAuthority" , decoder : | buf : & [u8] | { let msg : ProducerAuthority = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_BLOCK_SIGNING_AUTHORITY : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.BlockSigningAuthority")] impl :: prost_wkt :: MessageSerde for BlockSigningAuthority { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "BlockSigningAuthority" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.BlockSigningAuthority" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.BlockSigningAuthority" , decoder : | buf : & [u8] | { let msg : BlockSigningAuthority = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_BLOCK_SIGNING_AUTHORITY_V0 : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.BlockSigningAuthorityV0")] impl :: prost_wkt :: MessageSerde for BlockSigningAuthorityV0 { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "BlockSigningAuthorityV0" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.BlockSigningAuthorityV0" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.BlockSigningAuthorityV0" , decoder : | buf : & [u8] | { let msg : BlockSigningAuthorityV0 = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_BLOCK_ROOT_MERKLE : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.BlockRootMerkle")] impl :: prost_wkt :: MessageSerde for BlockRootMerkle { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "BlockRootMerkle" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.BlockRootMerkle" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.BlockRootMerkle" , decoder : | buf : & [u8] | { let msg : BlockRootMerkle = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_PRODUCER_TO_LAST_PRODUCED : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.ProducerToLastProduced")] impl :: prost_wkt :: MessageSerde for ProducerToLastProduced { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "ProducerToLastProduced" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.ProducerToLastProduced" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.ProducerToLastProduced" , decoder : | buf : & [u8] | { let msg : ProducerToLastProduced = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_PRODUCER_TO_LAST_IMPLIED_IRB : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.ProducerToLastImpliedIRB")] impl :: prost_wkt :: MessageSerde for ProducerToLastImpliedIrb { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "ProducerToLastImpliedIRB" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.ProducerToLastImpliedIRB" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.ProducerToLastImpliedIRB" , decoder : | buf : & [u8] | { let msg : ProducerToLastImpliedIrb = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_TRANSACTION_RECEIPT : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.TransactionReceipt")] impl :: prost_wkt :: MessageSerde for TransactionReceipt { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "TransactionReceipt" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.TransactionReceipt" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.TransactionReceipt" , decoder : | buf : & [u8] | { let msg : TransactionReceipt = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_PACKED_TRANSACTION : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.PackedTransaction")] impl :: prost_wkt :: MessageSerde for PackedTransaction { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "PackedTransaction" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.PackedTransaction" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.PackedTransaction" , decoder : | buf : & [u8] | { let msg : PackedTransaction = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_BLOCK_HEADER : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.BlockHeader")] impl :: prost_wkt :: MessageSerde for BlockHeader { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "BlockHeader" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.BlockHeader" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.BlockHeader" , decoder : | buf : & [u8] | { let msg : BlockHeader = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_TRANSACTION_EVENT : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.TransactionEvent")] impl :: prost_wkt :: MessageSerde for TransactionEvent { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "TransactionEvent" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.TransactionEvent" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.TransactionEvent" , decoder : | buf : & [u8] | { let msg : TransactionEvent = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_PUBLIC_KEYS : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.PublicKeys")] impl :: prost_wkt :: MessageSerde for PublicKeys { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "PublicKeys" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.PublicKeys" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.PublicKeys" , decoder : | buf : & [u8] | { let msg : PublicKeys = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_TRANSACTION_LIFECYCLE : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.TransactionLifecycle")] impl :: prost_wkt :: MessageSerde for TransactionLifecycle { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "TransactionLifecycle" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.TransactionLifecycle" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.TransactionLifecycle" , decoder : | buf : & [u8] | { let msg : TransactionLifecycle = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_SIGNED_TRANSACTION : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.SignedTransaction")] impl :: prost_wkt :: MessageSerde for SignedTransaction { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "SignedTransaction" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.SignedTransaction" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.SignedTransaction" , decoder : | buf : & [u8] | { let msg : SignedTransaction = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_TRANSACTION : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.Transaction")] impl :: prost_wkt :: MessageSerde for Transaction { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "Transaction" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.Transaction" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.Transaction" , decoder : | buf : & [u8] | { let msg : Transaction = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_TRANSACTION_HEADER : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.TransactionHeader")] impl :: prost_wkt :: MessageSerde for TransactionHeader { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "TransactionHeader" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.TransactionHeader" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.TransactionHeader" , decoder : | buf : & [u8] | { let msg : TransactionHeader = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_TRANSACTION_TRACE : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.TransactionTrace")] impl :: prost_wkt :: MessageSerde for TransactionTrace { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "TransactionTrace" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.TransactionTrace" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.TransactionTrace" , decoder : | buf : & [u8] | { let msg : TransactionTrace = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_TRANSACTION_RECEIPT_HEADER : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.TransactionReceiptHeader")] impl :: prost_wkt :: MessageSerde for TransactionReceiptHeader { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "TransactionReceiptHeader" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.TransactionReceiptHeader" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.TransactionReceiptHeader" , decoder : | buf : & [u8] | { let msg : TransactionReceiptHeader = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_ACTION : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.Action")] impl :: prost_wkt :: MessageSerde for Action { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "Action" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.Action" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.Action" , decoder : | buf : & [u8] | { let msg : Action = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_ACTION_TRACE : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.ActionTrace")] impl :: prost_wkt :: MessageSerde for ActionTrace { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "ActionTrace" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.ActionTrace" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.ActionTrace" , decoder : | buf : & [u8] | { let msg : ActionTrace = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_ACTION_RECEIPT : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.ActionReceipt")] impl :: prost_wkt :: MessageSerde for ActionReceipt { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "ActionReceipt" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.ActionReceipt" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.ActionReceipt" , decoder : | buf : & [u8] | { let msg : ActionReceipt = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_AUTH_SEQUENCE : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.AuthSequence")] impl :: prost_wkt :: MessageSerde for AuthSequence { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "AuthSequence" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.AuthSequence" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.AuthSequence" , decoder : | buf : & [u8] | { let msg : AuthSequence = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_ACCOUNT_RAM_DELTA : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.AccountRAMDelta")] impl :: prost_wkt :: MessageSerde for AccountRamDelta { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "AccountRAMDelta" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.AccountRAMDelta" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.AccountRAMDelta" , decoder : | buf : & [u8] | { let msg : AccountRamDelta = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_ACCOUNT_DELTA : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.AccountDelta")] impl :: prost_wkt :: MessageSerde for AccountDelta { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "AccountDelta" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.AccountDelta" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.AccountDelta" , decoder : | buf : & [u8] | { let msg : AccountDelta = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_EXTENSION : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.Extension")] impl :: prost_wkt :: MessageSerde for Extension { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "Extension" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.Extension" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.Extension" , decoder : | buf : & [u8] | { let msg : Extension = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_TRX_OP : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.TrxOp")] impl :: prost_wkt :: MessageSerde for TrxOp { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "TrxOp" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.TrxOp" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.TrxOp" , decoder : | buf : & [u8] | { let msg : TrxOp = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_DB_OP : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.DBOp")] impl :: prost_wkt :: MessageSerde for DbOp { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "DBOp" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.DBOp" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.DBOp" , decoder : | buf : & [u8] | { let msg : DbOp = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_RAM_OP : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.RAMOp")] impl :: prost_wkt :: MessageSerde for RamOp { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "RAMOp" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.RAMOp" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.RAMOp" , decoder : | buf : & [u8] | { let msg : RamOp = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_RAM_CORRECTION_OP : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.RAMCorrectionOp")] impl :: prost_wkt :: MessageSerde for RamCorrectionOp { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "RAMCorrectionOp" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.RAMCorrectionOp" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.RAMCorrectionOp" , decoder : | buf : & [u8] | { let msg : RamCorrectionOp = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_TABLE_OP : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.TableOp")] impl :: prost_wkt :: MessageSerde for TableOp { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "TableOp" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.TableOp" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.TableOp" , decoder : | buf : & [u8] | { let msg : TableOp = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_D_TRX_OP : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.DTrxOp")] impl :: prost_wkt :: MessageSerde for DTrxOp { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "DTrxOp" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.DTrxOp" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.DTrxOp" , decoder : | buf : & [u8] | { let msg : DTrxOp = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_EXT_D_TRX_OP : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.ExtDTrxOp")] impl :: prost_wkt :: MessageSerde for ExtDTrxOp { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "ExtDTrxOp" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.ExtDTrxOp" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.ExtDTrxOp" , decoder : | buf : & [u8] | { let msg : ExtDTrxOp = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_FEATURE_OP : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.FeatureOp")] impl :: prost_wkt :: MessageSerde for FeatureOp { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "FeatureOp" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.FeatureOp" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.FeatureOp" , decoder : | buf : & [u8] | { let msg : FeatureOp = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_CREATION_FLAT_NODE : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.CreationFlatNode")] impl :: prost_wkt :: MessageSerde for CreationFlatNode { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "CreationFlatNode" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.CreationFlatNode" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.CreationFlatNode" , decoder : | buf : & [u8] | { let msg : CreationFlatNode = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_PERM_OP : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.PermOp")] impl :: prost_wkt :: MessageSerde for PermOp { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "PermOp" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.PermOp" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.PermOp" , decoder : | buf : & [u8] | { let msg : PermOp = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_PERMISSION_OBJECT : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.PermissionObject")] impl :: prost_wkt :: MessageSerde for PermissionObject { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "PermissionObject" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.PermissionObject" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.PermissionObject" , decoder : | buf : & [u8] | { let msg : PermissionObject = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_PERMISSION : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.Permission")] impl :: prost_wkt :: MessageSerde for Permission { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "Permission" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.Permission" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.Permission" , decoder : | buf : & [u8] | { let msg : Permission = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_AUTHORITY : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.Authority")] impl :: prost_wkt :: MessageSerde for Authority { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "Authority" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.Authority" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.Authority" , decoder : | buf : & [u8] | { let msg : Authority = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_KEY_WEIGHT : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.KeyWeight")] impl :: prost_wkt :: MessageSerde for KeyWeight { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "KeyWeight" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.KeyWeight" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.KeyWeight" , decoder : | buf : & [u8] | { let msg : KeyWeight = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_PERMISSION_LEVEL : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.PermissionLevel")] impl :: prost_wkt :: MessageSerde for PermissionLevel { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "PermissionLevel" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.PermissionLevel" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.PermissionLevel" , decoder : | buf : & [u8] | { let msg : PermissionLevel = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_PERMISSION_LEVEL_WEIGHT : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.PermissionLevelWeight")] impl :: prost_wkt :: MessageSerde for PermissionLevelWeight { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "PermissionLevelWeight" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.PermissionLevelWeight" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.PermissionLevelWeight" , decoder : | buf : & [u8] | { let msg : PermissionLevelWeight = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_WAIT_WEIGHT : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.WaitWeight")] impl :: prost_wkt :: MessageSerde for WaitWeight { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "WaitWeight" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.WaitWeight" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.WaitWeight" , decoder : | buf : & [u8] | { let msg : WaitWeight = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_RLIMIT_OP : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.RlimitOp")] impl :: prost_wkt :: MessageSerde for RlimitOp { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "RlimitOp" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.RlimitOp" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.RlimitOp" , decoder : | buf : & [u8] | { let msg : RlimitOp = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_RLIMIT_STATE : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.RlimitState")] impl :: prost_wkt :: MessageSerde for RlimitState { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "RlimitState" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.RlimitState" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.RlimitState" , decoder : | buf : & [u8] | { let msg : RlimitState = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_RLIMIT_CONFIG : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.RlimitConfig")] impl :: prost_wkt :: MessageSerde for RlimitConfig { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "RlimitConfig" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.RlimitConfig" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.RlimitConfig" , decoder : | buf : & [u8] | { let msg : RlimitConfig = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_RLIMIT_ACCOUNT_LIMITS : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.RlimitAccountLimits")] impl :: prost_wkt :: MessageSerde for RlimitAccountLimits { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "RlimitAccountLimits" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.RlimitAccountLimits" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.RlimitAccountLimits" , decoder : | buf : & [u8] | { let msg : RlimitAccountLimits = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_RLIMIT_ACCOUNT_USAGE : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.RlimitAccountUsage")] impl :: prost_wkt :: MessageSerde for RlimitAccountUsage { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "RlimitAccountUsage" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.RlimitAccountUsage" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.RlimitAccountUsage" , decoder : | buf : & [u8] | { let msg : RlimitAccountUsage = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_USAGE_ACCUMULATOR : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.UsageAccumulator")] impl :: prost_wkt :: MessageSerde for UsageAccumulator { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "UsageAccumulator" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.UsageAccumulator" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.UsageAccumulator" , decoder : | buf : & [u8] | { let msg : UsageAccumulator = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_ELASTIC_LIMIT_PARAMETERS : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.ElasticLimitParameters")] impl :: prost_wkt :: MessageSerde for ElasticLimitParameters { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "ElasticLimitParameters" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.ElasticLimitParameters" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.ElasticLimitParameters" , decoder : | buf : & [u8] | { let msg : ElasticLimitParameters = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_RATIO : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.Ratio")] impl :: prost_wkt :: MessageSerde for Ratio { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "Ratio" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.Ratio" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.Ratio" , decoder : | buf : & [u8] | { let msg : Ratio = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_EXCEPTION : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.Exception")] impl :: prost_wkt :: MessageSerde for Exception { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "Exception" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.Exception" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.Exception" , decoder : | buf : & [u8] | { let msg : Exception = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_FEATURE : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.Feature")] impl :: prost_wkt :: MessageSerde for Feature { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "Feature" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.Feature" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.Feature" , decoder : | buf : & [u8] | { let msg : Feature = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_SUBJECTIVE_RESTRICTIONS : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.SubjectiveRestrictions")] impl :: prost_wkt :: MessageSerde for SubjectiveRestrictions { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "SubjectiveRestrictions" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.SubjectiveRestrictions" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.SubjectiveRestrictions" , decoder : | buf : & [u8] | { let msg : SubjectiveRestrictions = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_SPECIFICATION : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.Specification")] impl :: prost_wkt :: MessageSerde for Specification { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "Specification" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.Specification" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.Specification" , decoder : | buf : & [u8] | { let msg : Specification = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_ACCOUNT_CREATION_REF : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.AccountCreationRef")] impl :: prost_wkt :: MessageSerde for AccountCreationRef { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "AccountCreationRef" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.AccountCreationRef" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.AccountCreationRef" , decoder : | buf : & [u8] | { let msg : AccountCreationRef = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_HEADER_ONLY_BLOCK : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.HeaderOnlyBlock")] impl :: prost_wkt :: MessageSerde for HeaderOnlyBlock { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "HeaderOnlyBlock" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.HeaderOnlyBlock" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.HeaderOnlyBlock" , decoder : | buf : & [u8] | { let msg : HeaderOnlyBlock = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_TRANSACTION_TRACE_WITH_BLOCK_REF : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.TransactionTraceWithBlockRef")] impl :: prost_wkt :: MessageSerde for TransactionTraceWithBlockRef { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "TransactionTraceWithBlockRef" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.TransactionTraceWithBlockRef" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.TransactionTraceWithBlockRef" , decoder : | buf : & [u8] | { let msg : TransactionTraceWithBlockRef = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_BLOCK_REF : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.BlockRef")] impl :: prost_wkt :: MessageSerde for BlockRef { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "BlockRef" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.BlockRef" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.BlockRef" , decoder : | buf : & [u8] | { let msg : BlockRef = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_ACTION_TRACES : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.ActionTraces")] impl :: prost_wkt :: MessageSerde for ActionTraces { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "ActionTraces" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.ActionTraces" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.ActionTraces" , decoder : | buf : & [u8] | { let msg : ActionTraces = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_TRANSACTION_TRACES : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.TransactionTraces")] impl :: prost_wkt :: MessageSerde for TransactionTraces { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "TransactionTraces" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.TransactionTraces" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.TransactionTraces" , decoder : | buf : & [u8] | { let msg : TransactionTraces = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_DB_OPS : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.DBOps")] impl :: prost_wkt :: MessageSerde for DbOps { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "DBOps" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.DBOps" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.DBOps" , decoder : | buf : & [u8] | { let msg : DbOps = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_BLOCK : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.Block")] impl :: prost_wkt :: MessageSerde for Block { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "Block" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.Block" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.Block" , decoder : | buf : & [u8] | { let msg : Block = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_BLOCK_WITH_REFS : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.BlockWithRefs")] impl :: prost_wkt :: MessageSerde for BlockWithRefs { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "BlockWithRefs" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.BlockWithRefs" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.BlockWithRefs" , decoder : | buf : & [u8] | { let msg : BlockWithRefs = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_TRANSACTION_REFS : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.TransactionRefs")] impl :: prost_wkt :: MessageSerde for TransactionRefs { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "TransactionRefs" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.TransactionRefs" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.TransactionRefs" , decoder : | buf : & [u8] | { let msg : TransactionRefs = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_ACTIVATED_PROTOCOL_FEATURES : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.ActivatedProtocolFeatures")] impl :: prost_wkt :: MessageSerde for ActivatedProtocolFeatures { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "ActivatedProtocolFeatures" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.ActivatedProtocolFeatures" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.ActivatedProtocolFeatures" , decoder : | buf : & [u8] | { let msg : ActivatedProtocolFeatures = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_PENDING_PRODUCER_SCHEDULE : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.PendingProducerSchedule")] impl :: prost_wkt :: MessageSerde for PendingProducerSchedule { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "PendingProducerSchedule" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.PendingProducerSchedule" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.PendingProducerSchedule" , decoder : | buf : & [u8] | { let msg : PendingProducerSchedule = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_PRODUCER_SCHEDULE : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.ProducerSchedule")] impl :: prost_wkt :: MessageSerde for ProducerSchedule { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "ProducerSchedule" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.ProducerSchedule" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.ProducerSchedule" , decoder : | buf : & [u8] | { let msg : ProducerSchedule = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_PRODUCER_KEY : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.ProducerKey")] impl :: prost_wkt :: MessageSerde for ProducerKey { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "ProducerKey" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.ProducerKey" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.ProducerKey" , decoder : | buf : & [u8] | { let msg : ProducerKey = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_PRODUCER_AUTHORITY_SCHEDULE : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.ProducerAuthoritySchedule")] impl :: prost_wkt :: MessageSerde for ProducerAuthoritySchedule { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "ProducerAuthoritySchedule" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.ProducerAuthoritySchedule" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.ProducerAuthoritySchedule" , decoder : | buf : & [u8] | { let msg : ProducerAuthoritySchedule = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_PRODUCER_AUTHORITY : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.ProducerAuthority")] impl :: prost_wkt :: MessageSerde for ProducerAuthority { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "ProducerAuthority" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.ProducerAuthority" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.ProducerAuthority" , decoder : | buf : & [u8] | { let msg : ProducerAuthority = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_BLOCK_SIGNING_AUTHORITY : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.BlockSigningAuthority")] impl :: prost_wkt :: MessageSerde for BlockSigningAuthority { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "BlockSigningAuthority" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.BlockSigningAuthority" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.BlockSigningAuthority" , decoder : | buf : & [u8] | { let msg : BlockSigningAuthority = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_BLOCK_SIGNING_AUTHORITY_V0 : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.BlockSigningAuthorityV0")] impl :: prost_wkt :: MessageSerde for BlockSigningAuthorityV0 { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "BlockSigningAuthorityV0" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.BlockSigningAuthorityV0" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.BlockSigningAuthorityV0" , decoder : | buf : & [u8] | { let msg : BlockSigningAuthorityV0 = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_BLOCK_ROOT_MERKLE : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.BlockRootMerkle")] impl :: prost_wkt :: MessageSerde for BlockRootMerkle { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "BlockRootMerkle" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.BlockRootMerkle" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.BlockRootMerkle" , decoder : | buf : & [u8] | { let msg : BlockRootMerkle = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_PRODUCER_TO_LAST_PRODUCED : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.ProducerToLastProduced")] impl :: prost_wkt :: MessageSerde for ProducerToLastProduced { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "ProducerToLastProduced" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.ProducerToLastProduced" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.ProducerToLastProduced" , decoder : | buf : & [u8] | { let msg : ProducerToLastProduced = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_PRODUCER_TO_LAST_IMPLIED_IRB : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.ProducerToLastImpliedIRB")] impl :: prost_wkt :: MessageSerde for ProducerToLastImpliedIrb { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "ProducerToLastImpliedIRB" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.ProducerToLastImpliedIRB" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.ProducerToLastImpliedIRB" , decoder : | buf : & [u8] | { let msg : ProducerToLastImpliedIrb = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_TRANSACTION_RECEIPT : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.TransactionReceipt")] impl :: prost_wkt :: MessageSerde for TransactionReceipt { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "TransactionReceipt" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.TransactionReceipt" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.TransactionReceipt" , decoder : | buf : & [u8] | { let msg : TransactionReceipt = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_PACKED_TRANSACTION : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.PackedTransaction")] impl :: prost_wkt :: MessageSerde for PackedTransaction { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "PackedTransaction" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.PackedTransaction" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.PackedTransaction" , decoder : | buf : & [u8] | { let msg : PackedTransaction = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_BLOCK_HEADER : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.BlockHeader")] impl :: prost_wkt :: MessageSerde for BlockHeader { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "BlockHeader" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.BlockHeader" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.BlockHeader" , decoder : | buf : & [u8] | { let msg : BlockHeader = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_TRANSACTION_EVENT : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.TransactionEvent")] impl :: prost_wkt :: MessageSerde for TransactionEvent { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "TransactionEvent" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.TransactionEvent" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.TransactionEvent" , decoder : | buf : & [u8] | { let msg : TransactionEvent = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_PUBLIC_KEYS : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.PublicKeys")] impl :: prost_wkt :: MessageSerde for PublicKeys { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "PublicKeys" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.PublicKeys" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.PublicKeys" , decoder : | buf : & [u8] | { let msg : PublicKeys = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_TRANSACTION_LIFECYCLE : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.TransactionLifecycle")] impl :: prost_wkt :: MessageSerde for TransactionLifecycle { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "TransactionLifecycle" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.TransactionLifecycle" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.TransactionLifecycle" , decoder : | buf : & [u8] | { let msg : TransactionLifecycle = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_SIGNED_TRANSACTION : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.SignedTransaction")] impl :: prost_wkt :: MessageSerde for SignedTransaction { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "SignedTransaction" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.SignedTransaction" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.SignedTransaction" , decoder : | buf : & [u8] | { let msg : SignedTransaction = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_TRANSACTION : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.Transaction")] impl :: prost_wkt :: MessageSerde for Transaction { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "Transaction" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.Transaction" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.Transaction" , decoder : | buf : & [u8] | { let msg : Transaction = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_TRANSACTION_HEADER : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.TransactionHeader")] impl :: prost_wkt :: MessageSerde for TransactionHeader { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "TransactionHeader" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.TransactionHeader" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.TransactionHeader" , decoder : | buf : & [u8] | { let msg : TransactionHeader = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_TRANSACTION_TRACE : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.TransactionTrace")] impl :: prost_wkt :: MessageSerde for TransactionTrace { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "TransactionTrace" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.TransactionTrace" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.TransactionTrace" , decoder : | buf : & [u8] | { let msg : TransactionTrace = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_TRANSACTION_RECEIPT_HEADER : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.TransactionReceiptHeader")] impl :: prost_wkt :: MessageSerde for TransactionReceiptHeader { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "TransactionReceiptHeader" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.TransactionReceiptHeader" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.TransactionReceiptHeader" , decoder : | buf : & [u8] | { let msg : TransactionReceiptHeader = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_ACTION : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.Action")] impl :: prost_wkt :: MessageSerde for Action { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "Action" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.Action" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.Action" , decoder : | buf : & [u8] | { let msg : Action = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_ACTION_TRACE : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.ActionTrace")] impl :: prost_wkt :: MessageSerde for ActionTrace { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "ActionTrace" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.ActionTrace" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.ActionTrace" , decoder : | buf : & [u8] | { let msg : ActionTrace = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_ACTION_RECEIPT : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.ActionReceipt")] impl :: prost_wkt :: MessageSerde for ActionReceipt { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "ActionReceipt" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.ActionReceipt" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.ActionReceipt" , decoder : | buf : & [u8] | { let msg : ActionReceipt = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_AUTH_SEQUENCE : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.AuthSequence")] impl :: prost_wkt :: MessageSerde for AuthSequence { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "AuthSequence" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.AuthSequence" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.AuthSequence" , decoder : | buf : & [u8] | { let msg : AuthSequence = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_ACCOUNT_RAM_DELTA : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.AccountRAMDelta")] impl :: prost_wkt :: MessageSerde for AccountRamDelta { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "AccountRAMDelta" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.AccountRAMDelta" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.AccountRAMDelta" , decoder : | buf : & [u8] | { let msg : AccountRamDelta = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_ACCOUNT_DELTA : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.AccountDelta")] impl :: prost_wkt :: MessageSerde for AccountDelta { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "AccountDelta" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.AccountDelta" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.AccountDelta" , decoder : | buf : & [u8] | { let msg : AccountDelta = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_EXTENSION : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.Extension")] impl :: prost_wkt :: MessageSerde for Extension { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "Extension" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.Extension" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.Extension" , decoder : | buf : & [u8] | { let msg : Extension = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_TRX_OP : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.TrxOp")] impl :: prost_wkt :: MessageSerde for TrxOp { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "TrxOp" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.TrxOp" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.TrxOp" , decoder : | buf : & [u8] | { let msg : TrxOp = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_DB_OP : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.DBOp")] impl :: prost_wkt :: MessageSerde for DbOp { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "DBOp" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.DBOp" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.DBOp" , decoder : | buf : & [u8] | { let msg : DbOp = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_RAM_OP : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.RAMOp")] impl :: prost_wkt :: MessageSerde for RamOp { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "RAMOp" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.RAMOp" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.RAMOp" , decoder : | buf : & [u8] | { let msg : RamOp = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_RAM_CORRECTION_OP : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.RAMCorrectionOp")] impl :: prost_wkt :: MessageSerde for RamCorrectionOp { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "RAMCorrectionOp" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.RAMCorrectionOp" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.RAMCorrectionOp" , decoder : | buf : & [u8] | { let msg : RamCorrectionOp = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_TABLE_OP : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.TableOp")] impl :: prost_wkt :: MessageSerde for TableOp { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "TableOp" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.TableOp" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.TableOp" , decoder : | buf : & [u8] | { let msg : TableOp = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_D_TRX_OP : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.DTrxOp")] impl :: prost_wkt :: MessageSerde for DTrxOp { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "DTrxOp" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.DTrxOp" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.DTrxOp" , decoder : | buf : & [u8] | { let msg : DTrxOp = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_EXT_D_TRX_OP : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.ExtDTrxOp")] impl :: prost_wkt :: MessageSerde for ExtDTrxOp { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "ExtDTrxOp" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.ExtDTrxOp" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.ExtDTrxOp" , decoder : | buf : & [u8] | { let msg : ExtDTrxOp = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_FEATURE_OP : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.FeatureOp")] impl :: prost_wkt :: MessageSerde for FeatureOp { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "FeatureOp" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.FeatureOp" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.FeatureOp" , decoder : | buf : & [u8] | { let msg : FeatureOp = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_CREATION_FLAT_NODE : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.CreationFlatNode")] impl :: prost_wkt :: MessageSerde for CreationFlatNode { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "CreationFlatNode" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.CreationFlatNode" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.CreationFlatNode" , decoder : | buf : & [u8] | { let msg : CreationFlatNode = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_PERM_OP : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.PermOp")] impl :: prost_wkt :: MessageSerde for PermOp { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "PermOp" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.PermOp" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.PermOp" , decoder : | buf : & [u8] | { let msg : PermOp = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_PERMISSION_OBJECT : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.PermissionObject")] impl :: prost_wkt :: MessageSerde for PermissionObject { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "PermissionObject" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.PermissionObject" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.PermissionObject" , decoder : | buf : & [u8] | { let msg : PermissionObject = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_PERMISSION : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.Permission")] impl :: prost_wkt :: MessageSerde for Permission { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "Permission" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.Permission" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.Permission" , decoder : | buf : & [u8] | { let msg : Permission = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_AUTHORITY : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.Authority")] impl :: prost_wkt :: MessageSerde for Authority { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "Authority" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.Authority" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.Authority" , decoder : | buf : & [u8] | { let msg : Authority = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_KEY_WEIGHT : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.KeyWeight")] impl :: prost_wkt :: MessageSerde for KeyWeight { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "KeyWeight" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.KeyWeight" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.KeyWeight" , decoder : | buf : & [u8] | { let msg : KeyWeight = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_PERMISSION_LEVEL : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.PermissionLevel")] impl :: prost_wkt :: MessageSerde for PermissionLevel { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "PermissionLevel" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.PermissionLevel" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.PermissionLevel" , decoder : | buf : & [u8] | { let msg : PermissionLevel = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_PERMISSION_LEVEL_WEIGHT : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.PermissionLevelWeight")] impl :: prost_wkt :: MessageSerde for PermissionLevelWeight { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "PermissionLevelWeight" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.PermissionLevelWeight" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.PermissionLevelWeight" , decoder : | buf : & [u8] | { let msg : PermissionLevelWeight = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_WAIT_WEIGHT : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.WaitWeight")] impl :: prost_wkt :: MessageSerde for WaitWeight { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "WaitWeight" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.WaitWeight" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.WaitWeight" , decoder : | buf : & [u8] | { let msg : WaitWeight = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_RLIMIT_OP : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.RlimitOp")] impl :: prost_wkt :: MessageSerde for RlimitOp { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "RlimitOp" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.RlimitOp" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.RlimitOp" , decoder : | buf : & [u8] | { let msg : RlimitOp = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_RLIMIT_STATE : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.RlimitState")] impl :: prost_wkt :: MessageSerde for RlimitState { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "RlimitState" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.RlimitState" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.RlimitState" , decoder : | buf : & [u8] | { let msg : RlimitState = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_RLIMIT_CONFIG : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.RlimitConfig")] impl :: prost_wkt :: MessageSerde for RlimitConfig { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "RlimitConfig" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.RlimitConfig" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.RlimitConfig" , decoder : | buf : & [u8] | { let msg : RlimitConfig = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_RLIMIT_ACCOUNT_LIMITS : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.RlimitAccountLimits")] impl :: prost_wkt :: MessageSerde for RlimitAccountLimits { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "RlimitAccountLimits" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.RlimitAccountLimits" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.RlimitAccountLimits" , decoder : | buf : & [u8] | { let msg : RlimitAccountLimits = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_RLIMIT_ACCOUNT_USAGE : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.RlimitAccountUsage")] impl :: prost_wkt :: MessageSerde for RlimitAccountUsage { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "RlimitAccountUsage" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.RlimitAccountUsage" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.RlimitAccountUsage" , decoder : | buf : & [u8] | { let msg : RlimitAccountUsage = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_USAGE_ACCUMULATOR : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.UsageAccumulator")] impl :: prost_wkt :: MessageSerde for UsageAccumulator { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "UsageAccumulator" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.UsageAccumulator" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.UsageAccumulator" , decoder : | buf : & [u8] | { let msg : UsageAccumulator = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_ELASTIC_LIMIT_PARAMETERS : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.ElasticLimitParameters")] impl :: prost_wkt :: MessageSerde for ElasticLimitParameters { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "ElasticLimitParameters" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.ElasticLimitParameters" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.ElasticLimitParameters" , decoder : | buf : & [u8] | { let msg : ElasticLimitParameters = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_RATIO : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.Ratio")] impl :: prost_wkt :: MessageSerde for Ratio { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "Ratio" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.Ratio" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.Ratio" , decoder : | buf : & [u8] | { let msg : Ratio = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_EXCEPTION : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.Exception")] impl :: prost_wkt :: MessageSerde for Exception { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "Exception" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.Exception" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.Exception" , decoder : | buf : & [u8] | { let msg : Exception = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_FEATURE : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.Feature")] impl :: prost_wkt :: MessageSerde for Feature { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "Feature" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.Feature" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.Feature" , decoder : | buf : & [u8] | { let msg : Feature = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_SUBJECTIVE_RESTRICTIONS : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.SubjectiveRestrictions")] impl :: prost_wkt :: MessageSerde for SubjectiveRestrictions { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "SubjectiveRestrictions" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.SubjectiveRestrictions" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.SubjectiveRestrictions" , decoder : | buf : & [u8] | { let msg : SubjectiveRestrictions = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_SPECIFICATION : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.Specification")] impl :: prost_wkt :: MessageSerde for Specification { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "Specification" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.Specification" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.Specification" , decoder : | buf : & [u8] | { let msg : Specification = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_ACCOUNT_CREATION_REF : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.AccountCreationRef")] impl :: prost_wkt :: MessageSerde for AccountCreationRef { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "AccountCreationRef" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.AccountCreationRef" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.AccountCreationRef" , decoder : | buf : & [u8] | { let msg : AccountCreationRef = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_HEADER_ONLY_BLOCK : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.HeaderOnlyBlock")] impl :: prost_wkt :: MessageSerde for HeaderOnlyBlock { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "HeaderOnlyBlock" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.HeaderOnlyBlock" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.HeaderOnlyBlock" , decoder : | buf : & [u8] | { let msg : HeaderOnlyBlock = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_TRANSACTION_TRACE_WITH_BLOCK_REF : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.TransactionTraceWithBlockRef")] impl :: prost_wkt :: MessageSerde for TransactionTraceWithBlockRef { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "TransactionTraceWithBlockRef" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.TransactionTraceWithBlockRef" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.TransactionTraceWithBlockRef" , decoder : | buf : & [u8] | { let msg : TransactionTraceWithBlockRef = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_BLOCK_REF : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.BlockRef")] impl :: prost_wkt :: MessageSerde for BlockRef { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "BlockRef" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.BlockRef" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.BlockRef" , decoder : | buf : & [u8] | { let msg : BlockRef = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_ACTION_TRACES : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.ActionTraces")] impl :: prost_wkt :: MessageSerde for ActionTraces { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "ActionTraces" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.ActionTraces" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.ActionTraces" , decoder : | buf : & [u8] | { let msg : ActionTraces = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_TRANSACTION_TRACES : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.TransactionTraces")] impl :: prost_wkt :: MessageSerde for TransactionTraces { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "TransactionTraces" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.TransactionTraces" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.TransactionTraces" , decoder : | buf : & [u8] | { let msg : TransactionTraces = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_DB_OPS : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.DBOps")] impl :: prost_wkt :: MessageSerde for DbOps { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "DBOps" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.DBOps" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.DBOps" , decoder : | buf : & [u8] | { let msg : DbOps = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_BLOCK : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.Block")] impl :: prost_wkt :: MessageSerde for Block { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "Block" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.Block" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.Block" , decoder : | buf : & [u8] | { let msg : Block = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_BLOCK_WITH_REFS : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.BlockWithRefs")] impl :: prost_wkt :: MessageSerde for BlockWithRefs { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "BlockWithRefs" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.BlockWithRefs" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.BlockWithRefs" , decoder : | buf : & [u8] | { let msg : BlockWithRefs = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_TRANSACTION_REFS : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.TransactionRefs")] impl :: prost_wkt :: MessageSerde for TransactionRefs { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "TransactionRefs" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.TransactionRefs" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.TransactionRefs" , decoder : | buf : & [u8] | { let msg : TransactionRefs = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_ACTIVATED_PROTOCOL_FEATURES : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.ActivatedProtocolFeatures")] impl :: prost_wkt :: MessageSerde for ActivatedProtocolFeatures { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "ActivatedProtocolFeatures" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.ActivatedProtocolFeatures" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.ActivatedProtocolFeatures" , decoder : | buf : & [u8] | { let msg : ActivatedProtocolFeatures = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_PENDING_PRODUCER_SCHEDULE : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.PendingProducerSchedule")] impl :: prost_wkt :: MessageSerde for PendingProducerSchedule { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "PendingProducerSchedule" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.PendingProducerSchedule" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.PendingProducerSchedule" , decoder : | buf : & [u8] | { let msg : PendingProducerSchedule = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_PRODUCER_SCHEDULE : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.ProducerSchedule")] impl :: prost_wkt :: MessageSerde for ProducerSchedule { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "ProducerSchedule" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.ProducerSchedule" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.ProducerSchedule" , decoder : | buf : & [u8] | { let msg : ProducerSchedule = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_PRODUCER_KEY : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.ProducerKey")] impl :: prost_wkt :: MessageSerde for ProducerKey { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "ProducerKey" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.ProducerKey" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.ProducerKey" , decoder : | buf : & [u8] | { let msg : ProducerKey = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_PRODUCER_AUTHORITY_SCHEDULE : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.ProducerAuthoritySchedule")] impl :: prost_wkt :: MessageSerde for ProducerAuthoritySchedule { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "ProducerAuthoritySchedule" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.ProducerAuthoritySchedule" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.ProducerAuthoritySchedule" , decoder : | buf : & [u8] | { let msg : ProducerAuthoritySchedule = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_PRODUCER_AUTHORITY : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.ProducerAuthority")] impl :: prost_wkt :: MessageSerde for ProducerAuthority { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "ProducerAuthority" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.ProducerAuthority" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.ProducerAuthority" , decoder : | buf : & [u8] | { let msg : ProducerAuthority = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_BLOCK_SIGNING_AUTHORITY : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.BlockSigningAuthority")] impl :: prost_wkt :: MessageSerde for BlockSigningAuthority { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "BlockSigningAuthority" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.BlockSigningAuthority" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.BlockSigningAuthority" , decoder : | buf : & [u8] | { let msg : BlockSigningAuthority = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_BLOCK_SIGNING_AUTHORITY_V0 : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.BlockSigningAuthorityV0")] impl :: prost_wkt :: MessageSerde for BlockSigningAuthorityV0 { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "BlockSigningAuthorityV0" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.BlockSigningAuthorityV0" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.BlockSigningAuthorityV0" , decoder : | buf : & [u8] | { let msg : BlockSigningAuthorityV0 = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_BLOCK_ROOT_MERKLE : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.BlockRootMerkle")] impl :: prost_wkt :: MessageSerde for BlockRootMerkle { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "BlockRootMerkle" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.BlockRootMerkle" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.BlockRootMerkle" , decoder : | buf : & [u8] | { let msg : BlockRootMerkle = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_PRODUCER_TO_LAST_PRODUCED : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.ProducerToLastProduced")] impl :: prost_wkt :: MessageSerde for ProducerToLastProduced { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "ProducerToLastProduced" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.ProducerToLastProduced" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.ProducerToLastProduced" , decoder : | buf : & [u8] | { let msg : ProducerToLastProduced = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_PRODUCER_TO_LAST_IMPLIED_IRB : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.ProducerToLastImpliedIRB")] impl :: prost_wkt :: MessageSerde for ProducerToLastImpliedIrb { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "ProducerToLastImpliedIRB" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.ProducerToLastImpliedIRB" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.ProducerToLastImpliedIRB" , decoder : | buf : & [u8] | { let msg : ProducerToLastImpliedIrb = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_TRANSACTION_RECEIPT : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.TransactionReceipt")] impl :: prost_wkt :: MessageSerde for TransactionReceipt { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "TransactionReceipt" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.TransactionReceipt" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.TransactionReceipt" , decoder : | buf : & [u8] | { let msg : TransactionReceipt = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_PACKED_TRANSACTION : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.PackedTransaction")] impl :: prost_wkt :: MessageSerde for PackedTransaction { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "PackedTransaction" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.PackedTransaction" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.PackedTransaction" , decoder : | buf : & [u8] | { let msg : PackedTransaction = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_BLOCK_HEADER : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.BlockHeader")] impl :: prost_wkt :: MessageSerde for BlockHeader { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "BlockHeader" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.BlockHeader" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.BlockHeader" , decoder : | buf : & [u8] | { let msg : BlockHeader = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_TRANSACTION_EVENT : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.TransactionEvent")] impl :: prost_wkt :: MessageSerde for TransactionEvent { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "TransactionEvent" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.TransactionEvent" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.TransactionEvent" , decoder : | buf : & [u8] | { let msg : TransactionEvent = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_PUBLIC_KEYS : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.PublicKeys")] impl :: prost_wkt :: MessageSerde for PublicKeys { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "PublicKeys" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.PublicKeys" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.PublicKeys" , decoder : | buf : & [u8] | { let msg : PublicKeys = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_TRANSACTION_LIFECYCLE : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.TransactionLifecycle")] impl :: prost_wkt :: MessageSerde for TransactionLifecycle { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "TransactionLifecycle" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.TransactionLifecycle" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.TransactionLifecycle" , decoder : | buf : & [u8] | { let msg : TransactionLifecycle = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_SIGNED_TRANSACTION : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.SignedTransaction")] impl :: prost_wkt :: MessageSerde for SignedTransaction { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "SignedTransaction" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.SignedTransaction" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.SignedTransaction" , decoder : | buf : & [u8] | { let msg : SignedTransaction = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_TRANSACTION : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.Transaction")] impl :: prost_wkt :: MessageSerde for Transaction { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "Transaction" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.Transaction" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.Transaction" , decoder : | buf : & [u8] | { let msg : Transaction = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_TRANSACTION_HEADER : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.TransactionHeader")] impl :: prost_wkt :: MessageSerde for TransactionHeader { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "TransactionHeader" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.TransactionHeader" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.TransactionHeader" , decoder : | buf : & [u8] | { let msg : TransactionHeader = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_TRANSACTION_TRACE : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.TransactionTrace")] impl :: prost_wkt :: MessageSerde for TransactionTrace { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "TransactionTrace" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.TransactionTrace" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.TransactionTrace" , decoder : | buf : & [u8] | { let msg : TransactionTrace = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_TRANSACTION_RECEIPT_HEADER : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.TransactionReceiptHeader")] impl :: prost_wkt :: MessageSerde for TransactionReceiptHeader { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "TransactionReceiptHeader" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.TransactionReceiptHeader" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.TransactionReceiptHeader" , decoder : | buf : & [u8] | { let msg : TransactionReceiptHeader = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_ACTION : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.Action")] impl :: prost_wkt :: MessageSerde for Action { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "Action" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.Action" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.Action" , decoder : | buf : & [u8] | { let msg : Action = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_ACTION_TRACE : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.ActionTrace")] impl :: prost_wkt :: MessageSerde for ActionTrace { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "ActionTrace" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.ActionTrace" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.ActionTrace" , decoder : | buf : & [u8] | { let msg : ActionTrace = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_ACTION_RECEIPT : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.ActionReceipt")] impl :: prost_wkt :: MessageSerde for ActionReceipt { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "ActionReceipt" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.ActionReceipt" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.ActionReceipt" , decoder : | buf : & [u8] | { let msg : ActionReceipt = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_AUTH_SEQUENCE : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.AuthSequence")] impl :: prost_wkt :: MessageSerde for AuthSequence { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "AuthSequence" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.AuthSequence" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.AuthSequence" , decoder : | buf : & [u8] | { let msg : AuthSequence = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_ACCOUNT_RAM_DELTA : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.AccountRAMDelta")] impl :: prost_wkt :: MessageSerde for AccountRamDelta { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "AccountRAMDelta" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.AccountRAMDelta" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.AccountRAMDelta" , decoder : | buf : & [u8] | { let msg : AccountRamDelta = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_ACCOUNT_DELTA : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.AccountDelta")] impl :: prost_wkt :: MessageSerde for AccountDelta { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "AccountDelta" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.AccountDelta" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.AccountDelta" , decoder : | buf : & [u8] | { let msg : AccountDelta = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_EXTENSION : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.Extension")] impl :: prost_wkt :: MessageSerde for Extension { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "Extension" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.Extension" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.Extension" , decoder : | buf : & [u8] | { let msg : Extension = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_TRX_OP : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.TrxOp")] impl :: prost_wkt :: MessageSerde for TrxOp { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "TrxOp" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.TrxOp" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.TrxOp" , decoder : | buf : & [u8] | { let msg : TrxOp = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_DB_OP : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.DBOp")] impl :: prost_wkt :: MessageSerde for DbOp { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "DBOp" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.DBOp" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.DBOp" , decoder : | buf : & [u8] | { let msg : DbOp = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_RAM_OP : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.RAMOp")] impl :: prost_wkt :: MessageSerde for RamOp { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "RAMOp" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.RAMOp" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.RAMOp" , decoder : | buf : & [u8] | { let msg : RamOp = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_RAM_CORRECTION_OP : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.RAMCorrectionOp")] impl :: prost_wkt :: MessageSerde for RamCorrectionOp { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "RAMCorrectionOp" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.RAMCorrectionOp" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.RAMCorrectionOp" , decoder : | buf : & [u8] | { let msg : RamCorrectionOp = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_TABLE_OP : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.TableOp")] impl :: prost_wkt :: MessageSerde for TableOp { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "TableOp" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.TableOp" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.TableOp" , decoder : | buf : & [u8] | { let msg : TableOp = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_D_TRX_OP : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.DTrxOp")] impl :: prost_wkt :: MessageSerde for DTrxOp { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "DTrxOp" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.DTrxOp" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.DTrxOp" , decoder : | buf : & [u8] | { let msg : DTrxOp = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_EXT_D_TRX_OP : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.ExtDTrxOp")] impl :: prost_wkt :: MessageSerde for ExtDTrxOp { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "ExtDTrxOp" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.ExtDTrxOp" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.ExtDTrxOp" , decoder : | buf : & [u8] | { let msg : ExtDTrxOp = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_FEATURE_OP : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.FeatureOp")] impl :: prost_wkt :: MessageSerde for FeatureOp { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "FeatureOp" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.FeatureOp" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.FeatureOp" , decoder : | buf : & [u8] | { let msg : FeatureOp = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_CREATION_FLAT_NODE : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.CreationFlatNode")] impl :: prost_wkt :: MessageSerde for CreationFlatNode { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "CreationFlatNode" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.CreationFlatNode" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.CreationFlatNode" , decoder : | buf : & [u8] | { let msg : CreationFlatNode = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_PERM_OP : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.PermOp")] impl :: prost_wkt :: MessageSerde for PermOp { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "PermOp" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.PermOp" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.PermOp" , decoder : | buf : & [u8] | { let msg : PermOp = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_PERMISSION_OBJECT : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.PermissionObject")] impl :: prost_wkt :: MessageSerde for PermissionObject { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "PermissionObject" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.PermissionObject" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.PermissionObject" , decoder : | buf : & [u8] | { let msg : PermissionObject = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_PERMISSION : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.Permission")] impl :: prost_wkt :: MessageSerde for Permission { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "Permission" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.Permission" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.Permission" , decoder : | buf : & [u8] | { let msg : Permission = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_AUTHORITY : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.Authority")] impl :: prost_wkt :: MessageSerde for Authority { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "Authority" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.Authority" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.Authority" , decoder : | buf : & [u8] | { let msg : Authority = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_KEY_WEIGHT : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.KeyWeight")] impl :: prost_wkt :: MessageSerde for KeyWeight { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "KeyWeight" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.KeyWeight" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.KeyWeight" , decoder : | buf : & [u8] | { let msg : KeyWeight = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_PERMISSION_LEVEL : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.PermissionLevel")] impl :: prost_wkt :: MessageSerde for PermissionLevel { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "PermissionLevel" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.PermissionLevel" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.PermissionLevel" , decoder : | buf : & [u8] | { let msg : PermissionLevel = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_PERMISSION_LEVEL_WEIGHT : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.PermissionLevelWeight")] impl :: prost_wkt :: MessageSerde for PermissionLevelWeight { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "PermissionLevelWeight" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.PermissionLevelWeight" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.PermissionLevelWeight" , decoder : | buf : & [u8] | { let msg : PermissionLevelWeight = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_WAIT_WEIGHT : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.WaitWeight")] impl :: prost_wkt :: MessageSerde for WaitWeight { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "WaitWeight" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.WaitWeight" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.WaitWeight" , decoder : | buf : & [u8] | { let msg : WaitWeight = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_RLIMIT_OP : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.RlimitOp")] impl :: prost_wkt :: MessageSerde for RlimitOp { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "RlimitOp" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.RlimitOp" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.RlimitOp" , decoder : | buf : & [u8] | { let msg : RlimitOp = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_RLIMIT_STATE : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.RlimitState")] impl :: prost_wkt :: MessageSerde for RlimitState { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "RlimitState" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.RlimitState" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.RlimitState" , decoder : | buf : & [u8] | { let msg : RlimitState = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_RLIMIT_CONFIG : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.RlimitConfig")] impl :: prost_wkt :: MessageSerde for RlimitConfig { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "RlimitConfig" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.RlimitConfig" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.RlimitConfig" , decoder : | buf : & [u8] | { let msg : RlimitConfig = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_RLIMIT_ACCOUNT_LIMITS : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.RlimitAccountLimits")] impl :: prost_wkt :: MessageSerde for RlimitAccountLimits { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "RlimitAccountLimits" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.RlimitAccountLimits" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.RlimitAccountLimits" , decoder : | buf : & [u8] | { let msg : RlimitAccountLimits = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_RLIMIT_ACCOUNT_USAGE : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.RlimitAccountUsage")] impl :: prost_wkt :: MessageSerde for RlimitAccountUsage { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "RlimitAccountUsage" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.RlimitAccountUsage" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.RlimitAccountUsage" , decoder : | buf : & [u8] | { let msg : RlimitAccountUsage = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_USAGE_ACCUMULATOR : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.UsageAccumulator")] impl :: prost_wkt :: MessageSerde for UsageAccumulator { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "UsageAccumulator" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.UsageAccumulator" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.UsageAccumulator" , decoder : | buf : & [u8] | { let msg : UsageAccumulator = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_ELASTIC_LIMIT_PARAMETERS : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.ElasticLimitParameters")] impl :: prost_wkt :: MessageSerde for ElasticLimitParameters { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "ElasticLimitParameters" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.ElasticLimitParameters" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.ElasticLimitParameters" , decoder : | buf : & [u8] | { let msg : ElasticLimitParameters = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_RATIO : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.Ratio")] impl :: prost_wkt :: MessageSerde for Ratio { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "Ratio" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.Ratio" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.Ratio" , decoder : | buf : & [u8] | { let msg : Ratio = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_EXCEPTION : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.Exception")] impl :: prost_wkt :: MessageSerde for Exception { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "Exception" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.Exception" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.Exception" , decoder : | buf : & [u8] | { let msg : Exception = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_FEATURE : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.Feature")] impl :: prost_wkt :: MessageSerde for Feature { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "Feature" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.Feature" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.Feature" , decoder : | buf : & [u8] | { let msg : Feature = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_SUBJECTIVE_RESTRICTIONS : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.SubjectiveRestrictions")] impl :: prost_wkt :: MessageSerde for SubjectiveRestrictions { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "SubjectiveRestrictions" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.SubjectiveRestrictions" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.SubjectiveRestrictions" , decoder : | buf : & [u8] | { let msg : SubjectiveRestrictions = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_SPECIFICATION : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.Specification")] impl :: prost_wkt :: MessageSerde for Specification { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "Specification" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.Specification" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.Specification" , decoder : | buf : & [u8] | { let msg : Specification = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_ACCOUNT_CREATION_REF : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.AccountCreationRef")] impl :: prost_wkt :: MessageSerde for AccountCreationRef { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "AccountCreationRef" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.AccountCreationRef" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.AccountCreationRef" , decoder : | buf : & [u8] | { let msg : AccountCreationRef = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_HEADER_ONLY_BLOCK : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.HeaderOnlyBlock")] impl :: prost_wkt :: MessageSerde for HeaderOnlyBlock { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "HeaderOnlyBlock" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.HeaderOnlyBlock" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.HeaderOnlyBlock" , decoder : | buf : & [u8] | { let msg : HeaderOnlyBlock = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_TRANSACTION_TRACE_WITH_BLOCK_REF : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.TransactionTraceWithBlockRef")] impl :: prost_wkt :: MessageSerde for TransactionTraceWithBlockRef { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "TransactionTraceWithBlockRef" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.TransactionTraceWithBlockRef" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.TransactionTraceWithBlockRef" , decoder : | buf : & [u8] | { let msg : TransactionTraceWithBlockRef = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;

# [allow (dead_code)] const IMPL_MESSAGE_SERDE_FOR_BLOCK_REF : () = { use :: prost_wkt :: typetag ; # [typetag :: serde (name = "type.googleapis.com/sf.antelope.type.v1.BlockRef")] impl :: prost_wkt :: MessageSerde for BlockRef { fn package_name (& self) -> & 'static str { "sf.antelope.type.v1" } fn message_name (& self) -> & 'static str { "BlockRef" } fn type_url (& self) -> & 'static str { "type.googleapis.com/sf.antelope.type.v1.BlockRef" } fn new_instance (& self , data : Vec < u8 >) -> :: std :: result :: Result < Box < dyn :: prost_wkt :: MessageSerde > , :: prost :: DecodeError > { let mut target = Self :: default () ; :: prost :: Message :: merge (& mut target , data . as_slice ()) ? ; let erased : :: std :: boxed :: Box < dyn :: prost_wkt :: MessageSerde > = :: std :: boxed :: Box :: new (target) ; Ok (erased) } fn try_encoded (& self) -> :: std :: result :: Result < :: std :: vec :: Vec < u8 > , :: prost :: EncodeError > { let mut buf = :: std :: vec :: Vec :: new () ; buf . reserve (:: prost :: Message :: encoded_len (self)) ; :: prost :: Message :: encode (self , & mut buf) ? ; Ok (buf) } } :: prost_wkt :: inventory :: submit ! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/sf.antelope.type.v1.BlockRef" , decoder : | buf : & [u8] | { let msg : BlockRef = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } } } ;
